{"meta":{"title":"Dominic Blog","subtitle":"Study & Develop iOS","description":"Development iOS","author":"도미닉","url":"https://appleceo.github.io","root":"/"},"pages":[{"title":"All categories","date":"2019-06-08T14:48:11.000Z","updated":"2021-07-13T05:30:19.399Z","comments":true,"path":"categories/index.html","permalink":"https://appleceo.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-06-08T14:48:04.000Z","updated":"2021-07-13T05:30:20.264Z","comments":true,"path":"tags/index.html","permalink":"https://appleceo.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Bounds 와 Frame 의 차이점","slug":"BoundsAndFrame","date":"2021-09-16T05:34:17.000Z","updated":"2021-09-16T06:20:51.350Z","comments":true,"path":"2021/09/16/BoundsAndFrame/","link":"","permalink":"https://appleceo.github.io/2021/09/16/BoundsAndFrame/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 Bounds 와 Frame 에 대해서 알아보겠습니다. 우선 Frame 이 무엇인지에 대해 정리해보겠습니다. frame 이란?The frame rectangle, which describes the view’s location and size in its superview’s coordinate system. 공식 문서에 위와 같이 설명합니다. frame 은 사각형이고 슈퍼 뷰의 좌표 체계 안에서 뷰의 위치와 사이즈를 설명한다고 합니다. 위에 설명 만으로는 명확히 frame을 이해하기 힘듭니다. 공식 문서에 아래 Discussion 도 번역해보겠습니다. Discussion이 사각형은 상위 뷰의 좌표계에서 뷰의 크기와 위치를 정의합니다.레이아웃 작업 중에 이 사각형을 사용하여 뷰의 크기와 위치를 설정합니다.이 속성을 설정하면 center 프로퍼티에 지정된 위치가 변경되고 이에 따라 경계 사각형의 크기가 변경됩니다.프레임 사각형의 좌표는 항상 포인트로 지정됩니다. 의존성 주입이란?의존성 주입은 의존성을 분리시켜 사용합니다 위에 우리가 작성했던 코드들은 상위 계층(Programmer)이 하위 계층(Coffee) 에 의존하게 되는 상황이었습니다. 의존성 역전의 원칙을 사용해서 상위 계층인 Programmer가 하위 계층인 Coffee 로부터 독립하도록 변경해보겠습니다. 기존에는 Coffee 객체에 drink 가 없다면 Programmer 객체에서 오류 메시지가 발견됬을 것입니다. 이제 Coffee 프로토콜을 채택한 Americano 에 drink 메소드가 없다면 Americano를 선언할 때 에러가 발생하게 됩니다. 제어의 주체가 Programmer 에 있는 것이 아니라 Protocol(Coffee) 에게 있습니다. 에러 발생 시 Coffee 프로토콜만 파악하면 되니 분석이 수월해집니다. 이렇게 의존성이 분리되어 분석이 쉬워지는 것 말고도 의존성을 주입했을 때 아래와 같은 장점들이 있습니다. 의존성 주입의 장점 코드의 재사용성을 높여준다. Unit Test가 용이해진다. 객체 간의 의존성(종속성)을 줄이거나 없앨 수 있다. 객체 간의 결합도가 낮아지면서 유연한 코드를 작성할 수 있다. 코드가 단순화된다. 코드를 읽기 쉬워진다. 정리의존성 주입은 모바일 개발에서 필수적인 요소인 것 같습니다. 저도 이번 기회에 확실히 정리하고 넘어갈 수 있었습니다. 글 읽어주셔서 감사합니다. 참고https://developer.apple.com/documentation/uikit/uiview/1622621-frame https://zeddios.tistory.com/203https://zeddios.tistory.com/231","categories":[{"name":"iOS","slug":"iOS","permalink":"https://appleceo.github.io/categories/iOS/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/tags/Swift/"},{"name":"Storyboard","slug":"Storyboard","permalink":"https://appleceo.github.io/tags/Storyboard/"},{"name":"Bounds","slug":"Bounds","permalink":"https://appleceo.github.io/tags/Bounds/"},{"name":"Frame","slug":"Frame","permalink":"https://appleceo.github.io/tags/Frame/"}]},{"title":"의존성 주입","slug":"di","date":"2021-08-12T04:27:17.000Z","updated":"2021-08-12T04:27:36.071Z","comments":true,"path":"2021/08/12/di/","link":"","permalink":"https://appleceo.github.io/2021/08/12/di/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 의존성 주입에 대해서 알아보겠습니다. 우선 의존성이 무엇인지에 대해 정리해보겠습니다. 의존성이란? 위 코드와 같이 Programmer 구조체에서 startProgramming 함수가 호출되기 위해서는 Coffee 구조체가 필요합니다. 이 때 Programmer 구조체는 ‘Coffee 객체에 의존성을 가진다’라고 합니다. 위 예제에서 Coffee 구조체의 drink 메소드가 없어지거나 drink 메소드의 내용이 바뀌면 그에 따라 Programmer 의 startProgramming 메소드가 변경되어야 합니다. 이럴 때 코드의 재활용성이 떨어지고 결합도가 올라가게 됩니다. 아래에서 의존성 뒤에 붙는 주입이라는 단어에 대해서 알아보겠습니다. 주입이란? 위에 코드를 보시면 Coffee 객체를 외부에서 생성해서 Programmer 객체가 생성될 때 넣어주고 있습니다. 객체를 외부에서 넣어주는 것을 주입이라고 합니다. 이렇게 주입만으로 의존성이 줄어들었다고 할 수 있을까요? 첫 예제 코드와 똑같이 Coffee 객체의 drink 메소드가 변경되거나 제거되면 Programmer 의 startProgramming 메소드는 영향을 받을 것입니다. 주입만으로는 아직 Programmer 객체의 Coffee 객체에 대한 의존성을 줄였다고 할 수 없습니다. 의존성 주입이란?의존성 주입은 의존성을 분리시켜 사용합니다 위에 우리가 작성했던 코드들은 상위 계층(Programmer)이 하위 계층(Coffee) 에 의존하게 되는 상황이었습니다. 의존성 역전의 원칙을 사용해서 상위 계층인 Programmer가 하위 계층인 Coffee 로부터 독립하도록 변경해보겠습니다. 기존에는 Coffee 객체에 drink 가 없다면 Programmer 객체에서 오류 메시지가 발견됬을 것입니다. 이제 Coffee 프로토콜을 채택한 Americano 에 drink 메소드가 없다면 Americano를 선언할 때 에러가 발생하게 됩니다. 제어의 주체가 Programmer 에 있는 것이 아니라 Protocol(Coffee) 에게 있습니다. 에러 발생 시 Coffee 프로토콜만 파악하면 되니 분석이 수월해집니다. 이렇게 의존성이 분리되어 분석이 쉬워지는 것 말고도 의존성을 주입했을 때 아래와 같은 장점들이 있습니다. 의존성 주입의 장점 코드의 재사용성을 높여준다. Unit Test가 용이해진다. 객체 간의 의존성(종속성)을 줄이거나 없앨 수 있다. 객체 간의 결합도가 낮아지면서 유연한 코드를 작성할 수 있다. 코드가 단순화된다. 코드를 읽기 쉬워진다. 정리의존성 주입은 모바일 개발에서 필수적인 요소인 것 같습니다. 저도 이번 기회에 확실히 정리하고 넘어갈 수 있었습니다. 글 읽어주셔서 감사합니다. 참고https://velog.io/@wlsdud2194/what-is-dihttps://medium.com/@jang.wangsu/di-dependency-injection-%EC%9D%B4%EB%9E%80-1b12fdefec4f","categories":[{"name":"Architecture","slug":"Architecture","permalink":"https://appleceo.github.io/categories/Architecture/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/tags/Swift/"},{"name":"Property","slug":"Property","permalink":"https://appleceo.github.io/tags/Property/"},{"name":"Dependency","slug":"Dependency","permalink":"https://appleceo.github.io/tags/Dependency/"},{"name":"Injection","slug":"Injection","permalink":"https://appleceo.github.io/tags/Injection/"}]},{"title":"2021년 두번째 분기 회고","slug":"2021SecondquarterReview","date":"2021-07-13T06:15:20.000Z","updated":"2021-07-13T15:03:41.430Z","comments":true,"path":"2021/07/13/2021SecondquarterReview/","link":"","permalink":"https://appleceo.github.io/2021/07/13/2021SecondquarterReview/","excerpt":"","text":"안녕하세요. 도미닉입니다.올해 두번째 분기의 회고를 작성하고자 합니다.저번 분기에는 눈 앞에 있는 일들을 해결하는데 급급했습니다.이번 분기는 전체적인 시스템을 파악하는 분기였던 것 같습니다. 회고세차왕 앱 카카오페이, 네이버페이 구성결제 타입이 kcp, 페이코뿐이 없었다.카카오페이와 네이버페이를 구성했고 꽤 많은 고객 분들이 사용하고 계신다. 요청사항 구성 변경고객 분의 요청사항이 간단히 두개였는데 조금 더 세부화해서 테이블을 따로 만들어 구성하였다.생각보다 많은 분들이 요청사항은 옵션인데도 구체적으로 요청을 해주시면서 더 맞는 서비스를 받을 수 있으셨다. 결제 버튼 이동KCP, 페이코, 카카오페이, 네이버페이 결제 버튼의 위치를 오른쪽 아래로 통일하였다.기존의 코드가 많이 사용되면서 버튼의 색상과 위치가 제멋대로였는데 통일하고 위치를 오른쪽 아래로 이동해서 손으로 누르기 편하게 변경하였다. 개발 서버 이전기존 회사에 노트북에 간단히 개발 서버가 구성되어있었다.회사 건물에 네트워크를 점검하거나 문제가 생기면 개발 서버에 접속이 불가한 상황도 발생하였다.노트북이다보니 건드리거나 베터리가 꺼지면 안되었다.EC2에 인스턴스를 만들어 php, apache 를 설치하였고 php slim 도 구성하여 개발 서버를 이전하였다.노트북을 사용할 수 있어서 좋고 안정적으로 개발 서버를 운영할 수 있게 되었다. AWS ec2에 apache, php 설치해서 웹서버 구축 방법을 회사 기술블로그에 작성한 글기존에 php slim 으로 구성된 api 새로운 서버에 셋팅 방법을 회사 기술블로그에 작성한 글 푸시 개발예약 확정, 세차 시작, 세차 완료 등의 시점에 앱 푸시를 보내서 고객 분들이 세차가 언제 시작되고 마치는지 알 수 있게 되었다.배달의 민족에서 배달이 도착했을 때 푸시가 오는 것처럼 고객 분들이 “내 차가 세차되고 있구나”, “내 차의 세차가 완료되서 차를 사용할 수 있겠구나” 라고 생각하실 것을 생각하니 뿌듯하다.firebase 에서 제공하는 노드와 php 에서 푸시를 보내는 방법 공식 문서를 참고해서 구성을 하였다. node 서버에서 fcm token으로 푸시 전송 방법을 회사 기술블로그에 작성한 글 서버 및 테이블 정리AWS 에 안쓰이는 EC2 인스턴스들이 쓰이는 것들과 섞여있었다.10개 이상이 되었는데 사용하는 것들만 추리고 설명을 달았다.6개의 인스턴스만 남기고 지웠다.이 6개도 통합하고 이전하면 더 줄일 수 있을 것이다.테이블도 안쓰이는 것이 1/3 이상이었다.어떤 용도로 쓰이고 코드에서 어떻게 쓰이는지 파악하고 정리하였다.다음 분기 중에 안쓰이는 테이블들을 백업하고 지울 것이다.ERD도 그려서 테이블의 역할이 명확하게 정리하고 개발팀에 공유가 되도록 할 것이다. iOS 스터디 발표WWDC 가 끝난 후 스터디에서 돌아가면서 영상 하나씩 보고 발표를 했다.JK께서 추천해주신 What’s new in UIKit 영상을 보고 스터디에서 발표를 했다. 유튜브 영상발표 자료 정리이번 분기는 하나의 큰 기능 추가보다는 여러 부분에서 개선하고 발전시킬 수 있었던 분기였습니다.다음 분기는 이렇게 파악한 내용들을 정리하고 내실을 다지는 분기로 삼고 싶습니다.같이 일하던 개발자 분이 퇴사를 하여서 신입 개발자 분과 둘이서 앞으로 서비스를 유지보수해야 할 것 같습니다.서비스를 많이 파악하고 계셨던 분이라 퇴사하는 시점에 많이 물어보고 서버와 테이블에 대해서 인수인계를 받았습니다.앞으로 이것들을 정리하고 안정적으로 발전되도록 해야할 책임감이 많이 느껴집니다.노드를 많이 공부해야 할 것 같고 백엔드 노드, iOS 로 세차왕 고객앱을 만드는 것이 다음 분기에 큰 프로젝트입니다.신입 분도 많이 챙겨서 함께 성장하고 회사에 기여할 수 있도록 만들고 싶습니다.","categories":[{"name":"Retrospect","slug":"Retrospect","permalink":"https://appleceo.github.io/categories/Retrospect/"}],"tags":[{"name":"회고","slug":"회고","permalink":"https://appleceo.github.io/tags/회고/"}]},{"title":"2021년 첫번째 분기 회고","slug":"2021FirstquarterReview","date":"2021-03-22T05:41:20.000Z","updated":"2021-07-13T13:59:22.404Z","comments":true,"path":"2021/03/22/2021FirstquarterReview/","link":"","permalink":"https://appleceo.github.io/2021/03/22/2021FirstquarterReview/","excerpt":"","text":"안녕하세요. 도미닉입니다.오랜만에 깃허브 블로그에 글을 작성합니다.티스토리, 미디움 등 블로그를 전전하다가 개발 관련된 모든 내용은 깃허브에 모아놓는게 좋을 것 같아서,그리고 appleceo라는 서브도메인을 사용하기 위해 이 블로그에 다시 글을 작성하고자 합니다.올해 3개월동안 있었던 일들을 회고합니다. 회고DB 이전기존에 ec2에 mysql이 설치되어 있었다.ec2 인스턴스에 문제가 생기거나 mysql 자체에 문제가 생기면 DB가 다운되고 다시 시작이 되지 않아 장시간 장애가 발생한 적도 있었다.DB 이중화에 대해 알아보던 중 친구가 AWS Aurora 에 대해서 말해주었다.알아보니 RDS 를 활용해서 이중화를 하는 것이 가장 간단하고 확실한 것 같았다.공식문서와 블로그 글들을 보며 AWS RDS 로 이중화를 구성하였다. AWS Aurora 로 이중화를 하자고 사내에 제안할 때의 발표자료 장고 서버 구축회사에 장고로 만든 페이지들을 AWS에 올리지 못하고 있었다.주니어 급이 개발을 하여서 서버 환경 구축에 미숙했기 때문이다.python django gunicorn nginx 을 이용해서 서버를 구축했고 주니어 분이 개발해놓은 코드들을 올려서 안정적으로 서버에서 돌아가도록 구축하였다. 참고한 자료들 :http://dev.epiloum.net/1440https://conory.com/blog/42847https://seowoosung.github.io/architecture/2020/05/11/nginx.html 쿠폰 기능 고도화기존에 쿠폰 기능이 있긴 하였으나 제한 조건을 걸지도 못하였다.금액, 지역, 상품 제한을 걸 수 있도록 추가하여 쿠폰 기능을 고도화하였다. 세차왕 iOS 앱 개선 온보딩 페이지 추가 주문 화면에 카카오지도가 조그맣게 보이던 것을 구글 지도로 꽉 채워서 보이도록 수정 주문에 대한 리뷰 등록 시 앱 리뷰도 쓰도록 유도하는 기능 추가 외부 페이지는 팝업으로 띄우도록 수정 어드민 고도화 차량 검색 기능 추가 회원 검색 기능 추가 정리이번 분기는 회사에 적응도 많이된 시점이라 많은 일을 한 것 같습니다.추가로 대학교 동기를 회사에 추천해서 입사시키게 되었습니다.많은 일을 같이할 수 있을 것 같아서 기대됩니다.개발팀장으로서 좋은 개발 문화를 가꿔나갈 수 있도록 기여하고 싶습니다.","categories":[{"name":"Retrospect","slug":"Retrospect","permalink":"https://appleceo.github.io/categories/Retrospect/"}],"tags":[{"name":"회고","slug":"회고","permalink":"https://appleceo.github.io/tags/회고/"}]},{"title":"UIView 테두리 만드는 방법","slug":"border","date":"2020-04-01T05:36:34.000Z","updated":"2021-07-13T05:30:19.387Z","comments":true,"path":"2020/04/01/border/","link":"","permalink":"https://appleceo.github.io/2020/04/01/border/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 UIView 의 테두리를 보여주는 방법을 알아보겠습니다. UIView 를 상속받는 UIImageView, UIButton 등도 아래의 방법으로 테두리를 보여줄 수 있습니다. 테두리 만드는 방법UIView 에는 CALayer 객체인 layer 프로퍼티가 있습니다. layer 에는 borderWidth 와 borderColor 값이 있습니다. 이 값들을 변경해서 테두리를 보여줄 수 있습니다. 테두리를 두껍게 하고 싶다면 borderWidth 의 값을 원하는 만큼 설정하시면 됩니다.테두리의 색을 바꾸고 싶다면 borderColor 의 값을 원하는 색으로 설정하면 됩니다. 정리간단히 뷰의 테두리를 만드는 방법을 알아봤습니다. 질문있다면 남겨주세요. 감사합니다. 출처 : https://stackoverflow.com/questions/8162411/how-to-create-border-in-uibutton/30159869","categories":[{"name":"iOS","slug":"iOS","permalink":"https://appleceo.github.io/categories/iOS/"}],"tags":[{"name":"테두리","slug":"테두리","permalink":"https://appleceo.github.io/tags/테두리/"},{"name":"border","slug":"border","permalink":"https://appleceo.github.io/tags/border/"},{"name":"UIView","slug":"UIView","permalink":"https://appleceo.github.io/tags/UIView/"},{"name":"UILabel","slug":"UILabel","permalink":"https://appleceo.github.io/tags/UILabel/"},{"name":"UIButton","slug":"UIButton","permalink":"https://appleceo.github.io/tags/UIButton/"},{"name":"layer","slug":"layer","permalink":"https://appleceo.github.io/tags/layer/"}]},{"title":"Xcode ModuleNotFoundError: 파이썬 오류","slug":"ModuleNotFoundError","date":"2020-03-19T02:27:53.000Z","updated":"2021-07-13T05:30:19.384Z","comments":true,"path":"2020/03/19/ModuleNotFoundError/","link":"","permalink":"https://appleceo.github.io/2020/03/19/ModuleNotFoundError/","excerpt":"","text":"안녕하세요 도미닉입니다. 오늘 겪게 된 오류와 해결 방법을 공유하고자 합니다. 배경을 설명드리자면 오래된 iOS 프로젝트를 xcode 로 열었습니다. 빌드 버튼을 눌렀는데 xcode 가 파이썬 파일을 실행하는데 파이썬 쪽에서 오류를 발견했습니다. 오류ModuleNotFoundError: gspreadModuleNotFoundError: oauth2client 위와 같은 오류가 발생했습니다. xcode 의 어디선가 파이썬 코드를 실행시키고 있는데 이 파이썬에서 모듈을 못찾는다는 에러였습니다. 파이썬2 와 파이썬3 를 깔아보고 환경변수를 설정해보았습니다. 못찾는 모듈을 파이썬 2에도 설치해보고 파이썬 3에도 설치해봤지만 해결되지 않았습니다. 해결방법주변에 도움을 받아 파이썬이 어디서 실행되는지 찾을 수 있었습니다. 프로젝트 - Build Phases - Localization Run Script 에서 파이썬3 를 실행하고 있었습니다. 위와 같이 Run script only when installing 항목을 체크하니 오류가 발생하지 않았습니다. 정리저도 운이 좋아서 해결할 수 있는 문제였습니다. 혹시 비슷한 상황이 발생한다면 위와 같이 해보시길 바랍니다. 감사합니다.","categories":[{"name":"solve","slug":"solve","permalink":"https://appleceo.github.io/categories/solve/"}],"tags":[{"name":"solve","slug":"solve","permalink":"https://appleceo.github.io/tags/solve/"},{"name":"xcode","slug":"xcode","permalink":"https://appleceo.github.io/tags/xcode/"},{"name":"python","slug":"python","permalink":"https://appleceo.github.io/tags/python/"},{"name":"module","slug":"module","permalink":"https://appleceo.github.io/tags/module/"},{"name":"error","slug":"error","permalink":"https://appleceo.github.io/tags/error/"},{"name":"gspread","slug":"gspread","permalink":"https://appleceo.github.io/tags/gspread/"},{"name":"oauth2client","slug":"oauth2client","permalink":"https://appleceo.github.io/tags/oauth2client/"},{"name":"ModuleNotFoundError: gspread","slug":"ModuleNotFoundError-gspread","permalink":"https://appleceo.github.io/tags/ModuleNotFoundError-gspread/"},{"name":"ModuleNotFoundError: oauth2client","slug":"ModuleNotFoundError-oauth2client","permalink":"https://appleceo.github.io/tags/ModuleNotFoundError-oauth2client/"}]},{"title":"스택(stack)","slug":"stack","date":"2020-02-09T07:25:33.000Z","updated":"2021-07-13T05:30:19.395Z","comments":true,"path":"2020/02/09/stack/","link":"","permalink":"https://appleceo.github.io/2020/02/09/stack/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 스택에 대해서 알아보겠습니다. 스택에 대해서 들어본 분들도 많으실 겁니다. 확실히 알고 넘어가죠! Stack 이란 무엇인가?쌓는 것을 스택이라고 한다. 일상에서 우리는 무언가를 쌓고 또 쓰러뜨린다. 뷔페에 갔을 때 접시가 가지런히 쌓여있는 것도 Stack 이다. 책을 쌓아놓는 것도 Stack 이고 프린터 입구에 종이 여러 장이 쌓여있는 것도 Stack 이다. Stack 은 어떻게 동작하는가?뷔페에서 접시가 쌓여있을 때 가장 아래부터 접시를 가져가는 사람은 아마 없을 것이다. 일반적으로 Stack 은 First In Last Out 이다. 먼저 쌓은 것(예를 들면 가장 아래에 있는 접시)이 가장 나중에 사용된다. 가장 위에 뭔가를 쌓는 것을 push, 가장 위에 있는 것을 가져가는 것을 pop 이라고 한다. iOS 에서 addSubview 메소드를 통해 뷰 위에 뷰를 쌓는 것도 스택이다. Swift 로 Stack 구현하는 방법은 무엇인가? 배열을 이용해 간단하게 Stack 을 구현해보았다. 이런 식으로 push, pop 을 동작하게 만들면 그것을 어떻게 만들던 Stack 이라고 할 수 있다. 정리스택에 대해서 알아봤습니다. 뭔가를 쌓고 가장 위에 있는 것부터 사용하는 것은 일상적인 행동입니다. 이러한 행동에서 영감을 얻어 자료를 쌓고 가장 위에부터 빼서 사용하도록 컴퓨터 상에 구성한 것이 Stack 입니다. 어렵지 않고 편하게 사용할 수 있도록 연습해야겠습니다. 감사합니다.","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://appleceo.github.io/categories/DataStructure/"}],"tags":[{"name":"stack","slug":"stack","permalink":"https://appleceo.github.io/tags/stack/"},{"name":"swift","slug":"swift","permalink":"https://appleceo.github.io/tags/swift/"},{"name":"data structure","slug":"data-structure","permalink":"https://appleceo.github.io/tags/data-structure/"}]},{"title":"UIView 모서리 둥글게 만드는 방법","slug":"cornerRadius","date":"2020-01-03T11:52:34.000Z","updated":"2021-07-13T05:30:19.388Z","comments":true,"path":"2020/01/03/cornerRadius/","link":"","permalink":"https://appleceo.github.io/2020/01/03/cornerRadius/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 UIView 의 모서리를 깍아서 둥글게 만드는 방법을 알아보겠습니다. UIView 를 상속받는 UIImageView, UIButton 등도 아래의 방법으로 모서리를 둥글게 할 수 있습니다. 모서리 둥글게 만드는 방법UIView 에는 CALayer 객체인 layer 프로퍼티가 있습니다. layer 에는 cornerRadius 와 masksToBounds 값이 있습니다. 이 값들을 변경해서 모서리를 둥글게 만들 수 있습니다. 모양을 원으로 싶다면 UIView 의 길이의 반만큼 cornerRadius 를 설정하시면 됩니다. 정리간단히 뷰의 모서리를 둥글게 만드는 방법을 알아봤습니다. 질문있다면 남겨주세요. 감사합니다. 출처 : http://blog.naver.com/PostView.nhn?blogId=hjleesm&amp;logNo=221298790719&amp;redirect=Dlog&amp;widgetTypeCall=true&amp;directAccess=false","categories":[{"name":"iOS","slug":"iOS","permalink":"https://appleceo.github.io/categories/iOS/"}],"tags":[{"name":"UIView","slug":"UIView","permalink":"https://appleceo.github.io/tags/UIView/"},{"name":"bounds","slug":"bounds","permalink":"https://appleceo.github.io/tags/bounds/"},{"name":"cornerRadius","slug":"cornerRadius","permalink":"https://appleceo.github.io/tags/cornerRadius/"},{"name":"masksToBounds","slug":"masksToBounds","permalink":"https://appleceo.github.io/tags/masksToBounds/"}]},{"title":"복잡도(Complexity)","slug":"Complexity","date":"2020-01-02T03:23:38.000Z","updated":"2021-07-13T05:30:19.379Z","comments":true,"path":"2020/01/02/Complexity/","link":"","permalink":"https://appleceo.github.io/2020/01/02/Complexity/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 복잡도에 대해서 알아보겠습니다. 복잡도란 무엇인가복잡도는 확장성과 관련이 깊다. 확장이 가능하냐는 질문은 소프트웨어 개발을 할 때 반복되는 질문 중 하나이다. 만약 10분 안에 처리되야하는 소프트웨어가 100분이 걸리게 된다면 이것은 확장성에 위배된다고 할 수 있다. 하지만 데이터의 양에 따라 10분이라는 시간은 상대적일 것이다. 이럴 때 우리는 복잡도를 활용한다. 복잡도에는 시간 복잡도(Time complexity)와 공간 복잡도(Space complexity)가 있다. 시간 복잡도란 무엇인가시간 복잡도는 입력되는 데이터의 양이 증가함에 따라 알고리즘이 실행되는데 필요한 시간을 나타낸 것이다. 시간 복잡도의 종류에는 Constant time, Linear time, Quadratic time, Logarithmic time, Quasilinear time 등이 있다. Constant time 이란 무엇인가Constant 은 번역하면 일정한 이라는 형용사이다. 입력되는 사이즈와 상관없이 일정한 시간을 가지는 시간 복잡도이다. 빅오표기법으로 O(1) 이다. 예제 소스는 아래와 같다. 데이터의 증가에 따라 시간의 증가를 나타내는 표는 아래와 같다. Linear time 이란 무엇인가Linear 은 번역하면 선형이라는 뜻이다. 가장 일반적인 것으로 데이터의 양이 증가함에 따라 시간도 균등하게 증가하는 시간 복잡도이다. 빅오표기법으로 O(N) 이다. 예제 소스는 아래와 같다. 데이터의 증가에 따라 시간의 증가를 나타내는 표는 아래와 같다. Quadratic time 이란 무엇인가Quadratic 은 번역하면 이차라는 뜻이다. 이차라는 말에서 예상할 수 있듯이 데이터의 양이 증가함에 따라 제곱 꼴로 증가해가는 시간 복잡도이다. 빅오표기법으로 O(N제곱) 이다. 예제 소스는 아래와 같다. Logarithmic time 이란 무엇인가Logarithmic 은 번역하면 대수라는 뜻이다. Logarithmic 에서 앞에 세글자만 보면 log 이다. 그렇다. Logarithmic 은 로그와 관련이 있다. 빅오표기법으로 O(logN) 이다. 예제 소스는 아래와 같다. Quasilinear time 이란 무엇인가준선형 시간이다. 빅오표기법으로 O(NlogN) 이다. 공간 복잡도(Space comlexity) 란 무엇인가시간과 마찬가지로 공간 또한 확장의 주요 요소이다. 공간 복잡도는 소프트웨어가 메모리를 얼마나 차지하는지에 대한 지표이다. 위의 예제소스의 공간 복잡도는 O(N) 이다. 같은 기능을 하지만 더 긴 아래 예제소스의 공간 복잡도는 O(1) 이다. 정리 시간 복잡도는 입력 크기가 증가함에 따라 알고리즘을 실행하는 데 필요한 시간을 측정한 것이다. 공간 복잡도는 알고리즘을 실행하는 데 필요한 메모리를 측정한 것이다. Big O 표기법은 일반적인 형태의 시간 및 공간 복잡성을 나타내는 데 사용한다. 시간과 공간의 복잡성은 높은 수준의 확장성의 척도이다. 알고리즘 자체의 실제 속도는 측적하지 않아도 된다. 작은 데이터 세트의 경우 시간복잡도와 일반적으로 관련이 없다. 준선형 알고리즘음이 선형 알고리즘 보다 느릴 수 있다.","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://appleceo.github.io/categories/Algorithm/"}],"tags":[{"name":"complexity","slug":"complexity","permalink":"https://appleceo.github.io/tags/complexity/"},{"name":"time","slug":"time","permalink":"https://appleceo.github.io/tags/time/"},{"name":"space","slug":"space","permalink":"https://appleceo.github.io/tags/space/"}]},{"title":"스토리보드에서 네비게이션 뷰 scene 의 타이틀 설정하기","slug":"storyboardSceneRename","date":"2019-12-28T04:38:29.000Z","updated":"2021-07-13T05:30:19.396Z","comments":true,"path":"2019/12/28/storyboardSceneRename/","link":"","permalink":"https://appleceo.github.io/2019/12/28/storyboardSceneRename/","excerpt":"","text":"안녕하세요. 도미닉입니다. 스토리보드를 사용하다보면 뷰 컨트롤러가 늘어나서 복잡해질 수 있습니다. 그럴 때 Scene 의 이름을 지정해줄 수 있으면 혼동을 줄일 수 있습니다. scene 의 이름 설정하기 Navigation Item 을 추가해서 텍스트 수정하기 뷰컨트롤러를 선택하고 어튜리뷰트 인스펙터 - Title 수정하기 정리위의 두가지 방법으로 네비게이션 컨트롤러와 연결된 뷰들의 타이틀을 설정할 수 있었습니다. 감사합니다.","categories":[],"tags":[{"name":"scene","slug":"scene","permalink":"https://appleceo.github.io/tags/scene/"},{"name":"화면","slug":"화면","permalink":"https://appleceo.github.io/tags/화면/"},{"name":"이름","slug":"이름","permalink":"https://appleceo.github.io/tags/이름/"},{"name":"변경","slug":"변경","permalink":"https://appleceo.github.io/tags/변경/"},{"name":"스토리보드\"","slug":"스토리보드","permalink":"https://appleceo.github.io/tags/스토리보드/"},{"name":"storyboard","slug":"storyboard","permalink":"https://appleceo.github.io/tags/storyboard/"},{"name":"title","slug":"title","permalink":"https://appleceo.github.io/tags/title/"},{"name":"label","slug":"label","permalink":"https://appleceo.github.io/tags/label/"},{"name":"navigation item","slug":"navigation-item","permalink":"https://appleceo.github.io/tags/navigation-item/"}]},{"title":"Xcode 스토리보드 테두리 보이도록 설정하기","slug":"boundsRectangles","date":"2019-12-27T16:54:30.000Z","updated":"2021-07-13T05:30:19.387Z","comments":true,"path":"2019/12/28/boundsRectangles/","link":"","permalink":"https://appleceo.github.io/2019/12/28/boundsRectangles/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 Xcode 에서 스토리보드에 테두리를 보이도록 설정하는 방법을 공유하겠습니다. Label 을 사용할 때 이 레이블이 어디에서 끝나는지 알기 어렵습니다. 오토레이아웃이 제대로 적용이 됬는지 확인하려면 직접 긴 텍스트를 입력해야 했습니다. 꼼꼼한 재은씨 실전편을 보다가 Xcode 에서 테두리를 보이게 설정하는 방법이 있다는 것을 알았습니다. Xcode 스토리보드 테두리 보이도록 설정하기 Xcode 실행 후 상단에 메뉴에서 Editor - Canvas - Bounds Rectangles 선택하시면 됩니다. 위에 이미지에서 보실 수 있듯이 비어있던 Label 의 테두리에 윤곽선이 드러나면서 오토레이아웃이 제대로 적용이 된 것을 알 수 있습니다. 글 읽어주셔서 감사합니다.","categories":[{"name":"Xcode","slug":"Xcode","permalink":"https://appleceo.github.io/categories/Xcode/"}],"tags":[{"name":"Storyboard","slug":"Storyboard","permalink":"https://appleceo.github.io/tags/Storyboard/"},{"name":"테두리","slug":"테두리","permalink":"https://appleceo.github.io/tags/테두리/"},{"name":"Xcode","slug":"Xcode","permalink":"https://appleceo.github.io/tags/Xcode/"},{"name":"bounds","slug":"bounds","permalink":"https://appleceo.github.io/tags/bounds/"},{"name":"rectangles","slug":"rectangles","permalink":"https://appleceo.github.io/tags/rectangles/"},{"name":"스토리보드","slug":"스토리보드","permalink":"https://appleceo.github.io/tags/스토리보드/"},{"name":"설정","slug":"설정","permalink":"https://appleceo.github.io/tags/설정/"},{"name":"setting","slug":"setting","permalink":"https://appleceo.github.io/tags/setting/"}]},{"title":"iOS 테이블뷰 구분선 안보이도록 설정하는 방법","slug":"tableViewSeparatorRemove","date":"2019-12-25T16:19:15.000Z","updated":"2021-07-13T05:30:19.397Z","comments":true,"path":"2019/12/26/tableViewSeparatorRemove/","link":"","permalink":"https://appleceo.github.io/2019/12/26/tableViewSeparatorRemove/","excerpt":"","text":"안녕하세요. 도미닉입니다. 테이블뷰를 만들다가 보면 셀 사이에 구분선이 생깁니다. 이 구분선을 지우고 싶은 경우가 있는데요. 구분선을 지우는 방법에 대해서 알려드리겠습니다. chatTableView.separatorColor = UIColor.white 배경 색이 흰색이라면 구분선의 색이 흰색이 되면 안보이게 되겠죠.위에 코드처럼 tableView 의 separatorColor 를 배경색과 같은 색(보통 흰색)으로 바꿔주면 구분선이 보이지 않습니다. chatTableView.separatorStyle = .none 구분선의 스타일을 없도록 구성해줄 수도 있습니다.위에 코드처럼 tableView 의 separatorStyle 을 .none 으로 바꿔주면 구분선이 보이지 않습니다. 간단하게 두가지 방법 알아봤습니다. 감사합니다.","categories":[],"tags":[]},{"title":"2019년 11월 네번째 주 회고","slug":"201911-LastWeek","date":"2019-11-30T14:43:20.000Z","updated":"2021-07-13T05:30:19.377Z","comments":true,"path":"2019/11/30/201911-LastWeek/","link":"","permalink":"https://appleceo.github.io/2019/11/30/201911-LastWeek/","excerpt":"","text":"안녕하세요. 도미닉입니다. 이번주의 회고와 이주의 읽은 책 독후감을 작성해보았습니다. 회고여러군데 회사 지원원티드에서 18군데 회사에 지원하였다. 온라인 RxSwift 스터디 참여야신님께서 클린 아키텍처 관련 발표를 해주셨다. 독후감 - RxSwift - Reactive Programming with Swift by Martin TodorovRxSwift 를 공부하면서 봤던 책을 다시 한번 전체를 읽어보았다. https://github.com/fimuxd/RxSwift 번역되어 있고 잘 정리되있는 위 레포지토리에서 읽었다. 다시 한번 읽으니 조금 더 이해가 많이 된 것 같다. 조금 더 공부하고 정리해서 블로그에 공유해야겠다. 다음주 계획월 - 면접이력서 쓰기알고리즘 공부","categories":[{"name":"Retrospect","slug":"Retrospect","permalink":"https://appleceo.github.io/categories/Retrospect/"}],"tags":[{"name":"회고","slug":"회고","permalink":"https://appleceo.github.io/tags/회고/"},{"name":"독후감","slug":"독후감","permalink":"https://appleceo.github.io/tags/독후감/"}]},{"title":"2019년 11월 세번째 주 회고","slug":"201911-ThirdWeek","date":"2019-11-24T15:08:20.000Z","updated":"2021-07-13T05:30:19.377Z","comments":true,"path":"2019/11/25/201911-ThirdWeek/","link":"","permalink":"https://appleceo.github.io/2019/11/25/201911-ThirdWeek/","excerpt":"","text":"안녕하세요. 도미닉입니다. 이번주의 회고와 이주의 읽은 책 독후감을 작성해보았습니다. 회고resume 작성포트폴리오로 제출한 resume 저장소의 readme를 작성하였다. https://github.com/AppleCEO/resume DDD 전체 모임 참석DDD 동아리 전체 모임에 참석하였다. 2팀 씩 같이 앉아서 각 팀의 아이디어나 진행상황을 공유하는 모임이었다. 우리와 짝을 이룬 팀에서는 이야기하기를 꺼려하셔서 아쉬웠다. 알고리즘 문제풀이Swift 알고리즘 오픈채팅방에 참여하였다. 어려운 문제, 쉬운 문제 하루에 하나씩 내주면 푸는 방이다. 쉬운 문제의 출제를 맡게 되었다. 매일 문제를 풀고 그 중에 괜찮은 문제를 공유하도록 해야겠다. 문제를 출제함으로서 나도 매일 공부할 수 있고 구성원들에게 도움이 될 수 있어서 좋았다. 이력서 제출두 군데 회사의 채용 공고를 보고 입사 지원했다. 4월부터 공부를 오래 했다고 생각한다. 업무의 압박에서 벗어나 성장할 수 있는 좋은 시간이었다. 이제 괜찮은 회사에 들어가서 오랫동안 일을 할 준비가 됬다. 0차 탈락을 하지 않으려면 지원을 해야한다. 여러 회사를 찾아보고 지원을 지속적으로 해야겠다. 독후감 - 비커밍 스티브 잡스책이 굉장히 두꺼워서 이번주에 다른 공부는 많이 못하고 독서를 많이 했다. 존경하는 스티브 잡스에 대해 사소한 부분까지 작성되어 있어서 좋았다. 글쓴이는 기자인데 스티브 잡스와 밀접한 사이였다. 스티브 잡스는 자신의 회사와 제품을 홍보하는데 글쓴이를 활용했고 글쓴이 또한 최신의 정보와 애플의 상세한 부분까지 취재를 할 수 있는 윈윈 관계였다. 글쓴이 자신이 취재한 내용들을 자신의 관점에서 상세하게 정리해놓았다. 영화나 아이 작슨의 책은 스티브 잡스를 굉장히 냉정하고 거진 성격 파탄자처럼 그려놓는다. 스티브 잡스는 창업 초기에 그러한 성격 상 문제를 드러내기도 했으나 다시 애플에 복귀한 뒤로는 소리를 지르거나 말도 안되는 일정에 맞춰서 개발을 추진하는 CEO 가 더는 아니었다. 팀쿡은 아이작슨이 쓴 스티브 잡스 책을 싫어한다고 한다. 그것은 떠도는 가쉽들을 모아놓은 모음집에 불과하다고 말한다. 비커밍 스티브 잡스를 통해 스티브 잡스가 뛰어난 CEO 가 되는 성장 과정을 볼 수 있어서 좋았다. 내 꿈은 애플 CEO 이다. 다음주 계획RxSwift 책 읽기일요일 - 전주 여행?이력서 쓰기알고리즘 공부","categories":[{"name":"Retrospect","slug":"Retrospect","permalink":"https://appleceo.github.io/categories/Retrospect/"}],"tags":[{"name":"회고","slug":"회고","permalink":"https://appleceo.github.io/tags/회고/"},{"name":"독후감","slug":"독후감","permalink":"https://appleceo.github.io/tags/독후감/"}]},{"title":"2019년 11월 두번째 주 회고","slug":"201911-SecondWeek","date":"2019-11-18T07:35:20.000Z","updated":"2021-07-13T05:30:19.377Z","comments":true,"path":"2019/11/18/201911-SecondWeek/","link":"","permalink":"https://appleceo.github.io/2019/11/18/201911-SecondWeek/","excerpt":"","text":"안녕하세요. 도미닉입니다. 이번주의 회고와 이주의 읽은 책 독후감을 작성해보았습니다. 회고객체지향 온라인 스터디 참석오브젝트 5강을 온라인 스터디 참여하는 분들과 같이 듣고 의견을 공유했다. Let’swift 2019 참석처음으로 렛츠스위프트에 참석했다. JK 와 야곰을 오랜만에 뵈서 반가웠다. 후기 : https://appleceo.github.io/2019/11/17/letswift2019/ Let us go 2019 fall 참석토요일에 렛어스고를 두번째로 참석했다. 많은 분들과 친해질 수 있었다. 후기 : https://appleceo.github.io/2019/11/17/letusgo2019Fall/ RxSwift 오프라인 모임 참석마지막 장인 24장을 공부했다. 나왔던 거의 모든 개념이 나오면서 프로젝트를 완성해가는 장이었다. 조장희님께서 발표해주셨다. 소스를 보면서 다시 한번 공부해봐야겠다. 독후감 - 빅 너드 랜치의 스위프트 프로그래밍두꺼운 스위프트 책이라서 1주일 안에 보기에 힘들었다. 프로그램을 작성하는 예제들은 최대한 넘어가고 훑어보듯이 읽어보았다. 각 장의 예제들은 시간 날 때마다 Xcode 에 입력해봐야겠다. 어려운 개념들을 쉽게 설명해서 풀어놓은 책이었다. 모르거나 헷갈렸던 개념들을 다시 잡을 수 있었다. 다음주 계획비커밍 스티브잡스 책 읽기월요일 - 객체지향 온라인 스터디 참석(코드스피츠 오브젝트 6강)수요일 - RxSwift 온라인 스터디 참석토요일 - DDD 전체 모임 참석","categories":[{"name":"Retrospect","slug":"Retrospect","permalink":"https://appleceo.github.io/categories/Retrospect/"}],"tags":[{"name":"회고","slug":"회고","permalink":"https://appleceo.github.io/tags/회고/"},{"name":"독후감","slug":"독후감","permalink":"https://appleceo.github.io/tags/독후감/"}]},{"title":"let us go 2019 Fall review","slug":"letusgo2019Fall","date":"2019-11-17T13:49:19.000Z","updated":"2021-07-13T05:30:19.392Z","comments":true,"path":"2019/11/17/letusgo2019Fall/","link":"","permalink":"https://appleceo.github.io/2019/11/17/letusgo2019Fall/","excerpt":"","text":"안녕하세요. 어제는 let us: go 2019 fall 세미나에 참석했습니다. 두번째로 참석한 렛어스고 세미나였습니다. 행사 장소가 너무나 멋졌고 뒤풀이에서 많은 분들과 만나서 이야기 나눌 수 있어서 좋았습니다. 행사 후기를 적어보고자 합니다. 첫번째 세션 주니어 개발자 해외 취업기[독일, 비전공자] 도길참새 도길참새님께서 독일에서 오셔서 발표해주셨습니다. 베를린에서 코리안 바베큐가 유행이라면서 분위기를 말랑말랑하게 하면서 발표를 시작해주셨습니다. 현재 베를린에 거주하고 있다고 하십니다. 독일에 가신 이유는 한국에서 나가고 싶어서 였다고 합니다. 준비를 하려고 하니 진행이 안되서 무작정 비행기표를 끊었다고 하셨습니다. 남편 분이 한국에서 개발자 10년을 하시고 독일에 가신거라고 합니다. 남편 분은 2주 만에 잡 오퍼를 받았다고 하십니다. 베를린은 집을 구하기가 힘든데 2주만에 집도 구했다고 합니다. 도길참새님은 우리나라에서 기획 경력이 있으셔서 기획으로 지원을 했는데 잘 안됬다고 하십니다. 그러던 와중에 남편 분이 하는 개발이 재밌어 보였다고 하십니다. 책을 보고 공부하는 것보다 프로젝트를 만들어보면서 실력이 빨리 늘으셨다고 합니다. 처음에는 합격될 것 같은 곳만 넣었다고 하십니다. 하지만 합격을 결정하는 것은 상대방임을 깨닫고 나서 아무데나 막 넣기 시작하셨다고 합니다. 시니어를 뽑는데도 지원하셨다고 합니다. 어디든 되고 봐야 한다고 하셨고 인턴 모집 안해도 막 넣어보았다고 합니다. 쫄지말고 넣고 면접보라고 하셨습니다. 테크니컬 인터뷰 - UI 디자이너 - 헤드까지 4시간 가량 이어지는 면접에서 테크니컬 인터뷰가 망했다고 하십니다. 집에 돌아가지 않고 인터뷰 경험, 영어 경험을 쌓자고 하면서 편하고 재미있게 있는 그대로 이야기하셨다고 합니다. 아는 것은 안다고 하고 모르는 것은 모른다고 하셨다고 합니다. 면접은 굉장한 정보의 비대칭에서 시작한다고 하셨습니다. 독일 생활에 굉장히 만족하고 있다고 하십니다. 예약을 해야지 뭐든지 할 수 있고 예약 대기가 오래 걸린다고 합니다. 종이로 모든 일이 처리된다고 합니다. 인종차별도 조금 있다고 합니다. 자유롭고 여유로워서 다양한 취향들을 존중해주는 분위기라고 합니다. 법이나 규범이 사람을 향해 있다는 느낌을 받았다고 하십니다. 독일에 나가고 싶다는 생각이 들 정도로 재밌고 좋은 발표였습니다. 두번째 세션 커스텀 오퍼레이터 곰튀김 커스텀 오퍼레이터에 대해서 곰튀김님께 발표해주셨습니다. 커스텀 오퍼레이터에 대해서는 이미 알고 있었습니다. view 에 연산을 하는 것이 신선했습니다. 2번째 문제를 맞춰서 야곰의 스위프트5 책을 받을 수 있었습니다! 다시 한번 커스텀 오퍼레이터에 대해 상기할 수 있었고 새로운 내용을 알게 되어서 기뻤습니다. 세번째 세션 fastlane init Swift 윤병훈 보맵에 윤병훈님께서 발표해주셨습니다. Fastlane 에 대해서 대략 알고 있었지만 어떻게 사용할 수 있고 어떤 역할을 하는지 명확하게 알지는 못했습니다. Fastlane 에 대한 간단한 소개부터 사용 방법들을 알려주셔서 좋았습니다. 아래 내용은 발표를 들으며 정리한 내용입니다. 대부분의 CI 시스템에서 사용 가능함Match 팀 인증서 및 프로파일 관리 및 동기화 Private 레포에 인증서를 올려서 관리한다고 함 Scan : 테스트 자동화 도구HTML, JSON Report 지원Slack 메시지로 테스트 결과 보낼 수 있음 Gym : Build : package Snapshot 해상도 별 스크린샷 지역화 스크린샷 Crashlytics베타 테스트PilottestFlight에서 테스트하도록 업로드Deliver Metadata Upload App Package Upload HTML Preview precheck - 앱 제출 전 사전검사, 메타데이터, 앱내구매 확인 Notifications Slack Malign Twitter 간식과 함께하는 네트워킹구인구직 쪽에 관심이 많아서 그 쪽에 가서 이야기를 나눴습니다. 마기님이 당근마켓의 채용에 대해서 간단히 설명해주셨습니다. 민소네님께서 카카오뱅크의 채용에 대해서 간단히 설명해주셨습니다. 쿠우님께서 하이퍼커넥트의 채용에 대해서 간단히 설명해주셨습니다. 클린트님께서 스타트업과 프리랜서에 대해서 이야기해주셨습니다. 다방에서 오신 분도 채용에 대해서 이야기하셨습니다. 마기님을 실제로 뵈어서 신기했고 재밌었습니다. 네번째 세션 Static Framework와 Dynamic Framework 그리고 Encapsulation 민소네 민소네님께서 스테틱 프레임워크, 다이나믹 프레임워크의 차이에 대해서 셜명해주셨습니다. 다이나믹 프레임워크에는 다이나믹 라이브러리가 있고 스테틱 프레임워크에는 스테틱 라이브러리가 있다고 합니다. 어떤 식으로 프레임워크를 구성하는 것이 좋은지에 대한 이야기였습니다. 아직 프레임워크를 파본 적이 없어서 많이 알아들을 수는 없었습니다. tree 명령어 등으로 프레임워크에 대해서 알아볼 수 있는 방법을 알려주셨습니다. 라이브러리와 프레임워크를 파악해서 원하는 부분만 가져다 쓰는 식으로 사용해봐야겠습니다. 다섯번째 세션 Swift 개발이 좋아요 클린트 클린트님께서 발표해주셨습니다. 클린트님이 화요일에 있었던 렛츠스위프트에서 먼저 알아봐주시고 인사해주셔서 안면이 있었습니다. 스위프트를 좋아하는 이유에 대해서 말씀해주셨습니다. 스위프트를 할 때 돈을 잘 번다고 하십니다. 재미있고 부드러운 분위기에서 스위프트의 장점 단점 등을 이야기하는 시간이었습니다. 조금은 어설픈 듯 하지만 순수하신 모습에 분위기가 좋았습니다. 여섯번째 세션 디버깅 시작해버깅 가은 가은님께서 발표해주셨습니다. 디버깅에서 LLDB 의 대부분에 명령어를 소개해주셨습니다. 아래는 간단한 메모입니다. (lldb) help breakpointApropos “reference count” 특정 Condition : 만족할 때만 BreakIgnore 특정 횟수만큼 무시Action 수행 후 프로그램 계속 실행 쉐어 브레이크 포인트하면 깃에 공유 가능 모듈에 내가 만든 모듈을 넣어주면 해당하는 라이브러리에 있는 함수에만 걸린다. Watchpoint 는 Breakpoint의 일종으로 언제 값이 바뀌는지 볼 수 있다. RefcountRef 카운트 확인 Image list모든 Module 의 정보 출력 image lookup Image dump symtab Alamofire -s address po [[UIWindow keyWindow] autolayoutTrace]Po [UIViewController … Command alias별명을 정해서 짧게 실행할 수 있다. /.lldbinit 에 자주 쓰는 별명을 넣어줄 수 있다. SetBacktrace를 심볼리틱? Keychain 일곱번째 세션 내 소스를 오픈하면 생기는 일 염염 카카오에 염염님께서 발표해주셨습니다. 코코아팟에 라이브러리 업로드 방법부터 스위프트 프로젝트 매니저를 사용하는 방법까지 오픈소스에 대해 얘기해주셨습니다. 소스를 오픈함으로써 조금 더 찾아서 공부하게 되고 책임감있게 소스를 짜게 되셨다고 합니다. 깃허브에 팔로우를 하고 있었는데 실제로 뵙게 되어서 반가웠습니다. 오늘 저를 팔로우해주셨는데 기분이 좋았습니다. 라이브러리를 오픈하고 렛어스고에서 발표할 때까지 더 노력해야겠습니다. 정리두번째로 참석한 렛어스고라서 그런지 조금 더 편했고 많은 분들과 인사를 나눴던 것 같습니다. 뒤풀이에가서 또 여러분을 만날 수 있어서 좋았습니다. 앞으로 이런 행사가 있다면 뒤풀이에 가는 것이 좋겠습니다. 쿠우님, 키윈도우님과 스테프 분들 고생하셨습니다. 읽어주셔서 감사합니다.","categories":[{"name":"Seminar","slug":"Seminar","permalink":"https://appleceo.github.io/categories/Seminar/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/tags/Swift/"},{"name":"iOS","slug":"iOS","permalink":"https://appleceo.github.io/tags/iOS/"},{"name":"Seminar","slug":"Seminar","permalink":"https://appleceo.github.io/tags/Seminar/"}]},{"title":"let'swift 2019 review","slug":"letswift2019","date":"2019-11-17T11:49:31.000Z","updated":"2021-07-13T05:30:19.391Z","comments":true,"path":"2019/11/17/letswift2019/","link":"","permalink":"https://appleceo.github.io/2019/11/17/letswift2019/","excerpt":"","text":"안녕하세요. 도미닉입니다. 이번주 화요일에 렛츠스위프트에 처음으로 참여해봤습니다. 그에 대한 리뷰를 작성해보겠습니다. Let’swift첫번째 발표레이니스트에 박보영님께서 발표해주셨습니다. RxSwift 에서 Combine 으로 바꾸는 내용들에 대해서 간략하게 설명해주셨습니다. RxSwift 와 Combine 둘 다 관심가는 주제라서 재미있게 들었습니다. 두번째 발표라인비즈플러스에 백성욱님께서 발표해주셨습니다. 그래픽 쪽으로 공부를 많이 하신 분이였습니다. 그래픽과 에니메이션에 대해서 심도깊은 이야기를 해주셨습니다. 아래는 말씀해주신 내용들입니다. UIBezierPath 그라데이션을 주려면 CAGradiention Layer 를 사용해야한다. Location 은 첫번재 칼라의 위치이다. 세번째 발표야놀자에 강승철님께서 발표해주셨습니다. 아래는 말씀해주신 내용들입니다. CADisplayLink Looper 보고 있는데 버튼이 움직이면 기분 나쁨 로그를 찍을 때 section 3 부터 찍힘(DI팀이 좋아한다) -&gt; 안보이는 영역에 있었을 때 문제 Render 에서 전체가 다 fetch 된 다음에 다 보여주게 할 수 있다. (한번에 여러개가 보여지면 랙이 발생함, section1이 보여질 수 있음에도 불구하고 기다려야한다) 워크샵 첫번째 시간점심 시간 이후에 워크샵 발표를 들었습니다. 라인비즈플러스에 최완복님께서 발표해주셨습니다. 아래는 말씀해주신 내용을 메모한 것입니다. 좋은 코드란 Readability 가 좋다 Solid 원칙을 잘 지켰다. 함자(Functor) :값(Value)을 담은 Context로 되어있고, map function 을 지원하는 것 map은 내용만 변경할 수 있었다.flatMap 은 컨테이너도 변경할 수 있다. 모나드값(Value)을 담은 Context로 되어있고, flatMap function 을 지원하는 것 로빈 포플스톤의 일급 객체에 대한 정의 워크샵 두번째 시간코드스쿼드에 JK 께서 발표해주셨습니다. 아래는 말씀해주신 내용을 메모한 것입니다. 의도를 명확하게 하라같은 메소드 내에 추상화 수준을 맞춰라 SOLIDSRP - Actor 들이 사용하는 것을 기준으로 책임을 나눠라OCP - 확장에는 열려있고 변경에는 닫혀있는..LSP - 상속 관계를 만든다 확장을 해야할 것 같을 때는 프로토콜을 만들고 그 프로토콜을 채택한 여러 것들을 추가한다.ISP - 인터페이스 분리 원칙DIP - 의존성 역전의 원칙, 의존성을 setter 로 넣어주는 방법도 있다. GRASP 패턴 코드 리뷰Private 을 먼저 구성(get, set 만드는 것은 지양) - 그래야 연관된 작업은 이 객체 안에서 처리하게 됨 (안그러면 어디서 데이터를 바꾸는지 다 찾아야함) 하드 코딩 제거(“|”, 0, 1 등)프로토콜의 이름은 형용사(able 등)출력할 때 제일 정확한 데이터 포멧을 넘겨주는게 좋음(사다리는 Bool) 다형성이 분기처리를 하도록 짜라If ~ RetuneReturn 이런 방식이 아니라 두개의 객체를 만들어서 다형성으로 짜라 구조적 프로그래밍Goto 구문 없이 반복문으로 제어 흐름에 대한 직접적인 전환 발표 피피티 참고 Creator 패턴 발표자료 참고 메소드를 호출한다고 하지 않고 operation 을 통해 메소드 호출그 객체가 가지고 있는 메소드를 호출한다고 하지 않고 메시지를 보낸다고 한다. 점으로 두번 이상 눌러서 들어가지마라 정리렛츠스위프트에 처음으로 참여해봤습니다. 1년에 한 번 열리는 큰 행사라서 그런지 스케일이 꽤나 컸습니다. 자극도 받고 좋은 시간 보냈습니다. 이런 큰 컨퍼런스를 열어주신 JK 와 스텝 분들께 감사드립니다. 읽어주셔서 감사합니다.","categories":[{"name":"Seminar","slug":"Seminar","permalink":"https://appleceo.github.io/categories/Seminar/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/tags/Swift/"},{"name":"iOS","slug":"iOS","permalink":"https://appleceo.github.io/tags/iOS/"},{"name":"Seminar","slug":"Seminar","permalink":"https://appleceo.github.io/tags/Seminar/"}]},{"title":"MVVM","slug":"MVVM","date":"2019-11-09T12:48:31.000Z","updated":"2021-07-13T05:30:19.383Z","comments":true,"path":"2019/11/09/MVVM/","link":"","permalink":"https://appleceo.github.io/2019/11/09/MVVM/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 MVVM 에 대해서 알아보겠습니다. 아키텍처iOS 에서 많이 사용되는 아키텍처에는 MVC, MVP, MVVM 이 있습니다. 아키텍처를 생각하지 않고 프로그램을 작성한다고 프로그램이 돌아가지 않는 것은 아닙니다. 하지만 이런 프로그램은 가독성은 떨어지며 유지 보수에 굉장히 많은 비용이 듭니다. 또한 테스팅 단계에서는 테스팅 자체가 거의 불가능하거나 효과를 볼 수 없는 난관에 봉착할 수 있습니다. 저는 개발을 할 때 MVC 를 주로 사용해 왔는데요. MVC 를 사용하다보면 View 와 ViewController, Model 이 뒤죽박죽 되는 경우가 많습니다. ViewController 가 너무 많은 소스를 가져가는 경우가 많아서 iOS 에서는 MVC 의 별명이 Massive ViewController 입니다. 이러한 배경으로 MVVM 에 관심을 가지게 되었고 어느 정도 이해한 내용을 정리하고 공유하고자 합니다. MVVMMVVM 은 Model 과 View 사이에 ViewModel 이 위치하는 아키텍처입니다. ViewModel 은 한마디로 View 를 위한 Model 이라고 할 수 있습니다. 저희는 보통 모델을 있는 그대로 사용하지 않습니다. 어떤 로직에 따라 가공을 하기도 하고 뷰에 보여지기 위한 처리가 필요합니다. 이러한 부분을 ViewModel 이 갖고 있어서 View 와 ViewController (이하 View 에 포함)에는 로직과 데이터가 없고 뷰에 대한 처리에만 집중합니다. MVVM 는 아래와 같은 특징을 가지고 있습니다. View 는 최대한 멍청한(dumb) 상태를 유지해야한다. View 는 View Model 과 바인딩 되어있다. ViewModel 은 뷰가 어떻게 보여지든지 상관하지 않는다. ViewModel 은 모델과 통신하여 값을 갖고 있고 로직만을 실행 한다. Binding위에서 바인딩이라는 이야기가 나왔는데요. 그렇다면 바인딩은 무엇일까요? View의 UI 요소들과 ViewModel의 인터페이스를 연결시키는 작업을 “바인딩(Binding)” 이라고 합니다. 뷰 모델의 프로퍼티를 변경하면 이것이 바인딩된 뷰에 반영되는 형태입니다. iOS 에서 바인딩 방법은 아래 4가지가 대표적입니다. KVO (Key-Value Observing) 패턴 RxSwift나 ReactiveCocoa같은 FRP(Functional Reactive Programming) 라이브러를 활용 Combine Property Observer 저는 RxSwift 를 공부하고 있기 때문에 2번째 방법은 RxSwift 를 활용해서 바인딩을 하고자 합니다. RxSwift 를 이용해 바인딩하여 MVVM 아키텍처를 구성하는 것을 RxMVVM 이라고도 합니다. 정리이론적으로는 위와 같이 정리가 되었으나 저 또한 예제를 작성해보고 여러번 활용해서 익숙해져야 하겠습니다. 같이 예제를 공유하고 함께 성장했으면 좋겠습니다. 글 읽어주셔서 감사합니다.","categories":[{"name":"Architecture","slug":"Architecture","permalink":"https://appleceo.github.io/categories/Architecture/"}],"tags":[{"name":"Architecture","slug":"Architecture","permalink":"https://appleceo.github.io/tags/Architecture/"},{"name":"MVVM","slug":"MVVM","permalink":"https://appleceo.github.io/tags/MVVM/"}]},{"title":"2019년 11월 첫번째 주 회고","slug":"201911-FirstWeek","date":"2019-11-08T11:58:20.000Z","updated":"2021-07-13T05:30:19.376Z","comments":true,"path":"2019/11/08/201911-FirstWeek/","link":"","permalink":"https://appleceo.github.io/2019/11/08/201911-FirstWeek/","excerpt":"","text":"안녕하세요. 도미닉입니다. 이번주의 회고와 이주의 읽은 책 독후감을 작성해보았습니다. 회고DDD 세션 모임 발표 준비정기욱님이 카카오 프렌즈 캐릭터를 모델로 만들어주셨다. 그 모델로 캐릭터를 판명하는 아이폰 카메라로 찍는 예제와 ImagePicker 로 사진을 등록하는 예제를 작성했다. 아이폰 카메라 예제 : https://www.youtube.com/watch?v=Eq4z4brcWHQ&amp;t=1s ImagePicker 예제 :https://www.youtube.com/watch?v=-Q5YEr56cKs MVVM 발표수요일 RxSwift 온라인 스터디에서 MVVM 을 발표하게 되었다. https://www.slideshare.net/joonjhokil/rx-mvvmhttps://github.com/AppleCEO/MVVMKyu 위에 자료로 발표를 하였다. 목요일에 오프라인 RxSwift 에서도 발표를 하였다. DDD 직군 세션 발표미리 회고를 작성하고 있어서 내일 토요일에 정기욱님과 만나서 &lt;CoreML-Vision 라이브 코딩&gt; 이라는 주제로 진행할 세션 발표를 할 예정이다. 객체지향 온라인 스터디 참석월요일에 객체지향 온라인 스터디에 참석하였다. 독후감 - 왜 일하는가김봉진 우아한 형제들 대표님의 추천 도서인 &lt;왜 일하는가&gt; 라는 책을 드디어 읽어보았다. 우아한 형제들에 가고 싶고 김봉진 대표님을 존경해서 추천도서들을 구매했었다. 사고 난 뒤에 조금 읽다가 전형적인 꼰대의 책이라는 생각에 책을 접었었다. 대우를 못받아도 무조건 열심히 일하고 애사심으로 일하라는 내용이 주 내용이다. 그런 마음으로 여러 회사들을 다녀봤지만 영세한 기업에 들어가서 이용만 당하고 퇴사한 경험이 많이 있다. 이런 경험으로 다시금 회사를 위해서 열심히 일할 수 있을지 의문이 들 정도로 요즘 의욕이 없었고 회사를 구하기도 주저하였다. 하지만 이 책을 다시 읽어보니 다시금 의욕이 생기는 것 같다. 성급하게 책을 덮었던 그 때와 달리 공부도 많이하고 휴식도 많이한 현재 다시 마음을 잡고 책을 읽어보니 책의 저자가 굉장히 존경스러웠다. 책의 저자는 지방대에 나와서 어찌 중견 기업에 들어갔다. 그 기업은 유명했지만 점점 수익이 줄고 월급도 제대로 못주는 영세 기업이었다. 월급을 못받았지만 저자는 열심히 일하고 연구해서 신기술을 개발해서 회사를 일으켜세운다. 저자는 그 회사에서 나와서 교세라 라는 기업을 만든다. 혼신의 힘을 다해서 세계적인 기업을 만들어낸다. 나의 경우는 전체 직원이 5명~10명 정도인 회사에서 열심히 일 한 경험이 있다. 이번에는 어느 정도 규모가 있는 회사에 가고 싶다. 내가 희생해서 회사를 일으켜 세우면 그거에 대해 고맙다는 말 한마디라도 들을 수 있는 곳에 취업하고 싶다. 슬슬 다시 일을 하고 싶다 다음주 계획월요일 - 객체지향 온라인 스터디 참석(코드스피츠 오브젝트 5강)화요일 - Let’swift 세미나 참석수요일 - RxSwift 온라인 스터디 참석목요일 - RxSwift 오프라인 모임 참석(책 24장)토요일 - Let us go 세미나 참석","categories":[{"name":"Retrospect","slug":"Retrospect","permalink":"https://appleceo.github.io/categories/Retrospect/"}],"tags":[{"name":"회고","slug":"회고","permalink":"https://appleceo.github.io/tags/회고/"},{"name":"독후감","slug":"독후감","permalink":"https://appleceo.github.io/tags/독후감/"}]},{"title":"2019년 10월 마지막 주 회고","slug":"201910-LastWeek","date":"2019-11-08T11:31:20.000Z","updated":"2021-07-13T05:30:19.376Z","comments":true,"path":"2019/11/08/201910-LastWeek/","link":"","permalink":"https://appleceo.github.io/2019/11/08/201910-LastWeek/","excerpt":"","text":"안녕하세요. 도미닉입니다. 이번주의 회고와 이주의 읽은 책 독후감을 작성해보았습니다. 회고오토레이아웃 강의 구매DDD 동아리 활동을 같이하는 정기욱 님께서 추천해주신 오토레이아웃 강의를 구매하였다. https://www.inflearn.com/course/autolayout 위에 강좌이다. 몇 강 안들었지만 기본적인 부분부터 자세히 설명이 되어있다. 꾸준히 듣고 아래 레포지토리에 업데이트 할 것이다. https://github.com/AppleCEO/autolayout 위키피디아 서퍼 앱스토어 신청어플을 앱스토어에 올리도록 처음으로 신청해봤다. 처음하는 절차라 오래 걸렸지만 정상적으로 신청을 마쳤다. 기능이 적다는 피드백을 받았다. DDD 직군 세션 발표 준비금요일에 정기욱님과 만나서 &lt;CoreML-Vision 라이브 코딩&gt; 이라는 주제로 진행할 세션 발표를 준비했다. 아직 coreML 을 사용해보지 않아서 기욱님이 작성하신 예제를 같이 살펴보았다. https://youtu.be/p6GA8ODlnX0 위에 유튜브 영상을 따라서 작성하신 예제였다. 나도 레포지토리를 파서 예제를 따라 작성해보았다. https://github.com/AppleCEO/SmartCameraLTBA 객체지향 온라인 스터디 참석월요일에 처음으로 객체지향 온라인 스터디에 참석하였다. https://www.youtube.com/watch?v=Qa3dRrSbeQI&amp;t=4302s 코드스피츠라는 유튜브 채널에서 올려준 오브젝트 책의 리뷰를 보는 스터이디다. 매주 월요일에 미리 한 강씩 보고와서 스터디에서 같이 보면서 알게 된 내용을 공유하는 스터디이다. https://open.kakao.com/o/gvjVVbDb 위에 오픈 카카오톡 채팅에서 스터디가 진행된다. 오브젝트 책이나 객체 지향에 대해서 혼자 공부하기 힘들고 뜬구름 잡는 느낌이 들었다. 이번에 스터디에서 같이 예제도 서로 공유하고 쉽게 설명 나누면서 너무 좋은 모임이었다. 매주 열심히 참여해야겠다. 독후감 - 읽기 좋은 코드가 좋은 코드다흥푸의 추천 도서 1 인 &lt;읽기 좋은 코드가 좋은 코드다&gt; 책을 드디어 읽어보았다. 이 책은 여러 예제를 가지고 좋은 코드로 개선하는 방법을 알려준다. 생각나는 내용은 아래와 같다. 영어 문장으로 읽히는 코드가 좋은 코드이다. 조건문을 사용할 때 부정을 사용하기 보다 긍정인 상황을 사용하자. 코드로 알 수 있는 내용은 주석에서 지우자 코드를 왜 이렇게 작성했는지 이유를 주석에 작성하자 get 메소드는 간단히 데이터를 리턴하는 메소드에만 사용하자(오래 걸리는 연산을 사용할 때는 사용하지 말자)","categories":[{"name":"Retrospect","slug":"Retrospect","permalink":"https://appleceo.github.io/categories/Retrospect/"}],"tags":[{"name":"회고","slug":"회고","permalink":"https://appleceo.github.io/tags/회고/"},{"name":"독후감","slug":"독후감","permalink":"https://appleceo.github.io/tags/독후감/"}]},{"title":"2019년 10월 4번째 주 회고","slug":"201910-FourthWeek","date":"2019-10-27T16:04:20.000Z","updated":"2021-07-13T05:30:19.375Z","comments":true,"path":"2019/10/28/201910-FourthWeek/","link":"","permalink":"https://appleceo.github.io/2019/10/28/201910-FourthWeek/","excerpt":"","text":"안녕하세요. 도미닉입니다. 이번주의 회고와 이주의 읽은 책 독후감을 작성해보았습니다. 회고DDD 기획 발표 세미나 참석디자이너 분들이 발표 자료를 만들어주셨고 iOS 팀에 정기욱 님이 발표를 해주셨다. 기욱님이 말씀을 너무 잘하시고 발표를 잘 해주셨다. 나이가 20대 초 중반이 대부분 인 것 같은데 여유롭게 발표를 다들 잘하셔서 놀랐다. 좋은 아이디어들이 많이 나온 것 같다. 우리 팀이 회의할 때 나왔던 아이디어가 2개나 다른 팀에서 나왔다. “생각하는 것들은 다 비슷하구나” 라는 생각이 들었다. 우아한 테크 세미나 참석우아한 테크 세미나에 드디어 당첨되어 가게 되었다. 회사 건물이 여러번 와본 듯 익숙한 분위기였고 우아한 형제들에 입사할 수 있도록 더 노력하겠다는 동기부여가 되었다. http://kiljh.me/2019/10/25/WoowahanSeminar201910/ 애플 개발자 계정 결제1년간 앱을 출시할 수 있는 애플 개발자 계정을 결제하였다. 그동안 만들었던 앱들을 마무리해서 출시하고자 한다. “잘만들어야한다.”, “더 준비하고 출시해야한다.” 라는 부담감보다 지금 상황에서 만들 수 있는 만큼 만들고 출시해보고 사용자가 많아지고 문제가 생기면 개선하는 식으로 생각을 바꾸었다. 위키피디아 서퍼 앱 출시 준비다크모드에서 위 아래 배경화면이 하얗게 나오는 문제, 검색 결과에서 셀을 지울 수 있는 버그 등을 해결하고 출시 준비를 하였다. 독후감 - 다시 프로이트, 내 마음의 상처를 읽다여러 현대인들이 겪고 있는 심리적 문제, 그리고 그 해결 방법이 작성되어 있었다. 프로이트에 대해서 요즘 관심을 가지게 되었다. 프로이트는 현대적인 심리학에 대한 시초라고 볼 수 있다. 마음을 알아야지 어떻게 다뤄야할지도 알 수 있을 것이다. 정신외과의사인 유범희 박사님이 자신이 치료한 사람들의 사례를 들면서 프로이트의 이론을 설명해준다. 프로이트에 대해서는 외국 사람이 쓴 책의 번역본을 많이 봤었다. 한국 분이 우리 정서에 맞게 책을 써주셔서 조금 더 친숙하고 쉽게 읽을 수 있었다. 다음주 계획월요일 - 데뷰 1일차 참석월요일 - 객체지향 온라인 스터디 참석목요일 - RxSwift 오프라인 모임 참석금요일 - DDD 발표 준비(CoreML - Vision)","categories":[{"name":"Retrospect","slug":"Retrospect","permalink":"https://appleceo.github.io/categories/Retrospect/"}],"tags":[{"name":"회고","slug":"회고","permalink":"https://appleceo.github.io/tags/회고/"},{"name":"독후감","slug":"독후감","permalink":"https://appleceo.github.io/tags/독후감/"}]},{"title":"xcode11 에서 iOS13 미만의 타겟을 빌드하는 방법","slug":"xcode11BuildLesstheniOS13","date":"2019-10-25T14:09:31.000Z","updated":"2021-07-13T05:30:19.398Z","comments":true,"path":"2019/10/25/xcode11BuildLesstheniOS13/","link":"","permalink":"https://appleceo.github.io/2019/10/25/xcode11BuildLesstheniOS13/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 Xcode 11 에서 iOS 13 미만 버전의 프로젝트를 빌드하는 방법에 대해서 알아보겠습니다. xcode 11 에서 프로젝트를 생성하면 자동으로 target 이 iOS 13 으로 정해집니다. iOS 13 에서 추가된 SceneDelegate.swift 가 자동으로 생성되고 이전 버전과 다른 AppDelegate.swift 가 생성됩니다. 이러한 상황에서 target 을 iOS 13 버전 미만으로 설정하고 빌드했을 때 오류들이 나오는 문제가 발생합니다. 이럴 때 오류를 해결하고 정상적으로 빌드할 수 있는 방법을 공유합니다. 오류 해결 방법 SceneDelegate.swift 수정 11번째 줄 class SceneDelegate: UIResponder, UIWindowSceneDelegate 위에 아래 소스를 추가합니다. 1@available(iOS 13.0, *) 수정한 소스 AppDelegate.swift 수정 func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: … 메소드와 func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: … 메소드 선언 위에 아래 소스를 추가합니다. 1@available(iOS 13.0, *) 수정한 소스 아래 프로퍼티도 추가합니다. 1var window: UIWindow? 정리오류를 해결하고 iOS 13 버전 미만을 xcode 11 에서 빌드하는 방법을 알아봤습니다. 읽어주셔서 감사합니다. 참고 : https://sarunw.com/tips/create-new-ios12-project-in-xcode11/","categories":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/categories/Swift/"}],"tags":[{"name":"iOS13","slug":"iOS13","permalink":"https://appleceo.github.io/tags/iOS13/"},{"name":"미만","slug":"미만","permalink":"https://appleceo.github.io/tags/미만/"},{"name":"xcode11","slug":"xcode11","permalink":"https://appleceo.github.io/tags/xcode11/"},{"name":"iOS12","slug":"iOS12","permalink":"https://appleceo.github.io/tags/iOS12/"},{"name":"SceneDelegate.swift","slug":"SceneDelegate-swift","permalink":"https://appleceo.github.io/tags/SceneDelegate-swift/"}]},{"title":"isEmpty vs count == 0","slug":"isEmptyVSCount-0","date":"2019-10-25T07:45:46.000Z","updated":"2021-07-13T05:30:19.390Z","comments":true,"path":"2019/10/25/isEmptyVSCount-0/","link":"","permalink":"https://appleceo.github.io/2019/10/25/isEmptyVSCount-0/","excerpt":"","text":"안녕하세요 도미닉입니다. 오늘은 isEmpty 와 count == 0 을 어떻게 사용하는지 설명드리고 이 두가지를 비교해보겠습니다. 같이 보시죠. isEmpty 은 무엇인가? 데이터 타입을 문자열로 선언하면 기본적으로 사용할 수 있는 메소드 중에 isEmpty 가 있습니다. 이 메소드는 말 그대로 이 문자열이 비어있는지 확인하여 Bool 값을 리턴합니다. count == 0 은 무엇인가? 데이터 타입을 문자열로 선언하면 기본적으로 사용할 수 있는 메소드 중에 count 가 있습니다. 이 메소드는 말 그대로 문자의 갯수를 확인하여 Int 로 리턴합니다. count == 0 이라는 비교를 통해 문자열의 갯수가 0 인지 확인합니다. isEmpty 와 count == 0 의 공통점isEmpty 와 count == 0 은 둘 다 문자열이 비었는지 확인하는 기능을 수행하는데요. 예제 코드를 보시면 똑같이 Bool 값이 생기는 것을 보실 수 있었습니다. isEmpty 와 count == 0 의 차이점isEmpty 는 문자열이 비었는지 한번에 확인하기 때문에 O(1) 의 시간 복잡도를 가집니다. count == 0 은 문자열 버퍼를 확인하여 몇개 인지 확인하기 때문에 O(N) 의 시간 복잡도를 가집니다. 문자열의 길이가 짧을 때는 두가지 방법의 속도 차이가 별로 나지 않습니다. 문자열의 길이가 길어질 수록 count 메소드의 속도가 느려지는 현상이 있었습니다. text.isEmpty 는 한번에 이 텍스트가 비었는지 확인한다고 읽어집니다. text.count == 0 은 text 라는 문자열이 비었다는 것인지 바로 읽어지지 않는 점도 차이점이라고 할 수 있겠습니다. 정리isEmpty 와 count == 0 이라는 문자열이 비었는지 확인하는 메소드에 대해서 알아봤습니다. 두가지 방법을 비교도 해봤습니다. 차이점을 확인해본 결과 isEmpty 가 조금 더 좋은 방법이라고 생각합니다. 읽어주셔서 감사합니다. 참고 : https://medium.com/better-programming/strings-comparison-isempty-vs-count-0-be80d701901b","categories":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/categories/Swift/"}],"tags":[{"name":"isEmpty","slug":"isEmpty","permalink":"https://appleceo.github.io/tags/isEmpty/"},{"name":"Count","slug":"Count","permalink":"https://appleceo.github.io/tags/Count/"}]},{"title":"우아한 테크 세미나 후기 - 2019년 10월","slug":"WoowahanSeminar201910","date":"2019-10-25T07:17:56.000Z","updated":"2021-07-13T05:30:19.386Z","comments":true,"path":"2019/10/25/WoowahanSeminar201910/","link":"","permalink":"https://appleceo.github.io/2019/10/25/WoowahanSeminar201910/","excerpt":"","text":"안녕하세요. 도미닉입니다. 저번주 목요일에 우아한 형제들에서 개최하는 우아한 테크 세미나에 다녀왔습니다. 매달 이렇게 세미나를 열고 기술적인 공유를 한다는 것에서 우아한 형제들이 정말 좋은 회사라고 느껴졌습니다. 그곳에서 들은 내용들을 공유하고자 합니다. 중국에서 여러 서비스를 오픈하신 김형준님께서 &lt;그럭저럭 돌아가는 서비스 만들기&gt; 라는 주제로 발표해주셨습니다. popit.kr 이라는 커뮤니티에서 활동하신다고 하십니다. 중국의 IT 회사는 좋은 경험을 지속적으로 주면서 자신들의 서비스에 사용자들을 적응시킨다고 합니다. 예를 들어 바코드를 찍어서 결제한 화면을 종업원에게 보여주면서 결제를 확인하던 방법에서 바코드를 찍으면 자동으로 결제가 되는 (종업원이 확인하는) 방법으로 개선되었다고 합니다. WeChat 은 중국인이 가장 많이 사용하는 서비스입니다. html 과 자바 스크립트 정도만 가지고 위쳇과 연동되는 서브 서비스(mini program) 를 만들 수 있다고 합니다. mini program 을 사용할 때 위쳇은 브라우저 역할만 수행한다고 합니다. 처음 mini program 을 실행할 때만 위쳇의 개인 정보를 허용할지 물어보고(우리나라 카카오톡이나 네이버 로그인처럼) 허용한다면 결제 정보부터 모든 정보를 넘겨줘서 사용할 수 있다고 합니다. 이러한 식으로 모바일 기반 서비스들이 많고 적극적으로 사용되는 이유 스마트폰에 접근 가능하다는 것으로 계정이 인증된 것으로 생각함(모바일에 문자를 인증하는 등의 행위) 웹 없이 모바일 환경으로 옴(중국에는 PC 보급이 많이 안된 상태에서 모바일이 보급됨) 조금 뜬금없는 이야기지만 중국에서 게임 성공하면 월급의 50배를 인센티브로 지급한다고 합니다. 퀘스트 모바일이라는 홈페이지에 들어가면 중국의 이러한 기술 동향을 파악할 수 있다고 합니다. 중국에서는 AWS 대신에 알리 클라우드를 많이 사용한다고 합니다. (거의 비슷) 미국에 hadoop 등의 오픈 소스는 56년 지속되는 반면에 한국은 23년 넘어가는 오픈 소스가 없다고 합니다. 그 이유로 한국 사람들은 성격이 급하고 완벽하지 않으면 사용을 안하려고 하는 태도 때문이라고 합니다. 중국은 에자일스럽게 실패하더라도 사용하고 피드백 받아서 개선하는 등의 도전적인 스타일이라고 합니다. 중국은 느린게 아니라 천천히 가는 것이라고도 하셨습니다. 중국은 성 하나에 인구 1억 정도나 되서 이런 성 하나에 사용하는 서비스라도 만들면 성공이라고 할 수 있겠습니다. 유명한 말로 “중국의 현재는 한국의 미래다”라는 이야기도 있다고 합니다. 운영하시는 서비스의 기술 스팩은 아래와 같습니다. 사이트는 서버알리 클라우드 백엔드는 Go 웹/모바일 : React Docker/Kubernetes MySQL, MongoDB Micro Service DB 를 운영하실 때 주문 관리, 제품 관리, 재고 관리 3가지 테이블이 있다면 3가지 테이블의 요소들을 각각 따로 관리하고 데이터 역시 중복으로 저장한다고 합니다.(JOIN 등으로 서로 참고하지 않음) 지불 API 자체가 비동기라고 합니다. (동기적으로 요청을 보내면 성공 여부를 바로 응답 받는 것이 아니고 신청만 하고 따로 결과를 정해진 시간마다 확인한 다던지 한다고 합니다.) 이런 식으로 우선 돌아가게 만들고 점점 사용자가 많아지면 더 잘돌아가게 만들고 개선하는 린스타트업 식으로 운영되는 회사가 많다고 합니다. 중국인들은 애자일이 몸에 베어있다고 합니다. 시키는 대로 어떻게든 빠르게 돌아가게 만들어놓고 피드백 받는 성격이라고 합니다. 이것이 장점이라고 생각한다고 하셨습니다. 돌아가는 소스 3줄 정도만 추가하기를 원하셨는데 한국인 개발자는 뭐 공부하는데 3일, 기존 소스 분석하는데 1일 등 10일이 걸려서 답답하셨다고 합니다. 개발 문화에 대해 아래처럼 생각하신다고 합니다. 성장을 기대하지 말자 단순한 코드로 빠르게 피드백 받자(에자일) 상급자가 그냥 물어보면 작은 조직으로 나눠도 된다(팀장을 안두고 5명짜리 4팀, 총 20명을 혼자 관리하신 경험이 있다고 하십니다.)팀장을 두고 각각 보고를 받는 것보다 20명이 뭘하는지 대충 아시니까 궁금한거 있으면 물어보고 하시는 방식을 선호한다고 하십니다. 정리처음으로 우아한 테크 세미나에 다녀왔습니다. 즐거운 시간이었고 매달가서 듣도록 해야겠습니다. 기술적으로 너무 공부하려고 하고 완벽하게 하려기 보다 우선 돌아가는 것을 만들어보고 앱을 출시해보고자 마음을 먹게 되었습니다. 읽어주셔서 감사합니다.","categories":[{"name":"Seminar","slug":"Seminar","permalink":"https://appleceo.github.io/categories/Seminar/"}],"tags":[{"name":"우아한 형제들","slug":"우아한-형제들","permalink":"https://appleceo.github.io/tags/우아한-형제들/"},{"name":"우아한 테크세미나","slug":"우아한-테크세미나","permalink":"https://appleceo.github.io/tags/우아한-테크세미나/"},{"name":"세미나","slug":"세미나","permalink":"https://appleceo.github.io/tags/세미나/"}]},{"title":"Initializer 확장","slug":"InitializerInExtension","date":"2019-10-23T14:33:25.000Z","updated":"2021-07-13T05:30:19.383Z","comments":true,"path":"2019/10/23/InitializerInExtension/","link":"","permalink":"https://appleceo.github.io/2019/10/23/InitializerInExtension/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 Initializer를 확장하는 방법을 알아보겠습니다. 구조체인 경우 선언한 프로퍼티에 따라 자동으로 Initializer 가 생성됩니다. Initializer에 대해서 궁금하시면 아래 링크 참고 부탁드립니다. http://kiljh.me/2019/06/09/Initializer/ 자동으로 생성된 Initializer 는 별도로 init 메소드 선언 시 사용할 수 없게 됩니다. 하지만 extension 에 init 메소드를 선언하면 자동으로 생성된 Initializer 도 사용할 수 있습니다. 그 예를 보여드리겠습니다. struct1 객체를 생성할 때는 extension 으로 직접 만든 init 메소드를 사용하였습니다. struct2 객체를 생성할 때는 기본으로 생성된 memberwise Initializer 를 사용하였습니다. 정리extension 을 활용해 자동 생성된 initializer 와 직접 만든 init 메소드를 함께 활용할 수 있는 방법을 알아봤습니다. 간단하지만 이렇게 동작한다는게 신기했습니다. 도움이 됬으면 좋겠습니다. 읽어주셔서 감사합니다.","categories":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/categories/Swift/"}],"tags":[{"name":"Initializer","slug":"Initializer","permalink":"https://appleceo.github.io/tags/Initializer/"},{"name":"초기화","slug":"초기화","permalink":"https://appleceo.github.io/tags/초기화/"},{"name":"Extension","slug":"Extension","permalink":"https://appleceo.github.io/tags/Extension/"}]},{"title":"RxSwift Playground 만드는 방법","slug":"HowToMakeRxSwiftPlayground","date":"2019-10-22T09:24:11.000Z","updated":"2021-07-13T05:30:19.382Z","comments":true,"path":"2019/10/22/HowToMakeRxSwiftPlayground/","link":"","permalink":"https://appleceo.github.io/2019/10/22/HowToMakeRxSwiftPlayground/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 RxSwift 소스를 마음대로 돌려볼 수 있는 Playground 를 만드는 방법을 알아보겠습니다. RxSwift Playground 만드는 방법 xcode 에서 Single View App을 생성합니다. Playground 를 추가합니다. 아래와 같이 Playground 가 추가되어 정상적으로 동작합니다. xcode 를 닫습니다. 터미널을 이용해 위에서 만든 프로젝트의 경로로 이동합니다. 터미널에서 pod init 을 실행합니다. 터미널에서 vi Podfile 로 Podfile 을 엽니다. 열면 위와 같을 것입니다. 터미널에서 열린 파일 가장 밑에 줄 end 위에 아래 코드를 추가하고 저장합니다. 1pod &apos;RxSwift&apos;, &apos;~&gt; 4.0&apos; 터미널에서 pod install 을 실행합니다. 정상적으로 설치됬다면 RxSwiftPlayground.xcworkspace 파일이 생성되었을 것입니다. 실행합니다. Playground 에 RxSwift 를 import 하고 예제 코드를 돌려보시면 됩니다. 오류가 나올 때 해결 방법 위와 같은 오류가 발생하시는 분들이 많을 것입니다. 저 또한 매번 이런 오류가 발생했는데요. 해결 방법을 알려드리겠습니다. import RxSwift 를 지웁니다. 아래 부분에서 실행버튼을 눌러 오류를 발생시킵니다. 다시 improt RxSwift 를 작성합니다. 메뉴바에서 Product-Build 를 클릭하여 다시 빌드합니다. 아래 부분에서 실행버튼을 클릭해보면 정상적으로 옵저버블이 생성되는 것을 볼 수 있습니다. 정리RxSwift Playground 를 만드는 방법에 대해서 알아봤습니다. RxSwift 를 공부하고 실습할 때 이용하면 좋습니다. 따라해보고 안되는 부분 있으면 피드백 주세요. 읽어주셔서 감사합니다.","categories":[{"name":"RxSwift","slug":"RxSwift","permalink":"https://appleceo.github.io/categories/RxSwift/"}],"tags":[{"name":"RxSwift","slug":"RxSwift","permalink":"https://appleceo.github.io/tags/RxSwift/"},{"name":"Playground","slug":"Playground","permalink":"https://appleceo.github.io/tags/Playground/"},{"name":"플레이그라운드","slug":"플레이그라운드","permalink":"https://appleceo.github.io/tags/플레이그라운드/"},{"name":"만드는 방법","slug":"만드는-방법","permalink":"https://appleceo.github.io/tags/만드는-방법/"}]},{"title":"2019년 10월 3번째 주 회고","slug":"201910-ThirdWeek","date":"2019-10-21T07:37:20.000Z","updated":"2021-07-13T05:30:19.376Z","comments":true,"path":"2019/10/21/201910-ThirdWeek/","link":"","permalink":"https://appleceo.github.io/2019/10/21/201910-ThirdWeek/","excerpt":"","text":"안녕하세요. 도미닉입니다. 이번주의 회고와 이주의 읽은 책 독후감을 작성해보았습니다. 회고RxSwift 책 13장 ~ 14장 공부이번 오프라인 스터디에서 공부할 13장과 14장을 공부하였다. 그 중 13장 에러 헨들링은 내가 발표하는 자료라서 발표 준비도 하였다. RxSwift 에러 핸들링 발표 자료 작성에러 핸들링에 대해서 발표자료를 작성하였다. 실습 소스도 각 단계에 따라 예제 소스도 준비하고 주석으로 하나씩 풀고 발표하도록 준비하였다. 발표 자료 : https://www.slideshare.net/joonjhokil/error-handling-183424180 RxSwift 에러 헨들링 온라인 스터디와 오프라인 스터디에서 발표위에서 작성한 발표 자료를 온라인 스터디와 오프라인 스터디에서 발표하였다. 현지화에 대해 예제 실습아래 참고 자료를 보고 현지화에 대해서 따라 실습해보았다. 야곰의 강의로 비슷하게 실습을 해봤지만 조금 더 다양한 시도를 해볼 수 있었다. 이 부분 정리해서 다시 공유해보고 싶다. 이미지를 현지화하는 실습은 못해본 것 같다. 참고 : https://devmjun.github.io/archive/Localization DDD 기획 회의저번주에 짜여진 DDD 팀의 기획 모임을 토요일에 했다. 분위기도 좋았고 모든 구성원이 나서서 일을 맡으려고 하는 모습이 인상적이었다. 열심히 참여하고 준비해서 좋은 어플을 출시하도록 해야겠다. 독후감 - 당신은 이미 읽혔다요즘에 다니는 강남도서관에서 책을 빌렸다. 좋아하는 포스팅에서 추천하는 책이었는데 이번에 읽게 되었다. 영어 책만 있는 줄 알았는데 한글로 번역한 책이 있는 것을 알게 되어서 바로 빌려보았다. 제스처의 중요성과 그것이 뜻하는 의미에 대해서 책은 설명한다. 사소한 것 하나하나 몸동작은 의미하는 바가 있고 그것을 이해한다면 사람과 의사소통하는데 큰 도움이 될 것이다. 예를 들어 조그마한 엘리베이터에 많은 사람이 타면 각자는 서로 친한 사이라도 말을 하지 않고 서로 다른 방향으로 서서 다른 곳을 바라본다. 흔히 겪는 일이 었는데 이러한 것도 이론으로 정리되어 있었다. 요즘 느끼는게 이론이나 학문이 다른게 있는게 아니고 그냥 사람들이 하는 방식이나 행동 방식을 정리해 놓은 것이구나 라는 것이다. 재미있게 읽었고 몇번 더 읽으며 책의 내용을 구체화하고 체득하는 것이 좋겠다. 다음주 계획자료구조 공부(배열, 구조체, 포인터, 리스트)리스트 발표 준비화요일 : 밀쿄님과 자료구조 온라인 스터디(리스트, 스택)목요일 : 우아한테크세미나 참여목요일 이후 RxSwift 15,16,17,18장 공부","categories":[{"name":"Retrospect","slug":"Retrospect","permalink":"https://appleceo.github.io/categories/Retrospect/"}],"tags":[{"name":"회고","slug":"회고","permalink":"https://appleceo.github.io/tags/회고/"},{"name":"독후감","slug":"독후감","permalink":"https://appleceo.github.io/tags/독후감/"}]},{"title":"국제화와 현지화","slug":"Localization","date":"2019-10-17T16:13:54.000Z","updated":"2021-07-13T05:30:19.383Z","comments":true,"path":"2019/10/18/Localization/","link":"","permalink":"https://appleceo.github.io/2019/10/18/Localization/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 국제화와 현지화에 대해서 알아보겠습니다. 앱이 다른 언어를 지원하게 만들려면 국제화와 현지화 두가지가 필요합니다. 국제화(Internationalization) 국제적인 호환성을 위해 앱을 디자인하고 제작하는 과정입니다. 즉, 예를들어 앱을 제작할때 다음의 것들을 의미합니다. 유저의 언어(user’s native language)에서 텍스트 입/출력 처리 다루기 다른 날짜, 시간, 숫자 형식 다루기 날짜를 처리하기 위한 적절한 달력, 표준 시간대(time zone) 활용 줄여서 I18N 이라고 하기도 합니다. I와 N 사이의 글자가 18 글자라서 이와 같이 줄일 수 있습니다. 현지화(Localization)현지화(Localization)는 앱의 유저 인터페이스와 리소스를 다른언어로 번역하는 과정 입니다. 현지에서 사용하는 유저가 익숙한 자국어로 앱을 편하게 사용하기 위해서 현지화가 필요합니다. 줄여서 L10N 이라고 하기도 합니다. L과 N 사이의 글자가 10 글자라서 이와 같이 줄일 수 있습니다. 현지화 실습 결과아래 참고 링크를 보고 실습을 진행했습니다. 결과물을 보여드리겠습니다. 폴란드어먼저 폴란드어에 대해서 현지화를 진행했습니다. 아래처럼 앱의 이름이 설정한 폴란드어로 바뀝니다. 앱의 실행화면도 폴란드어로 나타납니다. 위에 과정을 영어, 스페인어에도 적용을 하였습니다. 영어 스페인어 정리간단하게 국제화와 현지화가 무엇인지 알아보았습니다. 아래 포스팅을 따라서 실습을 진행해보면서 익숙해질 수 있었습니다. 시간 되시는 분들은 한번 해보시기를 추천 드리겠습니다. 참고 : https://devmjun.github.io/archive/Localization","categories":[{"name":"iOS","slug":"iOS","permalink":"https://appleceo.github.io/categories/iOS/"}],"tags":[{"name":"Internationalization","slug":"Internationalization","permalink":"https://appleceo.github.io/tags/Internationalization/"},{"name":"Localization","slug":"Localization","permalink":"https://appleceo.github.io/tags/Localization/"},{"name":"국제화","slug":"국제화","permalink":"https://appleceo.github.io/tags/국제화/"},{"name":"현지화","slug":"현지화","permalink":"https://appleceo.github.io/tags/현지화/"}]},{"title":"2019년 10월 2번째 주 회고","slug":"201910-SecondWeek","date":"2019-10-17T05:41:20.000Z","updated":"2021-07-13T06:12:47.931Z","comments":true,"path":"2019/10/17/201910-SecondWeek/","link":"","permalink":"https://appleceo.github.io/2019/10/17/201910-SecondWeek/","excerpt":"","text":"안녕하세요. 도미닉입니다. 이번주에는 DDD 첫 모임에 참가했습니다. 회고RxSwift 를 활용해서 위키피디아 검색 앱을 완성했다.링크 : https://github.com/kiljh-me/WikipediaSurfer 검색 로그가 남도록 기능을 추가했다. 저번주에 뼈대만 만들어놨다면 살을 붙이고 테스트하는 과정이었다. 목요일 RxSwift 오프라인 모임에서 시연했다. 완성도가 가장 높았던 것 같다고 이야기를 들었다. RxSwift 온라인 스터디 발표수요일에 RxSwift 온라인 모임에서 변환 연산자에 대해 발표하였다. 발표를 좋아하고 공유를 좋아해서 자진해서 발표하였다. 처음에는 만든 변환 연산자 발표 자료에 대해 발표했고 10분 쉬었다가 위키피디아 검색 앱의 코드를 발표했다. 잘못 작성하거나 개선할 점을 라이노님, 밀쿄님이 말씀해주셔서 개선할 수 있었다. 밀쿄님이 말씀하신 내용은 delegate, datasource 를 스토리보드에서 채택할 수 있다는 것이었다. 항상 viewDidLoad 에서 delegate = self 이런 식으로 위임했었는데 스토리보드에서도 된다는 것을 알게 되었다. 발표 자료 : https://www.slideshare.net/joonjhokil/rxswift-transforming-operators 독후감 - 시크릿 두번째 이야기예전에 고등학생 때 쯤 시크릿이라는 책을 감명 깊게 읽고 구매해서 왔던 기억이 있다. 그 책의 두번째 이야기를 얻게 되어서 예전에 읽었는데 다시 한번 읽어보았다. 다큐멘터리도 보았다. https://youtu.be/FWM16CQF_Og 바라고 준비하고 받은 것처럼 행동하면 뭐든지 얻을 수 있다는 어떻게 보면 허황된 이야기이다. 하지만 신빙성 있다고 생각이 든다. 생각을 하지 않고 바라지 않는데 뭔가가 얻어지겠는가 원하는 것에 대해 항상 생각하고 얻기 위해 노력한다면 얻을 수 있을 것이다. 시크릿에 대해 조금 더 알아보고 받아들일 것은 받아들여서 더 좋은 사람이 되고 싶다. 다음주 계획RxSwift 에 Error Handling 발표 자료 작성수요일 RxSwift 온라인 스터디에서 Error Handling 발표목요일 RxSwift 오프라인 스터디에서 Error Handling 발표지역화에 대해서 자료 조사해서 블로그 작성하루 1만보 걷기&lt;당신은 이미 읽혔다&gt; 책 읽기","categories":[{"name":"Retrospect","slug":"Retrospect","permalink":"https://appleceo.github.io/categories/Retrospect/"}],"tags":[{"name":"회고","slug":"회고","permalink":"https://appleceo.github.io/tags/회고/"},{"name":"독후감","slug":"독후감","permalink":"https://appleceo.github.io/tags/독후감/"}]},{"title":"hexo 설치 방법","slug":"hexoInstall","date":"2019-10-16T15:16:43.000Z","updated":"2021-07-13T05:30:19.389Z","comments":true,"path":"2019/10/17/hexoInstall/","link":"","permalink":"https://appleceo.github.io/2019/10/17/hexoInstall/","excerpt":"","text":"안녕하세요. 도미닉입니다. 최근에 mac 을 포맷하고 macOS 카탈리나를 설치했습니다. hexo 를 재설치해야 했는데요. 그 방법을 정리해놓고자 합니다. 설치 순서 homebrew 를 설치합니다. https://brew.sh 링크에 접속하시면 Install Homebrew 라는 큰 글씨 아래에 커맨드 명령어가 적혀있습니다. 버전에 따라 조금씩 달라지는데요. 현재는 아래와 같습니다. /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 이 명령어를 커맨드 창에 실행합니다. node.js 를 설치합니다. 위에 설치한 홈브루를 사용해 node.js 를 설치할 겁니다. brew install wget 이 명령어를 커맨드 창에 실행합니다. hexo 를 설치합니다. npm install -g hexo-cli 이 명령어를 커맨드 창에 실행합니다. 정리이제 평소에 사용하시던 hexo new, hexo clean, hexo deploy -g 를 활용해 글을 포스팅하실 수 있게 설치가 완료되었습니다. 백업해놓은 블로그 폴더를 가져온 뒤 위에 방법으로 hexo 를 설치하여 맥북이 바뀌어도 블로그를 계속 관리할 수 있습니다. 감사합니다. 참고 : https://hexo.io/docs/","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://appleceo.github.io/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://appleceo.github.io/tags/hexo/"},{"name":"install","slug":"install","permalink":"https://appleceo.github.io/tags/install/"},{"name":"blog","slug":"blog","permalink":"https://appleceo.github.io/tags/blog/"},{"name":"헥소","slug":"헥소","permalink":"https://appleceo.github.io/tags/헥소/"},{"name":"핵소","slug":"핵소","permalink":"https://appleceo.github.io/tags/핵소/"},{"name":"설치","slug":"설치","permalink":"https://appleceo.github.io/tags/설치/"}]},{"title":"슬라이드쉐어에서 한국어가 깨질 때 해결 방법","slug":"slideshareUsingKorean","date":"2019-10-16T15:03:25.000Z","updated":"2021-07-13T05:30:19.395Z","comments":true,"path":"2019/10/17/slideshareUsingKorean/","link":"","permalink":"https://appleceo.github.io/2019/10/17/slideshareUsingKorean/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 슬라이드쉐어에 슬라이드를 공유했을 때 한글이 깨지는 문제에 대해 해결 방법을 작성해보겠습니다. 발표한 자료를 공유하고자 슬라이드쉐어에 업로드했었습니다. 올린 발표 자료를 보니 한글이 깨지는 문제가 발생했습니다. 구글링하여 해결 방법을 찾아서 공유합니다. 해결 방법 터미널로 슬라이드를 저장한 경로로 이동합니다. 아래 명령어에서 가장 뒤에 이름.pdf 를 발표자료 명으로 바꾼 뒤에 실행합니다. 1LANG=C LC_ALL=C sed -i &apos;&apos; s&apos;|/Registry (Adobe) /Ordering (Korea1) /Supplement [0-9]|/Registry(Adobe) /Ordering(Identity) /Supplement 0|g&apos; 이름.pdf 슬라이드쉐어에 발표 자료를 업로드합니다. 정리이렇게 터미널 명령어 하나로 간단하게 문제를 해결하였습니다. 해결이 되는 원리는 아래 참고 링크를 확인해주시기 바랍니다. 읽어주셔서 감사합니다. 참고 : https://item4.github.io/2016-10-31/Way-to-Use-Homeland-Fonts-on-SlideShare/","categories":[{"name":"Solve","slug":"Solve","permalink":"https://appleceo.github.io/categories/Solve/"}],"tags":[{"name":"slideshare","slug":"slideshare","permalink":"https://appleceo.github.io/tags/slideshare/"},{"name":"슬라이드쉐어","slug":"슬라이드쉐어","permalink":"https://appleceo.github.io/tags/슬라이드쉐어/"},{"name":"한국어","slug":"한국어","permalink":"https://appleceo.github.io/tags/한국어/"},{"name":"한글","slug":"한글","permalink":"https://appleceo.github.io/tags/한글/"},{"name":"깨짐","slug":"깨짐","permalink":"https://appleceo.github.io/tags/깨짐/"},{"name":"korean","slug":"korean","permalink":"https://appleceo.github.io/tags/korean/"},{"name":"break","slug":"break","permalink":"https://appleceo.github.io/tags/break/"}]},{"title":"2019년 10월 1번째 주 회고","slug":"201910-FirstWeek","date":"2019-10-06T14:41:20.000Z","updated":"2021-07-13T05:30:19.375Z","comments":true,"path":"2019/10/06/201910-FirstWeek/","link":"","permalink":"https://appleceo.github.io/2019/10/06/201910-FirstWeek/","excerpt":"","text":"안녕하세요. 도미닉입니다. 이번주는 코드스쿼드를 나오고 처음 맞는 주였습니다. 불안하기도 했고 어떤 공부를 해야할지 헤이해지기도 했던 한주였습니다. 다음주에는 간단하게 여행 다녀오고 마음을 다시 잡아야겠습니다. 회고RxSwift 를 활용해서 위키피디아 검색 어플을 만들었다.링크 : https://github.com/kiljh-me/WikipediaSurfer 검색 로그가 남도록 기능 추가가 필요하다. 처음으로 RxSwift 로 개발을 시작해봤다. (기존에 개발된 소스를 RxSwift 로 변환한 경험은 있었다) RxSwift 를 배우고 개발하면서 느끼는 점은 “개발을 처음부터 다시 배우는 것 같다” 는 것이다. 이런 이야기를 라이노한테 했더니 “개발을 처음부터 배우는 것 맞죠” 라고 하더라.. 화요일에 라이노와 카페에서 근황을 나누고 같이 공부하였다.네이버 지도 컨퍼런스와 메쉬업 동아리 면접에서 만나서 친해진 라이노와 근황을 나누고 같이 공부했다. RxSwift 에 대해 정리하고 파고 있는 멋진 친구다. 저번 달에 이어서 한달에 한번 정도 정보를 공유하고 같이 공부하고자 만나고 있다. RxSwift 책 1장 ~ 11장 복습박보영님 께서 한글로 번역해서 정리해주신 자료(https://github.com/fimuxd/RxSwift) 를 잘 보고 있다. RxSwift 스터디가 이번주는 쉬기 때문에 일주일 간 복습하고 익숙해질 수 있는 시간을 가질 수 있었다. 부스트코스 커리어데이 참여부스트코스 에이스에 참여를 하지 않았지만 신청을 통해 커리어데이에 참여할 수 있었다. 열정있는 여러 스타트업의 발표를 듣고 예전에 꿈이었던 창업이 다시 하고 싶기도 하였다. 지원을 하지는 않았지만 이 회사들을 눈여겨 보고 차후 지원할 기회가 있다면 도움이 될 것 같다. 후기 : http://kiljh.me/2019/10/01/boostCourseCareerDayReview/ RxSwift 온라인 스터디 발표 자료 작성변환 연산자에 대해 ppt 자료를 작성하였다. 다음주에 발표하기로 미뤄졌다. 발표 자료 : https://www.slideshare.net/joonjhokil/rxswift-transforming-operators 독후감 - 프로이트 심리학집에 있었던 책이라 이번주에 읽을 책으로 골라봤다. 심리학과 정신학에 대해 관심이 생길만한 책이었다. 프로이트는 의사이자 철학가이자 심리학자이자 과학자였다. 그의 이론을 간략하게 요점만 짚어주는 방식으로 책은 작성되어 있었다. 모든 내용을 이해할 수는 없었지만 “아 이렇게 생각할 수도 있겠구나” 라는 구절들이 종종 있었다. 앞으로 조금 더 관심을 가지고 심리학에 대해서 알아보고 싶다. 이드와 자아와 초자아 3가지로 인간의 심리는 구성되어 있다고 한다. 이드는 본능이다. 자아는 이드를 통제할 수 있는 심리이다. 초자아는 자아를 통제할 수 있는 심리이다. 초아자가 강하다면 내가 원하는 것을 못하도록 통제하기 때문에 이 사람은 본인 스스로 감옥에 갖혀있는 것과 같다고도 한다. 또한 이드가 강하다면 본능에만 충실한 짐승과도 같은 사람일 것이다. 사람은 식사를 함으로써 공격 본능을 충족한다고도 한다. 식물 혹은 동물을 죽임으로써 자신 또한 언젠가 죽어 자연으로 돌아갈 준비를 한다고나 할까.. 조금은 어렵고 생뚱맞은 내용들이었지만 이렇게도 생각 할 수 있구나 하고 깨닫는 부분들도 많았던 책이었다. 다음주 계획목요일 : RxSwift 오프라인 스터디 참여RxSwift 으로 위키피디아 검색 앱 완성(검색 기록 기능 추가)지역화에 대해서 자료 조사해서 블로그 작성1박2일 여행하루 2만보 걷기","categories":[{"name":"Retrospect","slug":"Retrospect","permalink":"https://appleceo.github.io/categories/Retrospect/"}],"tags":[{"name":"회고","slug":"회고","permalink":"https://appleceo.github.io/tags/회고/"},{"name":"독후감","slug":"독후감","permalink":"https://appleceo.github.io/tags/독후감/"}]},{"title":".sh Permission denied 오류 뜰 때 해결방법","slug":"shPermissionDenied","date":"2019-10-02T08:39:56.000Z","updated":"2021-07-13T05:30:19.395Z","comments":true,"path":"2019/10/02/shPermissionDenied/","link":"","permalink":"https://appleceo.github.io/2019/10/02/shPermissionDenied/","excerpt":"","text":"안녕하세요. 도미닉입니다. 외부에서 받아온 프로젝트를 활용하다보면 아래 사진처럼 파일명.sh: Permission denied 에러가 뜨며 Xcode 에서 빌드가 안되는 경우가 있습니다. 그런 경우 해결할 수 있는 방법을 알려드리겠습니다. 해결 방법은 굉장히 간단한데 처음 접할 경우 당황할 수 있기 때문에 정리해놓고자 합니다. 에러/Users/joon-hokil/Library/Developer/Xcode/DerivedData/RxSwiftPlayground-duhjhqzthkgymmbkmbeotibnggoq/Build/Intermediates.noindex/RxSwiftPlayground.build/Debug-iphonesimulator/RxSwiftPlayground.build/Script-B7A6E9439ADEA36D41DF5382.sh: line 2: /Users/joon-hokil/Documents/도서/Reactive/05-filtering-operators/starter/RxSwiftPlayground/Pods/Target Support Files/Pods-RxSwiftPlayground/Pods-RxSwiftPlayground-frameworks.sh: Permission denied 위와 같이 오류가 발생했는데요. 이 경우 퍼미션 오류가 발생한 경로인 /Users/joon-hokil/Documents/도서/Reactive/05-filtering-operators/starter/RxSwiftPlayground/Pods/Target Support Files/Pods-RxSwiftPlayground/Pods-RxSwiftPlayground-frameworks.sh 파일의 권한을 변경하면 됩니다. 해결 방법 터미널을 엽니다. 파일이 있는 경로로 이동합니다.위 경우에는cd /Users/joon-hokil/Documents/도서/Reactive/05-filtering-operators/starter/RxSwiftPlayground/Pods/Target Support Files/Pods-RxSwiftPlayground/명령어로 이동합니다. 이 때 폴더 경로에 공백이 있는 경우 공백이 있는 폴더명의 상위 경로에 가서 tab 을 사용하던지 해서 이동해야합니다.(여기서는 Target Support Files) 파일에 권한을 변경합니다.chmod +x Pods-RxSwiftPlayground-frameworks.sh 정리간단하게 퍼미션 문제 해결 방법을 알아봤습니다. 글 읽어주셔서 감사합니다. 참고 : https://uiandwe.tistory.com/1010","categories":[{"name":"Solve","slug":"Solve","permalink":"https://appleceo.github.io/categories/Solve/"}],"tags":[{"name":"Xcode","slug":"Xcode","permalink":"https://appleceo.github.io/tags/Xcode/"},{"name":"sh","slug":"sh","permalink":"https://appleceo.github.io/tags/sh/"},{"name":"Permission denied","slug":"Permission-denied","permalink":"https://appleceo.github.io/tags/Permission-denied/"},{"name":"Error","slug":"Error","permalink":"https://appleceo.github.io/tags/Error/"}]},{"title":"부스트코스 커리어데이 후기","slug":"boostCourseCareerDayReview","date":"2019-09-30T15:26:19.000Z","updated":"2021-07-13T05:30:19.387Z","comments":true,"path":"2019/10/01/boostCourseCareerDayReview/","link":"","permalink":"https://appleceo.github.io/2019/10/01/boostCourseCareerDayReview/","excerpt":"","text":"안녕하세요. 도미닉입니다. 9월 30일 열린 부스트코스 커리어데이에 참여하였습니다. 스타트업 회사들의 발표 내용 정리한 것을 공유하고자 합니다. 굿럭 GoodLugg첫번째로 발표한 회사는 굿럭이었습니다. 굿럭은 여행 짐을 옮겨주는 서비스를 작년 8월 1일에 출시한 회사입니다. 마케팅 관련 일을 하던 분 대표로 창업하신 회사이며 대표님이 오셔서 발표를 진행하셨습니다. 말씀하신 내용 중에 인상적이었던 것은 아래와 같습니다. 기술적으로 잘만드는 것보다 적당한 기술에 사용자가 편하게 사용할 수 있는 것이 좋다고 하셨습니다. 기술적으로 뛰어나게 개발을 한다면 시간도 오래 걸릴 것입니다. 적재적소에 사용자가 편하게 사용할 수 있을 정도의 기술력만으로 운영을 하는 것이 좋다고 하셨습니다. 전 직군에 개발자 채용 계획이 있다고 하셨습니다. 사운드짐두번째 회사는 사운드짐이었습니다. 홈트레이닝을 하는데 사운드로 돕는 서비스입니다. 오디오를 활용해 트레이너가 옆에 있는 느낌을 주어 운동을 극대화할 수 있다고 합니다. 신입 개발자를 뽑을 때 라이브러리를 그냥 가져다가 쓰는 것이 아니라 이 라이브러리가 내부적으로 어떻게 동작하는지 관심을 가지는 사람을 선호한다고 하십니다. 현재 개발자가 혼자인데 Notion 으로 문서화하여 다른 개발자가 들어왔을 때 문서만 보고 개발에 참여 가능하도록 진행하고 계시다고 합니다. 생활연구소청소연구소 서비스를 출시한 생활연구소입니다. CTO 님이 발표해주셨는데 솔직 담백하게 진행하셨습니다. 카카오에서 개발하던 서비스인데 출시 버튼만 누르면 되는 상황에서 부서가 해체되었다고 합니다. 개발을 함께 했던 6명이 같이 나와서 회사를 차렸다고 합니다. 홈클리닝 시장이 2018년 자료로 8조라고 합니다. 청소하시는 분들은 매니저라고 지칭하며 교육을 진행하고 직접 채용한다고 합니다. 공급보다 수요가 훨씬 큰 성장하고 있는 시장이라고 합니다. 생활연구소는 서로에게 필요한 도움을 공유하는 서비스들을 만드는 것이 모토라고 합니다. rails, react, aws, docker, mysql 을 활용하고 있다고 합니다. 원하는 개발자 우리 분위기에 녹아들 수 있는 사람 개발을 하는 개발자가 아닌 서비스를 만드는 개발자 기술이 아닌 사람을 뽑는다(공부할 의지, 개발을 좋아하는지) SkyLabs백창현 CTO 님이 발표해주셨습니다. 의학 도메인에서 테크 관련 주제에 여러 세미나에서 발표를 한다고 하십니다. 건강 관련 반지를 출시했다고 합니다. 시니어 6, 주니어 4 정도의 비율로 개발팀이 구성되있다고 합니다. 쓸데 없는 회의를 지양하고 위크 미팅을 1주에 한번 진행한다고 합니다. 특이한 점은 테크 미팅을 진행하는데 기한이나 현재 진행하는 내용은 이야기하지 않고 오로지 기술을 공유하는 미팅을 여신다고 합니다. (주기는 모르겠네요.) Adriel.ai전수경 이사님이 발표해주셨습니다. 핀테크 솔리트웨어 회사를 Exit 하고 현재 회사를 만들었다고 합니다. 이미지나 문구만으로 페이스북, 구글 등의 플랫폼에 양식에 맞게 광고를 만들어주는 서비스를 만든다고 합니다. 광고를 한번 만들어주는 것에서 끝나는게 아니라 현재 트랜드나 용어에 따라 조금씩 AI 로 최적화를 하여 변경해서 반영해준다고 합니다. CTO 가 프랑스 분이고 외국인들이 많다고 합니다. 그래서 영어로 의사소통을 한다고 합니다. RISE 홍콩(스타트업 국제 컨퍼런스) 등 국제 컨퍼런스에 직원들이 돌아가며 참석하며 직원들을 그런데서 뽑아온다고 합니다. 자바스크립트로 백엔드, 프론트엔드 전부 구성되있다고 합니다. 개발자는 3~5년차가 대부분이라고 합니다. 프론트앤드는 5년차, 3년차, 2년차 개발자 3명으로 구성되있으며 백앤드는 7년차, 5년차, 2년차 개발자 3명으로 구성되있다고 합니다. 주 1회 회고 한다고 합니다. 에너자이 (ENERZAi)왕신조 이사님이 발표해주셨습니다. 자원 탐사 솔루션을 만든다고 합니다. 백앤드는 장고, AWS 로 구성되있으며 프론트앤드는 JS, jQuery 로 구성되있다고 합니다. AI 는 파이썬으로 주로 개발하므로 파이썬을 잘아는 분을 선호한다고 합니다. 허니비즈정경환 실장님이 발표해주셨습니다. 띵동을 출시한 회사입니다. KT Cloud, AWS 를 사용하며 REST API 로 구성되있다고 합니다. React, 안드로이드 네이티브를 사용한다고 합니다. 시니어4, 주니어 6 정도의 비율로 구성되있다고 합니다. CLASS101이병철 리드님이 발표해주셨습니다. 취미에 대한 동영상 강의를 구매하면 필요한 준비물도 배송해주는 서비스입니다. 작년 3월에 출시했고 작년 10월부터 리드해오셨다고 합니다. Node.js, React, Reactive 로 구성되있다고 합니다. 동영상 구매, 준비물 배송 등 여러 분야의 개발이 일어나고 있어서 아마존 + 넷플릭스 + 에어비엔비 같은 회사라고 합니다. 모든 PR 에 코드리뷰를 하고 있다고 합니다. 인재상 착한지 : 법인카드를 주고 자유로운 회사이기 때문에 자기규율이 엄청난 사람을 선호한다고 합니다. 피드백을 직설적으로 한다고 합니다. 똑똑한지 : 기술 성장을 포악하게 할 수 있는 주니어를 원한다고 합니다. 배우기만 하지 않고 가르칠 수 있는 사람을 원한다고 합니다. 야망이 있는지 : 회사를 원피스에 비유하며 회사의 꿈과 상통하는 꿈을 가진 사람을 원한다고 합니다. 웹개발자는 비즈니스에 적절한 시점에 임팩트 있는 코드를 쓸 수 있는 사람이라고 생각한다고 합니다. 속도, 퀄리티, 기능 3박자가 다 갖춰진, 3가지에서 중심을 잘 잡는 사람을 원한다고 합니다. 만나씨이에이우상욱 연구원님이 발표해주셨습니다. 농장을 관리하는 시스템을 구축하는 회사입니다. 농장별 인스턴스를 생성해야 하는 문제가 있었다고 합니다. 이런 것들을 한 곳에 묶어서 최적화를 해서 해결했다고 합니다. 동작하는 코드는 끝이 아니라 시작이며 사용자와 상호작용하며 더 좋은 코드(서비스)를 만들어가는 것이 중요하다고 합니다. 진천에서 근무해야 합니다. 시니어 2 : 주니어 1 비율이라고 합니다. 슬랙과 구글 독스를 이용해 의사소통 한다고 합니다. PUMP박기영 팀장님이 발표해주셨습니다. 씽씽을 서비스하고 있는 회사입니다. 씽씽의 장점 이동 편의성 비용 친환경 차후 대중교통과 환승 서비스, 스마트 시티 내 핵심사업계획을 가지고 있다고 합니다. 인재상은 창의적, 선한의지, 배려, 오픈커뮤니케이션을 중요하게 본다고 합니다. React, ReactNative, Node.js, MongoDB(NoSQL), AWS, Docker 를 사용한다고 합니다. 백엔드은 시니어 1, 주니어 1 두명의 개발자로 이루어져있다고 합니다.프론트엔드도 시니어 1명, 주니어 1명으로 두명의 개발자로 이루어져있다고 합니다.여기에 QA 1명해서 5명이 개발팀이라고 합니다. 협언은 라이크를 사용한다고 합니다.","categories":[{"name":"JobFair","slug":"JobFair","permalink":"https://appleceo.github.io/categories/JobFair/"}],"tags":[{"name":"채용박람회","slug":"채용박람회","permalink":"https://appleceo.github.io/tags/채용박람회/"},{"name":"네이버","slug":"네이버","permalink":"https://appleceo.github.io/tags/네이버/"},{"name":"부스트코스","slug":"부스트코스","permalink":"https://appleceo.github.io/tags/부스트코스/"},{"name":"스타트업","slug":"스타트업","permalink":"https://appleceo.github.io/tags/스타트업/"}]},{"title":"2019년 9월 4번째 주 회고","slug":"201909-FourthWeek","date":"2019-09-29T13:08:32.000Z","updated":"2021-07-13T05:30:19.375Z","comments":true,"path":"2019/09/29/201909-FourthWeek/","link":"","permalink":"https://appleceo.github.io/2019/09/29/201909-FourthWeek/","excerpt":"","text":"안녕하세요. 도미닉입니다. 이번주부터 매주 회고와 읽은 책의 독후감을 작성하고자 합니다. 이번주는 코드스쿼드에서의 마지막 주였습니다. 6개월동안 많이 성장하고 발전하였습니다. 앞으로 혼자 공부하며 구직 활동에 집중하고자 합니다. 회고코드스쿼드에서 쇼핑앱을 일부 구현했다. 쇼핑앱에 Section Header 에 Custom Cell 로 구성 여러 url 에서 json 을 받아와 한 테이블 뷰에 뿌려주도록 구현 DDD 동아리 면접을 보았다. 분위기는 좋았다. 동아리에 들어가 교류하면서 어플을 출시하고 싶다. 곰튀김님의 RxSwift + MVVM 오프라인 강의 들었다. RxSwift 에 많이 익숙해질 수 있었다. 열성적으로 가르쳐주셔서 만족스러웠다. 곰튀김님의 RxSwift 4시간만에 끝내기 온라인 강의를 들었다. 오프라인 강의를 듣기 전에 다시 한번 강의를 보았다. 실습도 수행해봤다. RxSwift 스터디를 참여하였다. 목요일 저녁마다 하는 스터디에 나가고 있다. 9~11장 공부하였다. 다음주는 공휴일이라 한주 쉰다. 쉬는동안 1~11장 하루에 한장씩 복습해야겠다. 서치바 과제도 해야한다. 코드스쿼드 수업 참여 화요일에 지역화와 국제화에 대해 부엉이가 발표해주었다. 블로그에 정리해서 공유해야겠다. 목요일에 파이어베이스에 대해 야곰이 강의해주셨다. 간단한 실습을 해볼 수 있었다. 독후감 - 지금 당장 롤렉스 시계를 사라평소에 롤렉스 시계에 관심이 있었다. 롤렉스를 검색하다가 이 책을 추천하는 블로그 글을 보게 되었다. 필요한 물건을 비싼 돈을 주더라도 사게 되면 그것을 산 돈 만큼 나에게 돌아온다는 내용이 골자이다. 돈을 잘 쓰면 감동을 받는 경우가 있다. “아 이렇게 돈을 쓰면 행복하구나 돈을 더 벌어야겠다” 라는 생각을 갖게 될 수도 있을 것이다. 또는 “아 돈 벌기 정말 힘든데 쓰면 행복하니까 직장을 계속 다녀야겠다” 라고 생각할 수도 있다. 이런 식으로 돈을 통장에만 모아놓는 것이 아니라 내가 감당할 수 있을 정도는 지출하는 것이다. 지출함으로써 만족감을 느끼고 더 의욕이 생겨서 돈을 더 벌 수 있어야겠다고 노력할 수 있다. 주변 사람에게 밥을 사거나 선물을 주는 것도 돈을 잘 쓰는 것이라고 한다. 하지만 내가 이만큼 주니까 상대방이 뭔가를 돌려주겠지라고 생각하는 것이 아니라 주는 것으로 만족하고 행복함을 느껴야 한다고 한다. 상대방에게 뭘 바라면서 주는 것은 돈으로 감동을 주는 것이 아니다. 오히려 “나에게는 왜 뭔가를 안돌려주지” 라고 자신도 상처를 받고 상대방도 부담을 느끼고 관계가 껄끄러워질 수도 있을 것이다. 아끼는 것도 중요하지만 잘 쓸 줄 아는 사람이 또 잘 벌 수 있다고 생각하게 되었다. 다음주 계획월요일에 네이버에서 하는 채용 박람회에 참여화요일에는 라이노와 신설동 스타벅스에서 최근 근황을 나누고 같이 공부.RxSwift 책을 정리한 아래 글을 보면서 8장까지 내용 확인https://github.com/fimuxd/RxSwift수요일에 RxSwift 온라인 스터디에서 공부한 내용 발표지역화에 대해 자료 조사해서 블로그 작성","categories":[{"name":"Retrospect","slug":"Retrospect","permalink":"https://appleceo.github.io/categories/Retrospect/"}],"tags":[{"name":"회고","slug":"회고","permalink":"https://appleceo.github.io/tags/회고/"},{"name":"독후감","slug":"독후감","permalink":"https://appleceo.github.io/tags/독후감/"}]},{"title":"Git 을 이용한 협업","slug":"CollaborateWithGit","date":"2019-09-21T14:32:39.000Z","updated":"2021-07-13T05:30:19.378Z","comments":true,"path":"2019/09/21/CollaborateWithGit/","link":"","permalink":"https://appleceo.github.io/2019/09/21/CollaborateWithGit/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 Git 을 활용해서 협업하는 방법에 대해서 알아보겠습니다. 우선 하나의 레퍼지터리를 크론해옵니다. 여러명이 어떤 식으로 협업할 수 있는지 정리하고자 합니다. 아래의 과정을 진행하면 됩니다. git checkout master git pull git checkout front git merge master 하나하나 설명드리겠습니다. 협업자들 각자 작업을 위한 브런치를 생성하고 그 브런치에서만 수정 작업을 하는 것이 좋습니다. 다른 분이 작업을 하고 마스터에 반영을 했다면 그 소스를 받아오는 작업입니다. 마스터로 체크아웃 합니다. 소스를 받아옵니다. 자신의 작업 브런치로 이동합니다. 마스터의 소스를 반영합니다. 이 과정을 통해 다른 분이 작업한 내용들을 자신의 브런치에 반영할 수 있습니다. 이 상태에서 작업을 진행합니다. 작업한 내용을 push 합니다. 협업 중인 레퍼지토리에 가면 PR 을 보낼 것이냐고 묻습니다. PR 을 하고 코드리뷰나 허가가 필요하다면 진행을 하고 각자 맡은 분야가 달라서 코드리뷰가 필요 없다면 본인이 PR 을 마스터에 바로 반영할 수 있습니다. 이런 식으로 한 레퍼지토리에서 여러명이 작업을 진행하고 코드를 최신화를 할 수 있습니다. 읽어주셔서 감사합니다. 참고 :","categories":[{"name":"Git","slug":"Git","permalink":"https://appleceo.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://appleceo.github.io/tags/Git/"},{"name":"Collaborate","slug":"Collaborate","permalink":"https://appleceo.github.io/tags/Collaborate/"},{"name":"Branch","slug":"Branch","permalink":"https://appleceo.github.io/tags/Branch/"}]},{"title":"CaseIterable 프로토콜의 allCases 와 AllCases","slug":"CaseIterable","date":"2019-09-15T13:02:16.000Z","updated":"2021-07-13T05:30:19.378Z","comments":true,"path":"2019/09/15/CaseIterable/","link":"","permalink":"https://appleceo.github.io/2019/09/15/CaseIterable/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 CaseIterable 프로토콜을 채택했을 때 사용할 수 있는 메소드들인 allCases 와 AllCases 이 무엇인지 그리고 그 차이에 대해서 알아보겠습니다. enum 을 활용하는 분이라면 allCases 메소드는 많이 사용해보셨을 거라고 생각합니다. allcases 란 무엇인가?enum 에 있는 모든 케이스를 선언한 순서대로 배열로 리턴하는 메소드입니다. enum 타입이 CaseIterable 을 채택하게 되면 기본적으로 제공됩니다. allcases 예제는 무엇이 있는가? numberOfChoices 변수는 Beverage 배열타입입니다.이 변수에는 [Beverage.coffee, Beverage.tea, Beverage.juice] 가 들어가게 됩니다. Beverage enum 타입에서 case 를 선언한 순서대로 출력되는 것을 알 수 있습니다. AllCases 란 무엇인가?enum 타입이 CaseIterable 을 채택하게 되면 AllCases 라는 메소드도 사용할 수 있습니다. AllCases 는 원하는 대로 case 를 조합하고 순서를 설정할 수 있습니다. Allcases 예제는 무엇이 있는가? AllCases() 를 호출하면 enum 타입을 요소로 갖는 배열이 초기화됩니다. 배열을 다루듯이 append 로 enum 타입의 case 들을 추가해줄 수 있습니다. 원하는 순서와 case 만 추가해서 활용할 수 있습니다. 정리CaseIterable 에서 allCases 와 AllCases 메소드에 대해서 알아봤습니다. allCases 는 선언한 순서대로 모든 case 를 반환하는 메소드였습니다. AllCases 는 원하는 case 만을 조합하여 배열로 활용하는 메소드였습니다. 메소드 이름 첫글자의 대소문자 차이만 가지고 있기 때문에 혼동하기 쉽습니다. 이 글 보시고 사용하시는데 도움이 됬으면 좋겠습니다. 글 읽어주셔서 감사합니다.","categories":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/tags/Swift/"},{"name":"AllCases","slug":"AllCases","permalink":"https://appleceo.github.io/tags/AllCases/"},{"name":"allCases","slug":"allCases","permalink":"https://appleceo.github.io/tags/allCases/"},{"name":"스위프트","slug":"스위프트","permalink":"https://appleceo.github.io/tags/스위프트/"},{"name":"CaseIterable","slug":"CaseIterable","permalink":"https://appleceo.github.io/tags/CaseIterable/"}]},{"title":"Defer","slug":"Defer","date":"2019-09-14T14:22:22.000Z","updated":"2021-07-13T05:30:19.379Z","comments":true,"path":"2019/09/14/Defer/","link":"","permalink":"https://appleceo.github.io/2019/09/14/Defer/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 Defer 에 대해서 알아보겠습니다. Defer 를 들어본 분도 계실 것 같고 안들어본 분들도 계실 것 같습니다. 한번 알아보죠. Defer 란 무엇인가?defer 를 번역해보면 “지연하다” 라는 동사입니다. defer 구문은 현재 스코프를 벗어날 때 실행하도록 지연합니다. defer 의 예제는 무엇이 있는가? 첫번째 예제입니다. print(“4”) 소스가 defer 안에 없었다면 1,4,2,3,5 순으로 출력이 되었을 겁니다. defer 구문 안에 print(“4”) 가 들어가게 되면서 doit() 메서드가 끝날 때 실행되게 되었습니다. 위에 소스는 1,2,3,4,5 순서로 출력됩니다. 두번째 예제입니다. 파일을 열고 상태메시지가 OK 가 아니면 메소드가 종료됩니다. guard 문 아래에 file.close() 가 있었다면 파일을 닫지 않고 메소드가 종료될 것입니다. defer 문을 활용해 loggin() 메소드가 종료될 때 파일이 닫히는 것을 보장할 수 있습니다. 세번째 예제입니다. defer 구문을 여러번 작성하면 역순으로 실행됩니다. 따라서 아래에 있는 print 2 부터 실행되고 그 다음에 print 1 이 실행됩니다. 정리defer 을 사용하면 어떤 메소드가 종료됬을 때 혹은 어떤 스코프가 종료될 때 원하는 동작을 수행할 수 있었습니다. 파일을 열거나, 데이터베이스 연결이나 네트워크 연결을 만들어 놓고 작업하는 중 예외를 만나는 경우에도 안전하게 리소스를 닫는 처리를 할 수 있습니다. 글 읽어주셔서 감사합니다. 참고 : https://soooprmx.com/archives/6118","categories":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/categories/Swift/"}],"tags":[{"name":"Defer","slug":"Defer","permalink":"https://appleceo.github.io/tags/Defer/"},{"name":"function","slug":"function","permalink":"https://appleceo.github.io/tags/function/"},{"name":"scope","slug":"scope","permalink":"https://appleceo.github.io/tags/scope/"},{"name":"Exit","slug":"Exit","permalink":"https://appleceo.github.io/tags/Exit/"}]},{"title":"Getter 와 Setter","slug":"GetterAndSetter","date":"2019-09-10T15:43:08.000Z","updated":"2021-07-13T05:30:19.381Z","comments":true,"path":"2019/09/11/GetterAndSetter/","link":"","permalink":"https://appleceo.github.io/2019/09/11/GetterAndSetter/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 Getter 와 Setter 에 대해서 알아보고자 합니다. 게터와 세터라는 단어를 프로그래밍 하다보면 들어보셨을 것입니다. 이것들이 무엇이고 왜 사용하는지 알아보도록 하겠습니다. Getter 란 무엇인가?게터는 번역하면 “얻는 사람” 입니다. 얻어오는 역할을 하는 무언가라고 이해할 수 있습니다. Getter 의 구현 방법은 무엇인가? 메소드를 사용해서 아래와 같이 게터를 구현해줄 수 있습니다. 읽기 전용 연산 프로퍼티를 사용해서 아래와 같이 게터를 구현해줄 수 있습니다. Setter 란 무엇인가?세터는 번역하면 “설정하는 사람” 입니다. 설정하는 역할을 하는 무언가라고 이해할 수 있습니다. Setter 의 구현 방법은 무엇인가? 메소드를 사용해서 아래와 같이 세터를 구현해줄 수 있습니다. 연산 프로퍼티를 사용해서 아래와 같이 세터를 구현해줄 수 있습니다.연산 프로퍼티의 특성상 Setter 만 구현할 수는 없고 Getter 와 함께 사용해야 합니다. Getter 와 Setter 를 사용하는 이유는 무엇인가?객체지향이 익숙해지면서 캡슐화라는 개념이 중요해졌습니다. 객체가 내부적으로 어떻게 동작하는지 다른 객체에게 알리지 않는 것이 좋다는 개념입니다. 이에 따라 어떤 프로퍼티가 있는지 숨기는 private 접근연산자를 사용하는 경우가 많아졌습니다. private 접근연산자를 자주 사용함에 따라 불편함이 생겼는데요. 통신을 위하거나 순수하게 데이터만을 가진 객체의 값을 편하게 사용할 수 없게 된 것입니다. 이에 따라 Getter, Setter 가 필요하게 되었습니다. 정리게터와 세터에 대해서 알아봤습니다. 객체지향 관점에서 게터와 세터를 자주 사용하는 것은 좋은 방법은 아닙니다. 프로퍼티에 직접 접근하는 것과 별반 차이가 없기 때문입니다. 하지만 DTO 나 VO 를 구현할 때는 잘 활용할 수 있습니다. DTO 나 VO 에 대해서 궁금하시다면 아래 링크 확인해주세요. http://kiljh.me/2019/09/10/DTOvsVO/ 글 읽어주셔서 감사합니다.","categories":[{"name":"Terminology","slug":"Terminology","permalink":"https://appleceo.github.io/categories/Terminology/"}],"tags":[{"name":"스위프트","slug":"스위프트","permalink":"https://appleceo.github.io/tags/스위프트/"},{"name":"클래스","slug":"클래스","permalink":"https://appleceo.github.io/tags/클래스/"},{"name":"구조체","slug":"구조체","permalink":"https://appleceo.github.io/tags/구조체/"},{"name":"객체","slug":"객체","permalink":"https://appleceo.github.io/tags/객체/"},{"name":"example","slug":"example","permalink":"https://appleceo.github.io/tags/example/"},{"name":"예제","slug":"예제","permalink":"https://appleceo.github.io/tags/예제/"},{"name":"Getter","slug":"Getter","permalink":"https://appleceo.github.io/tags/Getter/"},{"name":"Setter","slug":"Setter","permalink":"https://appleceo.github.io/tags/Setter/"},{"name":"게터","slug":"게터","permalink":"https://appleceo.github.io/tags/게터/"},{"name":"세터","slug":"세터","permalink":"https://appleceo.github.io/tags/세터/"},{"name":"캡슐화","slug":"캡슐화","permalink":"https://appleceo.github.io/tags/캡슐화/"}]},{"title":"DTO 와 VO","slug":"DTOvsVO","date":"2019-09-10T13:44:00.000Z","updated":"2021-07-13T05:30:19.379Z","comments":true,"path":"2019/09/10/DTOvsVO/","link":"","permalink":"https://appleceo.github.io/2019/09/10/DTOvsVO/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 DTO 와 VO 에 대해서 알아보겠습니다. 이 두가지를 헷갈려하는 분들이 많으신데요. DTO 와 VO 가 무엇이고 어떻게 다른지 알아보겠습니다. DTO 란 무엇인가?DTO 는 Data Transfer Object 의 약자입니다. 번역하면 데이터 전송 객체입니다. 데이터를 전송할 때 사용하는 객체라고 이해할 수 있겠습니다. 데이터의 getter 와 setter 만 있는 객체를 DTO 라고 합니다. getter 와 setter 에 대해서 모르신다면 아래 포스팅을 확인해주시기 바랍니다. http://kiljh.me/2019/09/11/GetterAndSetter/ DTO 의 구현 방법은 무엇인가? 위에 소스는 메소드로 구현한 DTO 의 예제입니다. Greeting 객체와 같이 각 프로퍼티에 해당하는 getter, setter 만을 갖고 있는 것이 DTO 입니다. 스위프트에서는 위와 같이 연산 프로퍼티를 활용해서 DTO 를 구현할 수도 있습니다. 연산 프로퍼티에 대해서 궁금하시다면 아래 링크를 확인해주세요. http://kiljh.me/2019/09/09/ComputedProperty/ VO 란 무엇인가?VO 는 Value Obejct 의 약자입니다. 번역하면 값 객체입니다. 값을 저장하는 객체라고 이해할 수 있겠습니다. getter 만 있는 불변 객체를 VO 라고 합니다. VO 의 예제는 무엇인가? UIColor 클래스는 VO 입니다. UIColor 를 사용할 때 각 색의 값을 설정하지 않아도 .blue 와 같이 가져와서 사용할 수 있습니다. 정리DTO 와 VO 는 명확한 차이를 갖고 있었습니다. 혼동해서 사용하지 않도록 조심하시길 바랍니다. 읽어주셔서 감사합니다. 참고 : https://mommoo.tistory.com/61","categories":[{"name":"Terminology","slug":"Terminology","permalink":"https://appleceo.github.io/categories/Terminology/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/tags/Swift/"},{"name":"스위프트","slug":"스위프트","permalink":"https://appleceo.github.io/tags/스위프트/"},{"name":"클래스","slug":"클래스","permalink":"https://appleceo.github.io/tags/클래스/"},{"name":"구조체","slug":"구조체","permalink":"https://appleceo.github.io/tags/구조체/"},{"name":"DTO","slug":"DTO","permalink":"https://appleceo.github.io/tags/DTO/"},{"name":"VO","slug":"VO","permalink":"https://appleceo.github.io/tags/VO/"},{"name":"객체","slug":"객체","permalink":"https://appleceo.github.io/tags/객체/"},{"name":"example","slug":"example","permalink":"https://appleceo.github.io/tags/example/"},{"name":"예제","slug":"예제","permalink":"https://appleceo.github.io/tags/예제/"}]},{"title":"연산 프로퍼티","slug":"ComputedProperty","date":"2019-09-09T14:56:46.000Z","updated":"2021-07-13T05:30:19.379Z","comments":true,"path":"2019/09/09/ComputedProperty/","link":"","permalink":"https://appleceo.github.io/2019/09/09/ComputedProperty/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 연산 프로퍼티에 대해서 알아보겠습니다. 연산 프로퍼티란?연산 프로퍼티하면 어떤 것이 생각나시나요? 보통 프로퍼티는 클래스, 구조체의 특성저장을 하기 위해 사용합니다. 하지만 연산 프로퍼티는 저장을 하지 않습니다. 단지 저장 프로퍼티에 값을 연산할 때 사용합니다 프로퍼티를 읽는 연산을 할 때는 수행하는 것을 getter, 프로퍼티를 바꾸는 연산을 할 때는 setter 라고 합니다. 연산 프로퍼티는 두가지 종류가 있습니다. getter 와 setter 두가지를 다 갖고 있는 Computed Property(연산 프로퍼티)가 있고요.getter 만 갖고 있는 Read-Only Computed Properties(읽기 전용 연산 프로퍼티) 가 있습니다. 연산 프로퍼티의 사용 방법은?우선 연산 프로퍼티를 사용하기 위해서는 대체로 “저장소” 가 필요합니다. 연산 프로퍼티는 값을 연산만 할 뿐 저장을 하지 않기 때문입니다. 그렇기 때문에 이런 연산을 수행할 저장소가 별도로 필요한 것이죠. tempName 라는 저장 프로퍼티가 저장소 역할을 합니다. name 는 연산 프로퍼티이며 get 과 set 이 지정되어 있습니다. name 은 별도의 값을 저장하지는 않습니다. name 의 getter, setter 는 tempName 이라는 저장소를 연산에 활용합니다. 읽기 전용 연산 프로퍼티의 사용 방법은?읽기 전용 연산 프로퍼티는 저장소가 필요하지 않습니다. 만약 어떤 정해진 값만을 리턴해준다면 저장소가 필요하지는 않습니다. name 은 읽을 수만 있으며 다른 값으로 변경하지 못합니다. name 을 읽으면 정해진 문자열만 리턴됩니다. 정리오늘은 연산 프로퍼티에 대해서 알아봤습니다. 궁금하거나 잘못된 점 있으면 댓글 부탁해요. 읽어주셔서 감사합니다~ 참고 : https://zeddios.tistory.com/245","categories":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/categories/Swift/"}],"tags":[{"name":"Computed Property","slug":"Computed-Property","permalink":"https://appleceo.github.io/tags/Computed-Property/"},{"name":"Class","slug":"Class","permalink":"https://appleceo.github.io/tags/Class/"},{"name":"Struct","slug":"Struct","permalink":"https://appleceo.github.io/tags/Struct/"},{"name":"연산 프로퍼티","slug":"연산-프로퍼티","permalink":"https://appleceo.github.io/tags/연산-프로퍼티/"},{"name":"읽기 전용 연산 프로퍼티","slug":"읽기-전용-연산-프로퍼티","permalink":"https://appleceo.github.io/tags/읽기-전용-연산-프로퍼티/"},{"name":"클래스","slug":"클래스","permalink":"https://appleceo.github.io/tags/클래스/"},{"name":"구조체","slug":"구조체","permalink":"https://appleceo.github.io/tags/구조체/"},{"name":"Read-Only Computed Properties","slug":"Read-Only-Computed-Properties","permalink":"https://appleceo.github.io/tags/Read-Only-Computed-Properties/"}]},{"title":"AppDelegate 에 있는 메소스들 정리","slug":"MethodInAppDelegate","date":"2019-09-08T14:27:28.000Z","updated":"2021-07-13T05:30:19.384Z","comments":true,"path":"2019/09/08/MethodInAppDelegate/","link":"","permalink":"https://appleceo.github.io/2019/09/08/MethodInAppDelegate/","excerpt":"","text":"안녕하세요. 도미닉입니다. AppDelegate 가 모두 익숙하실 것이라고 생각합니다. AppDelegate.swift 는 싱글뷰 프로젝트를 생성하면 가장 위에 보이는 파일이죠. 그렇다면 이 AppDelegate 에는 어떤 메소드들이 선언되어 있을까요? application 첫번째로 보이는 메소드는 application 입니다. 그렇다면 application 은 어떤 역할을 하는 메소드일까요? 이름에서도 알 수 있듯이 어플리케이션이 실행될 때 딱 한번 실행되는 메소드입니다. // Override point for customization after application launch. 주석에도 친절하게 어플리케이션이 시작될 때 원하는 작업을 추가할 수 있다고 적혀있네요. applicationWillResignActive 두번째 메소드는 applicationWillResignActive 입니다. 긴 주석이 두개나 적혀있네요. 해석해보고 어떤 역할을 하는 메소드인지 알아보겠습니다. 123응용 프로그램이 활성 상태에서 비활성 상태로 이동하려고 할 때 전송됩니다. 이는 특정 유형의 일시적인 중단 (예 : 전화 또는 SMS 메시지 수신) 또는 사용자가 응용 프로그램을 종료하고 백그라운드 상태로 전환하기 시작할 때 발생할 수 있습니다.이 방법을 사용하여 진행중인 작업을 일시 중지하고 타이머를 비활성화하고 그래픽 렌더링 콜백을 무효화하십시오. 게임은 이 방법을 사용하여 게임을 일시 중지해야합니다. 우리의 친절한 구글 번역기가 번역을 잘해줬네요. 앱을 사용하다가 전화가 오는 등의 일시적인 중단이나 홈 버튼을 눌러서 앱을 종료하면 수행되는 메소드라고 합니다. applicationDidEnterBackground 세번째의 메소드는 applicationDidEnterBackground 입니다. 이번에도 주석을 번역해보겠습니다. 123이 방법을 사용하여 공유 리소스를 해제하고, 사용자 데이터를 저장하고, 타이머를 무효화하고, 응용 프로그램이 나중에 종료 될 경우 응용 프로그램을 현재 상태로 복원 할 수있는 충분한 응용 프로그램 상태 정보를 저장하십시오.애플리케이션이 백그라운드 실행을 지원하는 경우 사용자가 종료 할 때는 applicationWillTerminate 메소드가 대신 호출됩니다. applicationDidEnterBackground 는 이름에서 알 수 있듯이 백그라운드로 들어가진 다음에 호출됩니다. applicationWillResignActive 에 이어서 동작되는 메소드라고 할 수 있습니다. applicationWillEnterForeground 네번째 메소드 applicationWillEnterForeground 입니다. 이번에도 맥락을 확인하기 위해 주석을 번역해봤습니다. 1백그라운드에서 활성 상태로 전환의 일부로 호출됩니다. 이름을 해석해보면 앱이 Foreground(화면) 에 나오기 시작할 때 실행되는 메소드입니다. applicationDidBecomeActive 5번째 메소드는 applicationDidBecomeActive 입니다. 이름에서 알 수 있듯이 백그라운드로 갔던 앱이 다시 정면에 나타난 이후 실행되는 메소드입니다. applicationWillEnterForeground 에 이어서 실행되는 메소드라고 할 수 있겠습니다. applicationWillTerminate 마지막 메소드 applicationWillTerminate 입니다. 어플리케이션이 종료될 때 실행되는 메소드입니다. 다만 애플에서는 applicationWillTerminate 메소드의 실행을 보장하지는 않습니다. 어플이 종료되는 경우 applicationWillTerminate 메소드가 꼭 실행되지는 않았습니다. 그래서 어플이 종료될 때 꼭 실행해야 할 작업이 있다면 앱이 백그라운드로 가는 메소드인 applicationDidEnterBackground 에서 수행해야 합니다. 정리AppDelegate 에 있는 메소드들에 대해서 간단하게 살펴봤습니다. 잘못된 정보가 있거나 피드백하고 싶으시다면 댓글 부탁드립니다. 읽어주셔서 감사합니다.","categories":[{"name":"iOS","slug":"iOS","permalink":"https://appleceo.github.io/categories/iOS/"}],"tags":[{"name":"AppDelegate","slug":"AppDelegate","permalink":"https://appleceo.github.io/tags/AppDelegate/"},{"name":"application","slug":"application","permalink":"https://appleceo.github.io/tags/application/"},{"name":"applicationWillResignActive","slug":"applicationWillResignActive","permalink":"https://appleceo.github.io/tags/applicationWillResignActive/"},{"name":"applicationDidEnterBackground","slug":"applicationDidEnterBackground","permalink":"https://appleceo.github.io/tags/applicationDidEnterBackground/"},{"name":"applicationWillEnterForeground","slug":"applicationWillEnterForeground","permalink":"https://appleceo.github.io/tags/applicationWillEnterForeground/"},{"name":"applicationDidBecomeActive","slug":"applicationDidBecomeActive","permalink":"https://appleceo.github.io/tags/applicationDidBecomeActive/"},{"name":"applicationWillTerminate","slug":"applicationWillTerminate","permalink":"https://appleceo.github.io/tags/applicationWillTerminate/"}]},{"title":"HTTP 통신 허용 방법","slug":"acceptHttp","date":"2019-09-07T02:55:19.000Z","updated":"2021-07-13T05:30:19.387Z","comments":true,"path":"2019/09/07/acceptHttp/","link":"","permalink":"https://appleceo.github.io/2019/09/07/acceptHttp/","excerpt":"","text":"안녕하세요. 도미닉입니다. json 을 받아오는 등의 네트워크 작업을 할 때 http 통신을 하게 되면 아래와 같은 오류를 마주하게 됩니다. 12345App Transport Security has blocked a cleartext HTTP (http://) resource load since it is insecure. Temporary exceptions can be configured via your app&apos;s Info.plist file.The resource could not be loaded because the App Transport Security policy requires the use of a secure connection. 애플이 보안 상의 이유로 오류를 발생시켜 막아놓은 것입니다. 실제 서비스에는 https 를 사용해야 하겠습니다. 개발이나 테스트용, 어쩔 수 없는 이유가 있다면 http 통신을 허용할 수 있습니다. HTTP 통신 허용 방법 Info.plist 를 source code 모드로 엽니다. 아래 코드를 dict 태그 안에 복사 붙여넣기 합니다. 12345&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;&lt;dict&gt; &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt; &lt;true/&gt;&lt;/dict&gt; 저장합니다. 위에 내용을 수행하신 뒤에 다시 http 통신을 시도해보시면 오류 없이 동작할 것입니다. 정리문제가 있거나 궁금하신 내용 있으면 댓글주세요. 읽어주셔서 감사합니다. 참고 : https://slobell.com/blogs/54","categories":[{"name":"iOS","slug":"iOS","permalink":"https://appleceo.github.io/categories/iOS/"}],"tags":[{"name":"error","slug":"error","permalink":"https://appleceo.github.io/tags/error/"},{"name":"http","slug":"http","permalink":"https://appleceo.github.io/tags/http/"},{"name":"Info.plist","slug":"Info-plist","permalink":"https://appleceo.github.io/tags/Info-plist/"}]},{"title":"키보드 내리는 방법","slug":"keyboardDown","date":"2019-08-29T02:57:14.000Z","updated":"2021-07-13T05:30:19.391Z","comments":true,"path":"2019/08/29/keyboardDown/","link":"","permalink":"https://appleceo.github.io/2019/08/29/keyboardDown/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 iOS 에서 키보드를 내리는 방법에 대해서 알아보겠습니다. 검색을 할 때 키워드를 다 입력했는데도 키보드를 내릴 수 없다면 화면의 반은 키보드로 계속 가려질 것입니다. 이럴 때 키보드를 내려줘야합니다. 그럼 어떻게 키보드를 내릴 수 있는지 알아보겠습니다. 뷰를 터치하면 키보드가 내려가도록 하는 방법키보드가 아닌 화면을 터치하면 키보드가 내려가도록 할 수 있을 것입니다. 터치했을 때 키보드가 내려갔으면 하는 뷰에 아래 소스처럼 메소드를 작성하시면 됩니다. 간단하게 3줄로 터치 했을 때 endEditing 메소드를 실행하여 키보드를 내릴 수 있습니다. 주의할 점은 하위 뷰를 클릭했을 때 키보드를 내리고 싶은 상황이라 상위 뷰의 endEditing 메소드를 실행하고 있는 것입니다. 이 부분은 터치하는 뷰와 키보드를 내린 뷰의 관계에 따라 달라질 수 있습니다. 키보드의 검색 버튼을 눌렀을 때 키보드가 내려가도록 하는 방법키보드의 검색 버튼을 눌렀는데 키보드가 내려가지 않고 버티고 있으면 안될 것입니다. 이때 키보드를 내려가는 방법은 아래 소스처럼 메소드를 작성하시면 됩니다. 검색 버튼을 눌렀을 때 endEditing 메소드를 실행하고 있는 것입니다. 정리오늘은 키보드를 내리는 두가지 방법에 대해서 알아봤습니다. 더 알고 계신 방법이 있다면 댓글로 남겨주셔도 좋을 것 같습니다. 감사합니다. 참고 :http://blog.naver.com/PostView.nhn?blogId=jdub7138&amp;logNo=220960570029&amp;redirect=Dlog&amp;widgetTypeCall=true","categories":[{"name":"iOS","slug":"iOS","permalink":"https://appleceo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://appleceo.github.io/tags/iOS/"},{"name":"Keyboard","slug":"Keyboard","permalink":"https://appleceo.github.io/tags/Keyboard/"},{"name":"endEditing","slug":"endEditing","permalink":"https://appleceo.github.io/tags/endEditing/"},{"name":"키보드","slug":"키보드","permalink":"https://appleceo.github.io/tags/키보드/"},{"name":"키패드","slug":"키패드","permalink":"https://appleceo.github.io/tags/키패드/"},{"name":"내리는 방법","slug":"내리는-방법","permalink":"https://appleceo.github.io/tags/내리는-방법/"},{"name":"down","slug":"down","permalink":"https://appleceo.github.io/tags/down/"}]},{"title":"WKWebView","slug":"WKUserScript","date":"2019-08-28T07:55:04.000Z","updated":"2021-07-13T05:30:19.386Z","comments":true,"path":"2019/08/28/WKUserScript/","link":"","permalink":"https://appleceo.github.io/2019/08/28/WKUserScript/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 WKWebView 에 대해서 알아보겠습니다. WKWebView 란?WKWebView 는 iOS 8에서 생긴 웹 뷰를 보여주기 위한 UIView 입니다. 기존에 있었던 UIWebView 의 업그레이드 버전이라고 보시면 될 것 같습니다. 현재 UIWebView 는 아래 사진과 같이 deprecate 되었습니다. WKWebView 를 이용해 간단히 웹페이지 띄우는 방법 WKWebView 화면을 mainStoryBoard 에 추가합니다. 스토리보드에 추가한 WKWebView 를 viewController 에 연동합니다. 아래와 같이 뷰컨트롤러를 작성하고 실행시킵니다. 간단하게 이미지를 띄우는 것처럼 웹페이지를 띄울 수 있었습니다. WKUserScript 를 이용해 로드하는 웹페이지에 JavaScript 소스를 실행하는 방법WKUserScript 를 이용하려면 WKWebView 초기화 시점에 적용해야하므로 소스로 WKWebView 를 만들어야합니다. 스토리보드에 WKWebView 를 subView 로 추가할 UIView 를 하나 만듭니다. containverView.swift 라는 UIView 의 하위 클래스를 만듭니다. 만든 스토리보드의 UIView 에 커스텀 클래스 containverView 를 채택합니다. containverView.swift 파일을 아래 내용으로 작성합니다. 위에 방법으로 WKUserScript 를 설정했음에도 불구하고 JavaScript 소스가 적용이 안될 때페이지의 일부분은 나중에 로드되는 경우 WKUserScript 을 설정했음에도 불구하고 해당 부분에는 설정한 JavaScript 가 적용되지 않는 문제가 있었습니다. 그럴 때는 전체 페이지가 로드된 후에 자바 스크립트를 실행하면 됩니다. 아까 작성한 예제소스를 아래와 같이 수정하였습니다. WKWebView 의 상태를 확인하기 위해 WKNavigationDelegate 을 채택하였습니다. containverView 의 draw 메소드에 webView.navigationDelegate = self 을 추가하였습니다. WKWebView 의 로드가 완료될 때 실행되는 webView(didFinish:) 메소드에 자바스크립트를 실행하는 webView.evaluateJavaScript 메소드를 추가하였습니다. 정리이상으로 WKWebView 와 WKWebView 에서 자바스크립트를 실행하는 방법을 알아봤습니다. 궁금하신 점은 댓글 남겨주세요. 읽어주셔서 감사합니다. 뿅~ 참고 :https://zeddios.tistory.com/332 - UIWebView 와 WKWebView 의 차이점https://medium.com/capital-one-tech/javascript-manipulation-on-ios-using-webkit-2b1115e7e405 - WKUserScript 사용 예제https://faith-developer.tistory.com/60 - WebKit Delegate 설명https://developer.apple.com/documentation/webkit/wkuserscript - wkuserscript 애플 공식 문서","categories":[{"name":"iOS","slug":"iOS","permalink":"https://appleceo.github.io/categories/iOS/"}],"tags":[{"name":"WKWebView","slug":"WKWebView","permalink":"https://appleceo.github.io/tags/WKWebView/"},{"name":"WKUserContentController","slug":"WKUserContentController","permalink":"https://appleceo.github.io/tags/WKUserContentController/"},{"name":"WKWebViewConfiguration","slug":"WKWebViewConfiguration","permalink":"https://appleceo.github.io/tags/WKWebViewConfiguration/"},{"name":"WKUserScript","slug":"WKUserScript","permalink":"https://appleceo.github.io/tags/WKUserScript/"},{"name":"WebView","slug":"WebView","permalink":"https://appleceo.github.io/tags/WebView/"},{"name":"Script","slug":"Script","permalink":"https://appleceo.github.io/tags/Script/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://appleceo.github.io/tags/JavaScript/"}]},{"title":"네트워크에서 Json 데이터 가져오기","slug":"networkProgramming","date":"2019-08-19T04:53:50.000Z","updated":"2021-07-13T05:30:19.392Z","comments":true,"path":"2019/08/19/networkProgramming/","link":"","permalink":"https://appleceo.github.io/2019/08/19/networkProgramming/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 네트워크에서 Json 데이터 가져오는 방법에 대해서 알아보겠습니다. 모바일 기기에서 가장 중요한 부분 중에 하나는 네트워크일 것입니다. 요즘에는 스마트폰을 통해 어디서든, 언제든 인터넷에 접속할 수 있습니다. 24시간 온라인 시대가 펼쳐진 것입니다. 그렇다면 아이폰에서 어떻게 json 데이터를 받아올 수 있을까요? URLSession스위프트는 네트워크 작업을 위한 URLSession 클래스를 제공합니다. 위에 예제는 랜덤 유저 생성 api 를 사용해 json 을 모델로 변환하는 예제입니다. https://randomuser.me : 해당 API 에 대한 자세한 설명을 보실 수 있습니다. API 에서 5명의 유저 정보(성별, 이름, 출신) 을 받아오도록 url 을 작성하였습니다. 이 부분은 API 의 도큐멘트 참고 바랍니다. 코드 설명 25번째 줄let task = URLSession.shared.dataTask(with: url) { (data, response, error) in dataTast 메소드는 url 에 요청을 보냅니다. 뒤에 붙는 data, response, error 에 대해서 알아보겠습니다. data : 서버가 리턴한 데이터입니다. response : HTTP 헤더 및 상태 코드와 같은 응답 메타 데이터를 제공하는 객체입니다. error : 요청이 실패한 이유를 나타내는 오류 객체입니다. 요청이 성공한 경우 nil입니다. 이런 식으로 url 을 통해 데이터와 응답을 받아올 수 있습니다. 33번째 줄let userResponse = try decoder.decode(RandomUserResponse.self, from: data) 위에서 생성한 JSONDecoder() 를 이용해서 받아온 데이터를 RandomUserResponse 모델 객체로 변환합니다. 이상으로 URLSession 을 이용해 json 데이터를 가져오는 방법을 정리해봤습니다. String(contentsOf: URL)URL 에서 바로 데이터를 받아오는 방법도 있습니다. 예제 소스입니다. 코드 설명 URL 을 string 으로 초기화합니다.String(contentsOf:url) 을 작성하면 해당 URL 에 있는 데이터를 String 으로 받아옵니다. 이 String 을 적절한 형태로 변환합니다. 4번째 줄 가장 오른쪽에 as? [[String: String]] 는 상황에 따라 올라와있는 json 데이터의 형태에 따라 상이합니다. 정리이상으로 json 데이터를 받아오는 2가지 방법을 알아봤습니다. 더 알고 계신 방법이나 틀린 부분, 궁금하신 부분 댓글 달아주시면 같이 고민해봅시다. 감사합니다.","categories":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/tags/Swift/"},{"name":"Network","slug":"Network","permalink":"https://appleceo.github.io/tags/Network/"},{"name":"URLRequest","slug":"URLRequest","permalink":"https://appleceo.github.io/tags/URLRequest/"},{"name":"URL","slug":"URL","permalink":"https://appleceo.github.io/tags/URL/"},{"name":"URLSession","slug":"URLSession","permalink":"https://appleceo.github.io/tags/URLSession/"},{"name":"dataTask","slug":"dataTask","permalink":"https://appleceo.github.io/tags/dataTask/"}]},{"title":"Drag And Drop Using UIPanGesutreRecognizer","slug":"dragAndDrop","date":"2019-08-18T13:04:41.000Z","updated":"2021-07-13T05:30:19.388Z","comments":true,"path":"2019/08/18/dragAndDrop/","link":"","permalink":"https://appleceo.github.io/2019/08/18/dragAndDrop/","excerpt":"","text":"안녕하세요. 도미닉입니다. 저번 글을 통해서 UIView 를 드래그하는 예제를 살펴봤습니다. 못보신 분이나 궁금하신 분은 아래 링크 확인해주시기 바랍니다. http://kiljh.me/2019/08/13/pan/ 오늘은 드래그했던 뷰를 드롭하는 것과 UIPanGesutreRecognizer 에서의 state 들을 알아보고자 합니다. drag and drop 위에 예제대로 작성하시고 실행시킵니다. 드래그하던 뷰를 놓았을 때 놓여진 좌표가 print 되는 것을 보실 수 있습니다. UIPanGesutreRecognizer.state 위에 사진을 보시면 UIPanGesutreRecognizer 에서 상태는 began, cancelled, changed, ended, failed, possible, recognized 7가지가 있습니다. 하나씩 테스트해보면서 어떤 때 실행이 되는지 알아보겠습니다. 위에 움짤처럼 switch 를 우클릭하고 Refactor - Expand Switch Cases 를 하시면 모든 case 가 switch 문에 추가됩니다. 이렇게 작성해서 언제 어떤 상태가 되는지 확인해보겠습니다. 테스트 결과 began : 드래그가 시작되면 began 상태가 됩니다.(처음 클릭시 began 이 되지는 않습니다.) changed : 드래그 중에 좌표가 변경되면 changed 상태가 됩니다. ended : 드래그하던 손을 놓으면 ended 상태가 됩니다.(drop) 테스트 결과에 cancelled, failed, possible, recognized 는 없는데요. 이것들에 대해서도 나중에 시간되면 알아보도록 하겠습니다. 정리저번에 드래그 글에 이어서 드롭을 하는 방법에 대해서 알아봤습니다. UIPanGesutreRecognizer 의 상태에 대해서도 간단히 정리해봤습니다. 글 읽어주셔서 감사합니다. 궁금한 점은 댓글 달아주세요.","categories":[{"name":"iOS","slug":"iOS","permalink":"https://appleceo.github.io/categories/iOS/"}],"tags":[{"name":"스위프트","slug":"스위프트","permalink":"https://appleceo.github.io/tags/스위프트/"},{"name":"iOS","slug":"iOS","permalink":"https://appleceo.github.io/tags/iOS/"},{"name":"UIGestureRecognizer","slug":"UIGestureRecognizer","permalink":"https://appleceo.github.io/tags/UIGestureRecognizer/"},{"name":"UIPanGesutreRecognizer","slug":"UIPanGesutreRecognizer","permalink":"https://appleceo.github.io/tags/UIPanGesutreRecognizer/"},{"name":"drag","slug":"drag","permalink":"https://appleceo.github.io/tags/drag/"},{"name":"drop","slug":"drop","permalink":"https://appleceo.github.io/tags/drop/"},{"name":"드래그","slug":"드래그","permalink":"https://appleceo.github.io/tags/드래그/"},{"name":"드롭","slug":"드롭","permalink":"https://appleceo.github.io/tags/드롭/"}]},{"title":"iOS UIView 드래그하기","slug":"pan","date":"2019-08-13T01:49:58.000Z","updated":"2021-07-13T05:30:19.393Z","comments":true,"path":"2019/08/13/pan/","link":"","permalink":"https://appleceo.github.io/2019/08/13/pan/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 iOS 에서 UIView 를 드래그하는 방법을 알아보겠습니다. iOS 에서는 터치에 대한 제스처를 어떤 식으로 처리하고 있을까요? iOS 에서 제스처를 처리하기 위해서는 UIGestureRecignizer 를 사용해야합니다. drag 을 하기 위해서는 UIPanGestureRecignizer 을 사용해야 합니다. 공식문서를 보시면 UIPanGestureRecignizer 은 UIGestureRecignizer 의 subclass 입니다. 예제를 따라해가며 UIView 를 드래그하는 실습을 해보겠습니다. Step1 위에 사진과 같이 UIView 를 화면에 생성합니다. UIImageView 도 UIView 를 상속받기 때문에 가능합니다. 주황색 상자에 있는 User Interaction Enabled 를 체크합니다. Step2 위와 같이 ViewController.swift 를 작성해줍니다. @IBOutlet weak var imageView: UIImageView! 는 스토리보드에서 만든 UIImageView 와 연동해주어야 합니다. Step3 시뮬레이터를 실행시키고 테스트해보시면 뷰가 드래그되고 마우스를 따라오는 것을 알 수 있습니다. 소스 분석draggingView 메소드를 먼저 살펴봅시다. 첫번째 줄 : sender.location(in: view) 에서 손가락의 위치를 point 에 저장합니다. 두번째 줄 : sender.view 는 손가락이 클릭하고 있는 view 를 draggedView 에 저장합니다. 세번째 줄 : draggedView 의 중심을 손가락 위치인 point 에 따라 움직입니다. 정리간단하게 UIView 를 드래그에 따라 움직이도록 소스를 작성해봤습니다. 비슷한 예제를 찾지 못해서 헤멨습니다. 도움이 됬으면 좋겠습니다. 아래 제가 참고한 유튜브를 보시면 동영상으로 예제를 따라해보실 수 있습니다. 참고 : https://www.youtube.com/watch?v=1U4-6CESv-s 예제 프로젝트 : https://github.com/kiljh-me/Pan","categories":[{"name":"iOS","slug":"iOS","permalink":"https://appleceo.github.io/categories/iOS/"}],"tags":[{"name":"스위프트","slug":"스위프트","permalink":"https://appleceo.github.io/tags/스위프트/"},{"name":"iOS","slug":"iOS","permalink":"https://appleceo.github.io/tags/iOS/"},{"name":"UIView","slug":"UIView","permalink":"https://appleceo.github.io/tags/UIView/"},{"name":"UIGestureRecognizer","slug":"UIGestureRecognizer","permalink":"https://appleceo.github.io/tags/UIGestureRecognizer/"},{"name":"UIPanGesutreRecognizer","slug":"UIPanGesutreRecognizer","permalink":"https://appleceo.github.io/tags/UIPanGesutreRecognizer/"},{"name":"drag","slug":"drag","permalink":"https://appleceo.github.io/tags/drag/"},{"name":"드래그","slug":"드래그","permalink":"https://appleceo.github.io/tags/드래그/"},{"name":"드래그하기","slug":"드래그하기","permalink":"https://appleceo.github.io/tags/드래그하기/"},{"name":"dragging","slug":"dragging","permalink":"https://appleceo.github.io/tags/dragging/"},{"name":"드래깅","slug":"드래깅","permalink":"https://appleceo.github.io/tags/드래깅/"}]},{"title":"아이콘 적용하기","slug":"iconMake","date":"2019-08-06T16:08:01.000Z","updated":"2021-07-13T05:30:19.390Z","comments":true,"path":"2019/08/07/iconMake/","link":"","permalink":"https://appleceo.github.io/2019/08/07/iconMake/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 아이콘 만드는 방법에 대해서 알아보겠습니다. Step1우선 1024x1024 사이즈의 이미지를 구해야합니다. 1024x1024 사이즈 이미지를 구하셨다면 아래 작업을 하지 말고 두번째 스텝으로 넘어가시면 됩니다. 이미지를 1024x1024 로 사이즈 조정하는 방법1024x1024 사이즈의 이미지를 구할 수 없다면 아래 사이트에서 이미지의 사이즈를 조정할 수 있습니다. https://www.iloveimg.com/ko/resize-image/resize-png “여러 이미지 선택”을 클릭한 뒤에 아이콘으로 만들 이미지 파일을 선택합니다. 여러 이미지를 선택하라고 적혀있지만 하나만 클릭해도 됩니다. 너비와 높이를 1024 로 적어줍니다. 그 다음에 아래에 “여러 이미지 크기 조절” 을 클릭합니다. 조금 기다리면 사이즈가 조정된 이미지가 생성되며 이미지를 다운로드하면 됩니다. Step2이제 1024x1024 이미지가 준비되었습니다. 아래 홈페이지에 들어가서 준비된 이미지를 업로드합니다. https://appiconmaker.co CHOOSE FILE 을 클릭해서 finder 에서 이미지를 선택하거나 이미지 파일을 드래그해서 drag and drop here 위치에 드롭하면 됩니다. GENERATE 를 클릭하면 iOS 아이콘에 필요한 크기의 이미지들이 생성됩니다. 생성된 이미지 파일을 다운로드 합니다. step3이제 iOS 아이콘에서 필요한 사이즈별 이미지가 준비되었습니다. 아이콘을 적용하고 싶은 Xcode project 을 엽니다. 프로젝트 내 기본으로 생성되는 파일 중에 Assets.xcassets 을 엽니다. AppIcon 을 클릭하면 아래 사진처럼 사이즈 별 아이콘을 넣을 수 있는 칸이 있습니다. 준비한 사이즈별 이미지를 아래 이미지에 써있는 사이즈 별로 넣어주면 됩니다. 예를 들어 20x20 이라고 적혀있는 칸에는 Icon-20.png 이미지를 넣어주면 됩니다. 정리지금까지 앱에 아이콘을 적용하는 방법을 알아봤습니다. 도움이 되었으면 좋겠습니다. 글 읽어주셔서 감사합니다.","categories":[{"name":"iOS","slug":"iOS","permalink":"https://appleceo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://appleceo.github.io/tags/iOS/"},{"name":"Xcode","slug":"Xcode","permalink":"https://appleceo.github.io/tags/Xcode/"},{"name":"Icon","slug":"Icon","permalink":"https://appleceo.github.io/tags/Icon/"}]},{"title":"let us go 2019 Summer review","slug":"letusgo2019Summer","date":"2019-08-05T03:20:39.000Z","updated":"2021-07-13T05:30:19.392Z","comments":true,"path":"2019/08/05/letusgo2019Summer/","link":"","permalink":"https://appleceo.github.io/2019/08/05/letusgo2019Summer/","excerpt":"","text":"안녕하세요. 도미닉입니다. 저번주 토요일에 let us: go 2019 summer 세미나에 참석했습니다. 처음으로 참석한 Swift 관련 세미나였고 긴 시간의 세미나였습니다. 새로운 분들을 만나 자극도 받고 새로운 기술들을 알 수 있는 유익한 시간이었습니다. 그에 대한 후기를 작성하고자 합니다. B 트랙첫번째 발표 누구나 할 수 있다. Networking 카우 https://github.com/kawoou/letusgo-photo-album 카우님이 발표해주셨습니다. alamofire 와 moya 을 이용해 네트워킹을 하는 실습을 하셨습니다. 저는 네트워킹을 해본적이 없어서 실습을 따라가지는 못했습니다. 조금 더 천천히 코어적인 부분 위주로 실습을 했으면 더 따라가기 쉬웠을 것 같습니다. mac os 를 카탈리나 베타 5 로 업그레이드하면서 cocoaPod 이 동작하지 않아서 소스를 따라치지도 못했네요. 써야하는 프로그램이 있다면 미리 공지해주시면 실습을 따라하는데 도움이 될 것 같습니다. “Moya 는 네트워크를 담당하는 파일을 만들어야 한다.” 라고 말하셨는데 조만간 alamofire 와 moya 를 이용해 보면 이해할 수 있을 것 같습니다. 두번째 발표 빨간맛 SwiftUI keyWindow https://github.com/iOSDevKor/swift_ui_2019_summer keyWindow 님이 발표해주셨습니다. 스위프트 UI 의 기본적인 내용부터 꼼꼼하게 발표해주셔서 쉽게 이해하면서 들을 수 있었습니다. 말씀하신 부분을 요약해봤습니다. AppKit, UIKit 등의 UI 소스가 기존에는 플랫폼 별로 셋팅을 해주어야한다. 반면에 Swift UI 로 작성을 하면 어느 플랫폼에 가져가도 다 쓸 수 있다. UI 객체들이 기존에는 클래스로 구성되어 있었다. 스위프트 UI 에서는 UI 객체가 구조체로 구성되어 있다. UIKit 은 명령형 UI 이고 SwiftUI 는 선언형 UI라는 점도 차이점이다. 선언형은 상태가 어떤지 등은 말하지 않고 표현하라고만 한다. Swift UI 는 MVVM 에 용이하게 설계되어 있다. View 와 view model 이 바인딩(싱크)되기 때문이다. 위와 같은 이유로 기존의 흐름이 엇갈리는 등의 문제가 발생하지 않는다. some : Opaque Return Type 이며 프로토콜에 해당하는 뭔가를 리턴할 것이다(불투명 리턴타입) 스위프트 5.0 부터 메소드 안에 소스가 한줄만 있으면 앞에 return 이 생략 가능하다. 앞에 @ 가 붙어있으면 Property Wrapper 이다. (매직박스) 파이프의 역할을 Combine 이 한다. (Publisher - Subscriber) Publisher 는 데이터를 쥐고 있는 사람. 다크모드와 라이트모드에서 사용할 색상을 따로 설정할 수 있다. 세번째 발표 iPadOS 13 앱 Step by Step 구범모 https://github.com/gbmksquare/let-us-Go-iPadOS-Demo https://github.com/gbmksquare/let-us-Go-iPadOS-Demo-Complete 구범모님께서 발표해주셨습니다. 시간이 촉박해서 인지 다소 빠르게 진행됬습니다. 아이패드 스케치북 앱을 만들었는데 카메라로 사진을 찍으면 스캔이 되는 등의 기능들이 간단하게 코드 한두줄로 작성되는 것이 신기했습니다. 이번에도 너무 여러 기능들을 구현하기 위해서 자세한 설명없이 코드 따라치는 식으로 진행이 되서 아쉬웠습니다. 중간에 하나라도 놓치면 전체를 따라가기가 힘들었습니다. 이번에 새로 나온 기능들과 여러 윈도우를 띄어보는 경험을 해봐서 좋았습니다. 네번째 발표 RxSwift Internal 엉덩숭아 https://github.com/intmain/DismissDisposable RxSwift 를 해보지 않은 상태에서 저번 Let Us: Go 에서 발표하신 Observable 세션만 보고 발표을 들었습니다. 아무래도 RxSwift 에 대한 이해가 없는 상태라 Observable 세션과 이번 발표 또한 이해가 많이 가지는 않았습니다. 하지만 RxSwift 가 어떻게 구성되있는지 조금이라도 익숙해질 수 있었습니다. 주말동안 발표 처음에 말씀하신 곰튀김님의 “RxSwift 4시간만에 끝내기” 을 보았습니다. RxSwift 에 대해서 이해가 생겼고 어떻게 공부할지도 알 수 있었습니다. 곰튀김님의 영상을 본 상태에서 저번에 엉덩숭아님이 발표하신 Observable 세션을 보니 더 이해가 됬습니다. 비록 발표는 많이 못알아들었지만 말로만 듣던 RxSwift 에 대한 공부의 자극도 받고 익숙해질 수 있었던 세션이었습니다. 다섯번째 발표 App Lifecycle giftbot https://github.com/giftbott/CardStyleLifecycle giftbot 님께서 발표해주셨습니다. view life cycle 에 대한 발표인지 알았는데 App 의 라이프 사이클에 대한 발표였습니다. 시간이 없었음에도 불구하고 개념들 설명과 따라하기 쉬운 예제 소스까지 깔끔하게 발표해주셨습니다. commit 을 남겨주셔서 따라서 안치더라도 다음 소스가 완성된 상태로 이동할 수 있어서 좋았습니다. 아래는 발표해주신 내용 요약한 내용입니다. 맥os 카탈리나부터 64비트 만 지원한다. Int 가 32비트였으면 4바이트였는데 64비트면 8바이트이다. iTunes Connect 가 App Store connect 로 바뀌었다. 낮은 버전의 OS 는 런타임 복사본이 필요하다. Tester Onboarding 은 어떤걸 테스트할지 등을 안내함 앱 이름 최대 30자, 부제목 최대 30자 앱 아이콘은 PNG Fullscreen != Sheet 내리면 View will disappear 로 바뀜 Print 대신에 OSLog 쓰는게 더 좋음 isModalInPresentation 을 true 로 하면 (기본값은 false) 내려서 dismiss 못함 presentationControllerDidAttemptToDismiss : 제스처로 인한 디스미스가 실패했을 때 호출되는 메소드 정리처음갔던 스위프트 세미나였습니다. 너무나 좋은 시간이었고 발표하시는 분들 보고 자극을 많이 받았습니다. 다음 가을 세미나도 갈 수 있도록 신청해야겠습니다. 나중에는 발표도 할 수 있도록 더 공부하고 연구해야겠습니다. 읽어주셔서 감사합니다.","categories":[{"name":"Seminar","slug":"Seminar","permalink":"https://appleceo.github.io/categories/Seminar/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/tags/Swift/"},{"name":"iOS","slug":"iOS","permalink":"https://appleceo.github.io/tags/iOS/"},{"name":"Seminar","slug":"Seminar","permalink":"https://appleceo.github.io/tags/Seminar/"}]},{"title":"Auto Layout","slug":"AutoLayout","date":"2019-07-25T01:48:05.000Z","updated":"2021-07-13T05:30:19.378Z","comments":true,"path":"2019/07/25/AutoLayout/","link":"","permalink":"https://appleceo.github.io/2019/07/25/AutoLayout/","excerpt":"","text":"Auto Layout dynamically calculates the size and position of all the views in your view hierarchy, based on constraints placed on those views. = 는 동등한 equal 의 뜻 attribute : 어디에 해당하는 부분인지서양인에게는 Leading(글자가 시작하는 방향)이 왼쪽이라서 왼쪽은 Leading 이다. 팁 오토레이아웃을 구성할 때 모양을 대략적으로 만들어놓고 시작하는게 좋다 기준을 잡고 시작하라.(가장 중요한 뷰) 비율을 나타낼 떄 1:1이라고 비율로 나타내는 것보다 1 이라고 소수 하나로 표현하는게 나음 다음주 priority, stackView, ScrolView 10시반부터 수업 시작","categories":[],"tags":[]},{"title":"Functor and Monad","slug":"functorMonad","date":"2019-07-21T07:22:45.000Z","updated":"2021-07-13T05:30:19.389Z","comments":true,"path":"2019/07/21/functorMonad/","link":"","permalink":"https://appleceo.github.io/2019/07/21/functorMonad/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 Functor 와 Monad 에 대해서 알아보겠습니다. Functor 란?Functor 는 일반적으로 Map 이라는 함수를 실행해서 같은 타입의 결고값을 얻는 것을 의미합니다. 예를 들어 [1,2,3,4,5] 라는 배열의 Map 함수를 실행해서 [2,4,6,8,10] 이 반환된다면 이러한 배열 타입은 Functor 입니다. 그렇다면 [1,2,3,4,5] 이 Map 이라는 함수에 넣어서 [true,true,false,false,false] 가 리턴된다면 이 배열의 타입은 Functor 일까요? Functor 가 맞습니다. 위에서 적었던 대로 Map 이라는 함수를 실행해서 같은 타입인 배열이 리턴되었기 때문입니다. Functor 는 값을 빼낼 수 없습니다. 값을 꺼내는 것은 순수한 펑터의 개념을 벗어나는 일입니다. 펑터를 이용하는 유일한 방법은 타입 안전성을 유지하면서 값을 변형해 나가는 것 뿐입니다. Monad 란?Monad 는 Functor 에 포함됩니다. 모나드에서는 특별히 flatmap 이라는 함수가 구현되어야합니다. 모나드는 Map 이라는 함수에 넣어서 정의역과 같은 숫자의 치역이 리턴되기만 했던 Functor 와 달리같은 숫자의 치역이고 정의역과 동일한 타입이 리턴되어야만합니다. 예를 들어 [1,2,3,4,5] 라는 배열을 flatmap 이라는 함수에 넣어서 [2,4,6,8,10] 가 반환됩니다. 이것은 모나드입니다. 하지만 [1,2,3,4,5] 이 [true,true,false,false,false] 라는 다른 타입이 리턴되면 이것은 펑터이지만 모나드가 아닙니다. 스위프트에서 Functor 와 Monad 는?Set 위에 소스의 set 상수는 Set 타입입니다. 이러한 Set 타입도 Map 이 존재합니다. Map 을 돌리면 {1,2,3,4,5} 집합 타입은 [2,4,6,8,10] Int 배열로 리턴됩니다. 이렇게 되면 같은 타입으로 리턴되지 않으므로 Set 타입은 Functor 이지만 Monad 는 아닙니다. Dictionary Dictionary 에도 Map 함수가 존재합니다. 하지만 리턴 값을 Dictionary 로 하지는 못합니다. 배열 타입으로 리턴이 가능하며 이런식으로 다른 타입으로 리턴되는 것은 Functor 입니다. 스위프트에서 Monad type 은?Array 위에 소스에서 보시면 array 는 [1,2,3,4,5] 입니다. map 에 의해서 [2,4,6,8,10] 으로 바뀔 수 있으므로 Functor 입니다. map 에 의해서 다시 [1,2,3,4,5] 으로 돌아올 수 있으므로 Monad 입니다. Optional 위에 소스에서 보시면 optional 변수는 옵셔널 Int 형입니다. optional 에도 Map 은 존재합니다. Map 을 통해 optional Int 형태의 2 로 바뀌었다가 다시 Optional Int 형의 1 로 돌아옵니다. 다시 돌아오므로 Monad 입니다. 정리오늘은 Functor 와 Monad 에 대해서 알아봤습니다. 이러한 예제를 보셔서 이해하는데 도움이 됬으면 좋겠습니다. 읽어주셔서 감사합니다.","categories":[{"name":"Terminology","slug":"Terminology","permalink":"https://appleceo.github.io/categories/Terminology/"}],"tags":[{"name":"펑터","slug":"펑터","permalink":"https://appleceo.github.io/tags/펑터/"},{"name":"Functor","slug":"Functor","permalink":"https://appleceo.github.io/tags/Functor/"},{"name":"Monad","slug":"Monad","permalink":"https://appleceo.github.io/tags/Monad/"},{"name":"모나드","slug":"모나드","permalink":"https://appleceo.github.io/tags/모나드/"}]},{"title":"Factory Pattern","slug":"FactoryPattern","date":"2019-07-21T06:24:23.000Z","updated":"2021-07-13T05:30:19.380Z","comments":true,"path":"2019/07/21/FactoryPattern/","link":"","permalink":"https://appleceo.github.io/2019/07/21/FactoryPattern/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 팩토리 패턴에 대해서 알아보겠습니다. 팩토리 패턴이란?팩토리하면 어떤 것이 생각나시나요? 제품을 만드는 공장이 생각이 납니다. 팩토리 패턴은 인스턴스를 만드는 객체를 두는 패턴이라고 생각할 수 있습니다. 팩토리 패턴 구현 제가 예전에 작성한 도형을 만드는 팩토리 객체입니다. 소스를 보면 return 값으로 Figure 이라는 프로토콜 타입을 리턴하는 것을 알 수 있습니다. 하나의 프로토콜을 따르는 여러 객체 중에 적절한 것을 생성하고 리턴하는 것입니다. getFigure 메소드의 매개변수인 coordinates 에 점의 배열의 요소가 하나면 MyPoint 객체를 생성하고 리턴합니다. 점이 2개면 직선, 3개면 삼각형, 4개면 사각형 객체를 생성하고 리턴합니다. 이런 식으로 객체를 생성하는 부분을 따로 뗴어놓고 관리하는 것이 팩토리 패턴입니다. 정리팩토리 패턴으로 객체를 생성하고 Figure 이라는 프로토콜로 다형성을 구현할 수 있습니다. 이렇게 구성이 되면 5각형, 6각형이 추가된다고 하여도 각 객체만 Figure 인터페이스를 채택하고 팩토리 패턴으로 객체를 생성하는 소스만 수정하면 될 것입니다. 이상으로 팩토리 패턴에 대해서 알아봤습니다. 궁금하신 분은 댓글 달아주세요. 감사합니다.","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://appleceo.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://appleceo.github.io/tags/Design-Pattern/"},{"name":"Pattern","slug":"Pattern","permalink":"https://appleceo.github.io/tags/Pattern/"},{"name":"디자인 패턴","slug":"디자인-패턴","permalink":"https://appleceo.github.io/tags/디자인-패턴/"},{"name":"패턴","slug":"패턴","permalink":"https://appleceo.github.io/tags/패턴/"},{"name":"팩토리 패턴","slug":"팩토리-패턴","permalink":"https://appleceo.github.io/tags/팩토리-패턴/"}]},{"title":"Strategy Pattern","slug":"strategyPattern","date":"2019-07-02T02:06:04.000Z","updated":"2021-07-13T05:30:19.396Z","comments":true,"path":"2019/07/02/strategyPattern/","link":"","permalink":"https://appleceo.github.io/2019/07/02/strategyPattern/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 스트래티지 패턴에 대해서 알아보겠습니다. 스트래티지 패턴이란?자주 변경되는 부분을 인터페이스화하는 것입니다. 스트래티지 패턴이 필요한 이유?예를 들어 Duck 이라는 클래스가 있습니다. 러버덕과 실제 오리가 Duck 클래스를 상속받습니다. Duck 에 fly 라는 메서드를 추가하면 어떻게 될까요? 러버덕도 날 수 있습니다!! 현실은 러버덕은 날지 못합니다. fly 라는 메서드를 오버라이드해서 아무 동작하지 않도록 수정해줘야 할 것입니다. 그렇다면 프로토콜로 채택해주면 어떨까요? Duck 이라는 프로토콜이 있습니다. 러버덕 인형과 실제 오리는 모두 Duck 을 채택합니다. 이럴 때 러버덕 인형과 실제 오리 모두 각 fly 와 quack(오리 울음소리) 메서드를 구현해주어야 할 것입니다. 소스의 중복이 발생합니다. 또한 똑같은 동작을 하는 메서드들이 동일한 소스인지 확인해줘야 할 것입니다. 이럴 때 사용할 수 있는 것이 스트래티지 패턴입니다. 스트래티지 패턴 적용 방법그렇다면 스트래티지 패턴은 어떻게 적용할 수 있을까요? 아래 예제를 먼저 보시겠습니다. FlyBehavior 프로토콜과 QuackBehavior 프로토콜이 작성되었습니다. 이러한 프로토콜은 각 기능 fly 와 quack 메서드만이 선언되어 있습니다. FlyWithWings 구조체와 FlyNoWay 구조체는 FlyBehavior 프로토콜을 채택했고 fly 라는 메서드가 각자의 동작대로 작성되어있습니다. Quack 구조체와 Squeak 구조체와 MuteQuack 구조체는 QuackBehavior 프로토콜을 채택했고 quack 이라는 메서드가 각자의 동작대로 작성되어있습니다. Duck 이라는 프로토콜은 오리가 가져야할 특성들을 정의합니다. 스트래티지 패턴 적용 전의 예제소스는 날 수 있고 울을 수 있기 때문에 fly 와 quack 이라는 메서드만 있었습니다. 이제 flyBehavior 와 quackBehavior 이라는 프로토콜 변수를 프로퍼티로 가집니다. flyBehavior 에는 FlyBehavior 을 채택한 FlyWithWings 와 FlyNoWay 가 상황에 따라 들어갈 수 있을 것입니다. quackBehavior 의 경우도 마찬가지입니다. 이렇게 구현함으로써 fly 와 quack 은 원하는 대로 동작을 작성해서 넣어줄 수 있을 것입니다. 하지만 이게 끝이 아닙니다. 이렇게 동적으로 작성해놓고 flyBehavior 와 quackBehavior 을 바꿀 수 없다면 의미가 없을 것입니다. 아래 예제 소스를 보시죠. 이제 setFlyBehavior 와 setQuackBehavior 메서드를 통해 MallarDuck 객체를 다시 선언하지 않고도 fly 와 quack 동작을 바꿀 수 있게 되었습니다. 이런 식으로 자주 변동되는 부분들을 프로토콜 변수로 선언하여 변경할 수 있도록 하는 것이 스트래티지 패턴입니다. 정리오늘은 스트래티지 패턴에 대해서 알아봤습니다. 자주 변동되는 소스가 있다면 스트래티지 패턴을 통해 소스 수정을 줄일 수 있을 것입니다. 글 읽어주셔서 감사합니다.","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://appleceo.github.io/categories/Design-Pattern/"}],"tags":[{"name":"디자인 패턴","slug":"디자인-패턴","permalink":"https://appleceo.github.io/tags/디자인-패턴/"},{"name":"strategy pattern","slug":"strategy-pattern","permalink":"https://appleceo.github.io/tags/strategy-pattern/"},{"name":"design pattern","slug":"design-pattern","permalink":"https://appleceo.github.io/tags/design-pattern/"},{"name":"스트래티지 패턴","slug":"스트래티지-패턴","permalink":"https://appleceo.github.io/tags/스트래티지-패턴/"}]},{"title":"Design Pattern","slug":"Design-Pattern","date":"2019-06-28T05:51:10.000Z","updated":"2021-07-13T05:30:19.380Z","comments":true,"path":"2019/06/28/Design-Pattern/","link":"","permalink":"https://appleceo.github.io/2019/06/28/Design-Pattern/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 디자인 패턴에 대해서 알아보겠습니다. 디자인 패턴이란?“바퀴를 다시 발명하지 마라(Don’t reinvent the wheel)” 이라는 한 문장으로 표현할 수 있습니다. 여러분이 개발하고 고민하는 문제들은 이미 누군가가 경험했을 문제라는 겁니다. 선배 개발자들은 특정 맥락에서 자주 발생하는 문제들의 해결책을 정리해놓고 패턴으로 정의해놨습니다. 디자인 원칙 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분으로부터 분리시킨다. 구현이 아닌 인터페이스에 맞춰서 프로그래밍한다. 상속보다는 구성을 활용한다. 디자인 패턴을 알고 있으면 좋은 점은?만약 여러분이 팀 내에서 아래와 같은 대화를 하게 되면 어떨까요? 후배 개발자 : 이 broadcast 클래스를 만들어 봤습니다. 이 클래스는 자신에게 귀를 기울이고 있는 모든 다른 객체를 추적할 수 있고, 새로운 데이터가 들어올 때마다 각각의 리스너에게 메시지를 보내줍니다. 게다가 리스너는 언제든지 broadcast 에 참가하거나 탈퇴할 수 있습니다. 괜찮지 않나요? 동적이면서도 결합도는 낮습니다. 후배 개발자는 장황하게 설명하였지만 위에 설명한 내용은 옵저버 패턴이라고 하면 한 단어로 정리할 수 있습니다. 이런 예를 보면 알 수 있듯이 디자인 패턴을 알고 있으면 의사소통이 수월하고 정확해집니다. 문제를 겪고 있을 때 해당 상황에 맞는 패턴을 알고 있다면 문제 해결도 빨리 할 수 있겠죠 디자인 패턴의 단점은?이러한 패턴은 많이 알고 있으면 도움이 되지만 너무 몰입하면 문제가 발생할 수 있습니다. 간단한 프로그램이나 전혀 상관없는 상황에서 “이럴 때는 내가 알고 있는 패턴을 사용해야해” 라며 생뚱 맞은 패턴으로 문제를 해결하고자 한다면 시간도 오래 걸리고 다른 사람은 오히려 알아보기 힘들 수 있습니다. 이러한 것을 패턴 열병이라고 하는데 뭐든지 적당한 것이 좋은 것 같습니다. 정리이번에 옵저버 패턴에 대해서 발표할 기회가 있어서 옵저버 패턴과 디자인 패턴에 대해서 공부를 하였습니다. 처음에는 디자인 패턴에 대해서 어렵게 생각했습니다. 조금 더 공부하다보니 생각보다 간단하고 이미 사용하고 있는 패턴도 있었습니다. 디자인 패턴들을 알고 있다면 비슷한 문제가 발생했을 때 선배 개발자들이 정리해 놓은 깔끔한 방법으로 해결할 수 있을 것입니다. 글 읽어주셔서 감사합니다.","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://appleceo.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://appleceo.github.io/tags/Design-Pattern/"},{"name":"Pattern","slug":"Pattern","permalink":"https://appleceo.github.io/tags/Pattern/"},{"name":"디자인 패턴","slug":"디자인-패턴","permalink":"https://appleceo.github.io/tags/디자인-패턴/"},{"name":"패턴","slug":"패턴","permalink":"https://appleceo.github.io/tags/패턴/"}]},{"title":"Observer Pattern","slug":"ObserverPattern","date":"2019-06-26T03:08:29.000Z","updated":"2021-07-13T05:30:19.385Z","comments":true,"path":"2019/06/26/ObserverPattern/","link":"","permalink":"https://appleceo.github.io/2019/06/26/ObserverPattern/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 옵저버 패턴에 대해서 알아보겠습니다. 옵저버 패턴이란? 위에 이미지를 보시면 주제(Subject) 객체와 옵저버(Observer) 객체가 있습니다. 주제의 데이터가 달라지면 옵저버한테 그 소식이 전해집니다. 옵저버 패턴을 사용하기 전의 상황은..보통 다른 객체에 필요한 데이터가 있다면 그 데이터를 가지고 있는 객체에 직접 접근해서 가져와서 사용합니다. 해당 객체는 다른 객체에서 가져갈 프로퍼티의 이름을 공개해야하고 private 으로 선언할 수 없습니다. point 의 x 좌표와 y 좌표가 drawPoint 함수를 실행하는데 필요하기 때문에 값을 가져오기 위해 private(set) 으로 선언됬습니다. 또한 x, y 라는 프로퍼티 이름을 알고 있어야 직접 접근해서 가져갈 수 있습니다. 만약 점의 위치가 바뀌어서 x, y 프로퍼티가 달라진다면 어떻게 해야할까요? 점을 그리는 drawPoint 함수가 다시 실행되서 점의 위치를 바꿔줘야 할 것입니다. 수시로 점의 위치가 바뀔 수 있다면 어떻게 해야할까요? drawPoint 함수를 1초마다 호출해야 할까요? 이런 상황에서 필요한게 옵저버 패턴입니다. 옵저버 패턴을 사용하면..위에 보여드렸던 이미지를 다시 보여드리겠습니다. 조금 더 이해가 가시나요? subject 객체에 프로퍼티가 변경되면 옵저버 객체들에게 알려줍니다. 그렇게 되면 어떤 장점이 있을까요? subject 객체에 들어와서 상태를 가져가게 드러내 보일 필요가 없다. observer 객체가 언제 값이 바뀌는지 대기하거나 수시로 조회할 필요가 없다. 스위프트에서 옵저버 패턴의 예제 옵저버 패턴의 예제입니다. graph 객체와 dominic 객체는 옵저버 객체이고 MyPoint 를 구독합니다. MyPoint 는 좌표가 바뀔 때마다 옵저버들에게 알려줍니다. 정리이상 옵저버 패턴에 대해서 알아봤습니다. 항상 값을 바뀌는지 기다리고 체크해야되는 상황이나 내가 어떤 데이터를 가지고 있는지 공개하지 않으면서 다른 객체에게 정보를 알려줄 때는 옵저버 패턴을 사용할 수 있습니다. 글 읽어주셔서 감사합니다. 참고https://linsaeng.tistory.com/6https://kimsunzun.tistory.com/entry/Observer감시자패턴","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://appleceo.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Pattern","slug":"Pattern","permalink":"https://appleceo.github.io/tags/Pattern/"},{"name":"패턴","slug":"패턴","permalink":"https://appleceo.github.io/tags/패턴/"},{"name":"Observer Pattern","slug":"Observer-Pattern","permalink":"https://appleceo.github.io/tags/Observer-Pattern/"},{"name":"옵저버 패턴","slug":"옵저버-패턴","permalink":"https://appleceo.github.io/tags/옵저버-패턴/"}]},{"title":"readLine","slug":"readLine","date":"2019-06-25T08:33:00.000Z","updated":"2021-07-13T05:30:19.394Z","comments":true,"path":"2019/06/25/readLine/","link":"","permalink":"https://appleceo.github.io/2019/06/25/readLine/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 readLine 에 대해서 알아보겠습니다. readLine 이란?readLine 은 문자열 한 줄을 입력받는 명령어입니다. readLine 은 플레이 그라운드와 iOS 프로젝트에서는 동작하지 않습니다. commandLineTool 프로젝트에서 문자열을 입력받을 수 있습니다. readLine 사용 방법은? readLine() 을 위와 같이 작성해서 변수나 상수에 문자열을 입력 받을 수 있습니다. readLine 으로 입력받은 변수나 상수의 타입은? 위에 캡쳐에서 보실 수 있듯이 옵셔널 String 입니다. 왜 옵셔널일까요? 사용자로부터 입력을 받는 것이기 때문에 혹시 입력이 안될 수 있기 때문입니다. readLine 에 언제 nil 이 들어갈까? nil 이 입력되면 “Non inputed” 문자열이 출력되도록 소스를 작성하였습니다. 언제 nil 이 들어갈까요? 아무 문자열도 입력 안하고 엔터를 누르면 nil 이 들어갈까요? 틀렸습니다! “” 이라는 빈 문자열이 들어갑니다. Control + D 를 누르면 입력을 하지 않는다는 뜻입니다. 이런 상황일 때 nil 이 들어갑니다. 정리언어를 배울 때 기본일 정도로 중요한 문자열 입력에 대해서 알아봤습니다. swift 에서 readLine 은 playground 와 iOS 프로젝트에서 작동하지 않습니다. 애플은 readLine 을 중요하게 생각하지는 않았던 것 같습니다. 아무래도 iOS 라면 textField 에 문자열을 입력받는 등의 작업이 더 중요하겠죠. readLine 에 대해서는 그럼에도 불구하고 알고 있어야한다고 생각합니다. 문자열의 입력과 처리에 대해 익숙해질 수 있는 기회이기 때문입니다. 글 읽어주셔서 감사합니다. 참고https://www.hackingwithswift.com/example-code/system/how-do-you-read-from-the-command-line","categories":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/tags/Swift/"},{"name":"readLine","slug":"readLine","permalink":"https://appleceo.github.io/tags/readLine/"},{"name":"문자열","slug":"문자열","permalink":"https://appleceo.github.io/tags/문자열/"},{"name":"입력","slug":"입력","permalink":"https://appleceo.github.io/tags/입력/"}]},{"title":"Pair Programming","slug":"PairProgramming","date":"2019-06-21T05:56:02.000Z","updated":"2021-07-13T05:30:19.385Z","comments":true,"path":"2019/06/21/PairProgramming/","link":"","permalink":"https://appleceo.github.io/2019/06/21/PairProgramming/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 Pair Programming 에 대해서 알아보겠습니다. Pair Programming 이란? 번역하면 짝코딩입니다. 짝코딩하면 조금 더 익숙한 느낌이 듭니다. 두 사람이 한 짝이 되어 프로그래밍(코딩)을 한다는 뜻입니다. Pair Programming 로 진행하기 좋은 일은? 두렵거나 지겹거나 내가 못할 거 같은 느낌이 드는 작업 Pair Work를 통해 안정감 있게 할 수 있습니다. 하기 귀찮아서 계속 미루는 작업 둘이서 하면 재미있습니다. 즉, Pair Work를 도입하기 전에 두렵거나 지겨운 일이 무엇인지를 파악한 후 거기에 Pair Work를 도입합니다. Pair Work 진행 방법은? 같이 Pair Work를 진행할 사람을 고릅니다. 내가 편한 사람 신뢰할 수 있는 사람 종이 한 장을 꺼냅니다.(바로 일을 시작하는 것이 아닙니다!) 우리의 목표을 적습니다. 브레인 스토밍을 통해 그 목표에 맞게 여러 task로 쪼갭니다. 어떤 task를 먼저 할지, 어떤 식으로 접근할지에 대해 얘기합니다. 알람을 맞추고 5분 간격으로 ‘운전자-항해사’가 되어 진행합니다. task를 완료하면 목록에서 지우고 필요한 task를 추가하거나 다시 새로운 task를 선택하여 진행합니다. 1시간 동안 6~7번 과정을 반복합니다. (1시간에 Pair Work로 6~7개 정도의 task를 수행합니다.) Pair Programming 에서의 역할? Driver(운전사) 키보드를 잡은 사람 Navigator(항해사) 옆에서 보고 있는 사람 항해사 항해사의 입장에서 운전사가 키보드를 치는 표면적인 모습을 보면서 머릿속으로 멍하니 보고만 있지는 않습니다. 항해사는 운전자의 과정을 보면서 ‘추론’ 을 하게 됩니다. 또한 ‘가설’ 이 생깁니다. (저렇게 하려고 지금 이렇게 하는가보다.) 운전사 추론, 가설했던 것을 가지고 직접 표현해봅니다. 운전사는 혼자서 자신의 사고과정을 중얼거리면서 코딩하는 것을 권합니다. 항해사가 그런 정보를 들으면서 추론할 수 있기 때문입니다. 코딩을 하는 중에 의도(설명)를 말하라는 것이 아닙니다! 정말로 혼자 중얼거리면서 생각의 과정을 읊는 것이 좋습니다. 즉, 모두에게 능동적인 학습이 됩니다. 내가 맞는가를 확인하고 직접 맞춰볼 수 있습니다. 상대의 사고 과정을 알 수 있습니다. Pair Programming 의 효과는? 결함수가 적어진다혼자서 할 때 보다 둘이서 하면 실수가 줄어듭니다. 두명이 동시에 같이 소스를 확인하니까 당연히 실수가 줄겠죠? 통합 시간이 줄어든다! 둘이서 각자 기능을 만들어서 합치는데 예상치 못하게 시간이 많이 걸릴 수 있습니다. 최악의 상황에서는 서로 만든 것을 합치지 못하고 한 사람이 다시 만들어야 하는 상황이 발생할 수도 있습니다. Pair Programming은 만들 때부터 두 사람이 지식을 공유하면서 만들기 때문에 처음부터 통합을 고려하게 되므로 통합하는데 시간이 적게 걸립니다. 팀워크를 향상시킨다! 같이 오래 일해도 접촉이 없는 경우가 많습니다. Pair Programming을 통해 서로 간에 신뢰가 생기고 팀워크가 생깁니다. Pair Programming은 서로 피드백을 계속 주고 받기 때문에 협력의 기술이 늘어날 환경을 만듭니다. Pair Work를 통해 배우는 것 생각하는 과정을 배웁니다! 보통 전문가의 결과(코드)만 배우고 전문가의 과정(사고의 과정)을 배우진 못한다. Pair Work를 통해서는 사고방식을 배울 수 있습니다. 암묵지(tacit knowledge) 를 배울 수 있습니다. 암묵지: 학습과 경험을 통하여 습득함으로써 개인에게 체화되어 있지만 언어나 문자로 표현하기 어려운, 겉으로 드러나지 않는 지식을 의미합니다. Pair Work을 통해 전문가의 암묵지를 배움으로써 전문성의 차이를 만드는 것을 알 수 있습니다. 항해사가 운전사의 생각하는 과정을 보면서 계속해서 ‘추측’, ‘가설’을 하게 되고, 그 추측의 결과물(항해사가 추측한 내용)에 대해서 계속해서 피드백(운전자의 코딩 내용)을 받게 되므로 생각하는 과정을 배우게 되는 것입니다. 나의 전문성을 키우려면 Pair Work를 도입하는 것이 좋습니다. Pair Programming 의 주의사항은? 1. 컴퓨터가 정확히 가운데 있는 것이 왜 좋은가? “주체 - 객체”의 형식이면 도움이 안됩니다. 예를 들어, 강의 형태 예를 들어, 내가 전문 분야인 코드를 내가 주로 계속 작성하고 옆에선 보기만 하는 형태 서로 수평인 관계를 만들어야 한다. 즉, 관계를 평등하게! 둘이 공평하게 한다는 느낌으로 해야 협력이 잘 일어납니다. 앉아 있는 테이블의 위치에 따라 역학관계에 영향을 받습니다. 따라서 누가 주인인 느낌이 들지 않게 컴퓨터를 정확히 가운데에 두고 앉는 것이 중요합니다. 공동이 주인! 2. 왜 빈번하게 왔다 갔다 하는 것이 좋은가? 데일리 스크럼이란에서 잠깐 언급했던 것처럼 추상과 구상을 왔다 갔다 하는 것이 중요합니다.왔다 갔다 하는 과정 안에서 ‘발견’이 있습니다. Pair Programming을 통해서 키보드를 잡으면 문제를 구체적으로 보게 되고, 키보드를 넘기면 문제를 전체적으로 보게 됩니다.전체의 그림 확인 -&gt; 구체적으로 진행 -&gt; 다시 전체적인 그림을 확인 위의 과정을 빈번하게 반복하는 것이 바로 피드백을 반복적으로 받는 것이고, 이 전환되는 과정에서 ‘통찰’이 생깁니다. 빈번하게 왔다 갔다 하는 것이 서로에게 학습이 더 빨라집니다. 애자일은 계획을 계속해서 수정해 나가는 것입니다. 상대가 어떻게 하는지 보고 그 의도를 파악하고, 다음엔 내가 진행하면서 학습이 빨라지고, 계획을 빠르게 수정해 나갈 수 있는 것입니다. 알람 을 권합니다. 치던거 다 안쳤어도 시간이 지나면 바로 다른 사람에게 키보드를 넘기고 다른 사람이 진행합니다. 정리오늘은 Pair Programming 에 대해서 알아봤습니다. 저도 Pair Programming 을 몇번 안해봤었습니다. “함께 자라기” 책에서 업무의 레벨을 낮추는 방법으로 Pair Programming 을 추천하고 있었습니다. 또한 Pair Programming 을 통해 조금 더 잘하는 사람의 암묵지를 알 수 있습니다. 이러한 암묵지는 설명으로 이해할 수 없는 고수들의 습관을 의미하며 이런 것을 얻을 수 있는 기회는 흔치 않을 것입니다. 만약 실력이 늘고 싶거나 업무의 어려움을 겪고 있으면 나보다 조금 잘하는 분과 Pair Programming 을 한번 해보는 것은 어떨까요? 정말 좋은 자료가 있어서 참고하였습니다. 참고https://gmlwjd9405.github.io/2018/07/02/agile-pair-programming.html","categories":[{"name":"Terminology","slug":"Terminology","permalink":"https://appleceo.github.io/categories/Terminology/"}],"tags":[{"name":"Pair Programming","slug":"Pair-Programming","permalink":"https://appleceo.github.io/tags/Pair-Programming/"},{"name":"짝코딩","slug":"짝코딩","permalink":"https://appleceo.github.io/tags/짝코딩/"},{"name":"페어 프로그래밍","slug":"페어-프로그래밍","permalink":"https://appleceo.github.io/tags/페어-프로그래밍/"}]},{"title":"Substring 과 String.SubSequence 와 String 의 차이점","slug":"substring","date":"2019-06-20T08:20:21.000Z","updated":"2021-07-13T05:30:19.397Z","comments":true,"path":"2019/06/20/substring/","link":"","permalink":"https://appleceo.github.io/2019/06/20/substring/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 Substring 과 String.SubSequence 와 String 의 차이에 대해서 정리해보고자 합니다. String 에 대해서는 모두 알고 있을 것이라고 생각되서 String.SubSequence 에 대해서 먼저 알아보겠습니다. String.SubSequence 이란?String.SubSequence 는 익숙하신 분들도 많이 계실 것 같습니다. 문자열을 자르는 메소드인 split 을 사용하면 결과의 타입이 String.SubSequence 입니다. 위에 예제의 결과가 String.SubSequence 입니다. 이런 식으로 String 을 자르는 메소드들을 사용하면 타입은 자동으로 String.SubSequence 입니다. 그렇다면 String.SubSequence 이 정확히 무슨 타입일까요? 공식문서에 가보면 이렇게 나옵니다. typealias SubSequence = Substring 이라고 나오죠. 그렇다면 typealias 는 무엇일까요? typealias 란?typealis 는 편하게 이야기하면 별명이라고 할 수 있습니다. 위에 예제에서 보시면 Int 형 별명을 여러개 정해놓지만 Int 와 같이 연산이 되는 것을 알 수 있습니다. Substring 이란?그렇다면 SubSequence 는 Substring 의 별명입니다. Substring 은 어떤 타입일까요? Substring 은 아래의 특징들을 가지고 있습니다. 위에서 예로 들은 split() 이나 prefix(), split() 등 과 같은 메서드를 사용해서 문자열에서 가져온 부분문자열 타입입니다. String에서 사용하는 대부분의 메서드를 가지고 있으며 String과 같은 방법으로 사용할 수 있습니다. 원래 문자열이나 다른 하위 문자열을 저장하는데 사용되는 메모리의 일부를 다시 사용합니다. 그렇다면 Substring, SubSequence 를 사용해도 문제가 없을까요?만약 계속 사용해야 한다면 Substring, SubSequence 타입을 String 타입의 상수나 변수에 저장하는 것이 좋습니다. 왜냐하면 아래 사진을 보시면 이해하실 수 있습니다. 사진을 보시면 Hello, world! 라는 문자열이 있습니다. 또한 Hello 라는 문자열을 Substring 이 참조하고 있습니다. 이런 상황에서 Hello 라는 Substring 을 다른 함수의 매개변수로 보내거나 사용한다면 메모리에 Hello 만 저장되어 있는 것이 아니라 원래 문자열인 Hello, world! 을 계속 가지고 있어야합니다. 이런 상황이 계속 반복되면 쓸데없는 메모리를 차지하고 있을 것입니다. 정리String 과 Substring, String.Subsequence 에 대해서 알아봤습니다. 댓글 달아주시면 성심성의껏 답변 드리겠습니다. 글 읽어주셔서 감사합니다. 참고https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.htmlhttps://medium.com/@jgj455/오늘의-swift-상식-substring-string-sequence-d13fe85954b","categories":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/categories/Swift/"}],"tags":[{"name":"문자열","slug":"문자열","permalink":"https://appleceo.github.io/tags/문자열/"},{"name":"Substring","slug":"Substring","permalink":"https://appleceo.github.io/tags/Substring/"},{"name":"String","slug":"String","permalink":"https://appleceo.github.io/tags/String/"},{"name":"Subsequence","slug":"Subsequence","permalink":"https://appleceo.github.io/tags/Subsequence/"}]},{"title":"Description and CustomStringConvertible","slug":"Description","date":"2019-06-18T02:48:57.000Z","updated":"2021-07-13T05:30:19.380Z","comments":true,"path":"2019/06/18/Description/","link":"","permalink":"https://appleceo.github.io/2019/06/18/Description/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 Description 과 CustomStringConvertible 에 대해서 알아보겠습니다. Description 이란?한글로 번역하면 설명이라는 뜻입니다. 그렇다면 뭔가를 설명한다고 이해할 수 있겠습니다. Description 은 언제 필요할까? 위에 예제 소스가 실행되면 “Point(x: 21, y: 30)” 이라는 문자열이 출력됩니다. 구조체의 이름 뒤에 괄호 안에 프로퍼티들이 차례로 출력되는 구조입니다. 이렇게 정형화된 구조말고 다르게 인스턴스의 정보를 출력하고 싶을 때가 있을 것입니다. 이럴 때 사용할 수 있는 것이 Description 입니다. Description 사용 방법은? 위에 소스가 실행되면 description 에서 정의한 (x 좌표, y 좌표) 형식으로 출력이 됩니다. 위에서 우리가 변수명을 바로 print 하던 것과는 달리 변수명 뒤에 .description 을 붙여줘야합니다. 이럴 때 사용할 수 있는 것이 CustomStringConvertible 입니다. CustomStringConvertible 이란?CustomStringConvertible 은 프로토콜입니다. CustomStringConvertible 을 채택하게 되면 저희가 위에서 선언해주었던 description 을 struct 변수를 print 할 때 출력해줍니다. CustomStringConvertible 사용 방법은? CustomStringConvertible 은 구조체와 클래스 등에서 변수를 출력할 때 description 을 출력하도록 해주는 프로토콜입니다. 위에 예제에서 print(p) 를 해주면 첫번째 예제에서 출력되던 “Point(x: 21, y: 30)” 이 출력되지 않고 (21, 30) 이 출력됩니다. 이를 잘 사용하면 별도로 프로퍼티를 선언하지 않아도 인스턴스의 정보를 알 수 있을 것입니다. description 을 출력하는 방법 두가지위에 예제에서 보셨듯이 인스턴스의 상수나 변수 이름을 바로 출력해도 description 이 출력됬습니다. 이 방법과 String(describing: p) 을 출력해주어도 description 이 출력됩니다. 정리description 과 CustomStringConvertible 에 대해서 알아봤습니다. 글 읽어주셔서 감사합니다. 참고https://developer.apple.com/documentation/swift/customstringconvertible","categories":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/categories/Swift/"}],"tags":[{"name":"Description","slug":"Description","permalink":"https://appleceo.github.io/tags/Description/"},{"name":"설명","slug":"설명","permalink":"https://appleceo.github.io/tags/설명/"},{"name":"CustomStringConvertible","slug":"CustomStringConvertible","permalink":"https://appleceo.github.io/tags/CustomStringConvertible/"}]},{"title":"Generic and Custom Operators","slug":"Generic","date":"2019-06-17T06:42:38.000Z","updated":"2021-07-13T05:30:19.381Z","comments":true,"path":"2019/06/17/Generic/","link":"","permalink":"https://appleceo.github.io/2019/06/17/Generic/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 Generic 과 Custom Operators 에 대해서 알아보겠습니다. 먼저 Custom Operators 에 대해서 알아보겠습니다. Custom Operators 란?한글로 번역하면 사용자 정의 연산자입니다. 한글로 번역해도 도통 무슨 말인지 알아듣기 힘듭니다. Custom 이라는 단어는 익숙하실 겁니다. 원하는 대로 바꿀 수 있는 것을 커스텀(Custom) 이라고 합니다. 그렇다면 Operator 를 마음대로 바꿀 수 있다고 이해할 수 있습니다. Operator 란?한글로 번역하면 연산자입니다. 흔히 사용하는 더하기, 빼기, 나누기, 곱하기를 사칙연산이라고 하죠. 이러한 연산의 종류를 알려주는 것이 연산자입니다. 그렇다면 연산자에는 어떤 종류가 있을까요? infix (중위 연산자): 더하기 연산자 처럼, 두 값 사이에서 사용됩니다(예, 1 + 1). prefix (전위 연산자) : 음수 연산자 처럼, 값의 앞에 추가됩니다(예, -3). postfix (후위 연산자): 강제 언래핑(force-unwrap) 연산자처럼, 값 뒤에 추가 됩니다(예, mayBeNil!). ternary (삼항 연산자): 3개의 값 사이에 삽입된 두개의 기호입니다. Swift에서, 사용자정의 삼항 연산자는 지원되지 않고 내장된 삼항 연산자는 하나있으며, 애플 문서(Apple’s documentation)에서 읽을수 있습니다. Custom Operator 은 어디에 쓰일까?보통 직접 만든 타입에서 연산을 할 때 사용한다고 합니다. 일반적으로 쓰이는 연산자들을 Custom Operator 로 사용할 수 있다면 메소드로 만드는 것보다 가독성이 좋을 것입니다. 예를 들어 카드를 비교할 때 isHigherPointThan(cardCompared: Card) 이라고 카드 내에 다른 카드와 비교하는 메소드를 선언하는 것보다 &gt;, &lt; 와 같은 비교 연산자를 사용하는 것이 더 좋을 것 같습니다. Custom Operator 사용 방법은? ** 이란 곱하기 연산을 수행하는 Custom Operator 를 만들어봤습니다. infix operator ** : MultiplicationPrecedence Int 와 Int 사이에 중위 연산자로 예제 소스의 첫번째 줄에서 operator 앞에 infix 를 붙여줍니다. Multi 연산자의 순서와 동일하기 때문에 MultiplicationPrecedence 를 : 뒤에 붙여줍니다. 이제 3 ** 4 는 정의해준 대로 3 곱하기 4 를 실행한 12 가 됩니다. Generic 이란?위와 같이 Int 를 곱해주는 Custom Operator 가 만들어진 후에 Float 도 곱해주어야 한다면 타입 별로 Custom Operator 를 정의해주어야 할까요? 이럴 때 사용할 수 있는 것이 Generic 입니다. 곱해줄 수 있는 타입들에 대해서 모두 동일하게 Custom Operator 가 동작하길 바란다면 위와 같이 작성할 수 있습니다. &lt;T&gt; 를 함수 이름 뒤에 붙이고 매개변수 또는 리턴 타입에 T 를 작성하게 되면은 해당되는 T 는 모두 동일한 타입이어야 합니다. 이 때 where 을 사용하면 위에서 선언한 Multipleiable 프로토콜을 따르는 타입만 받을 수 있습니다. 위에 두가지는 똑같이 동작합니다. 이런 식으로 제널릭을 사용할 수 있습니다. 정리Generic 과 Custom Operators 에 대해서 알아봤습니다. 아직 사용한 적은 없지만 사용할 수 있는 기회가 온다면 놓치지 않고 사용하도록 준비해야겠습니다. 글 읽어주셔서 감사합니다. 참고https://kka7.tistory.com/73 [때로는 까칠하게..]","categories":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/categories/Swift/"}],"tags":[{"name":"Generic","slug":"Generic","permalink":"https://appleceo.github.io/tags/Generic/"},{"name":"Custom Operators","slug":"Custom-Operators","permalink":"https://appleceo.github.io/tags/Custom-Operators/"},{"name":"Operator","slug":"Operator","permalink":"https://appleceo.github.io/tags/Operator/"},{"name":"제네릭","slug":"제네릭","permalink":"https://appleceo.github.io/tags/제네릭/"},{"name":"사용자 정의 연산자","slug":"사용자-정의-연산자","permalink":"https://appleceo.github.io/tags/사용자-정의-연산자/"},{"name":"연산자","slug":"연산자","permalink":"https://appleceo.github.io/tags/연산자/"}]},{"title":"Functional Programming","slug":"FunctionalProgramming","date":"2019-06-15T13:58:09.000Z","updated":"2021-07-13T05:30:19.381Z","comments":true,"path":"2019/06/15/FunctionalProgramming/","link":"","permalink":"https://appleceo.github.io/2019/06/15/FunctionalProgramming/","excerpt":"","text":"안녕하세요. 도미닉입니다. 저번 글에 Functor 와 Monad 에 대해 정리해봤습니다. Functor 와 Monad 글에 개선해야할 점들이 보였습니다. 조금 더 이해가 필요한 것 같아서 함수형 프로그래밍에 대해서 먼저 정리를 하고자 합니다. Functional Programming 이란?해석하면 함수형 프로그래밍입니다. 기존에 객체형 프로그래밍에서","categories":[{"name":"Terminology","slug":"Terminology","permalink":"https://appleceo.github.io/categories/Terminology/"}],"tags":[{"name":"함수형 프로그래밍","slug":"함수형-프로그래밍","permalink":"https://appleceo.github.io/tags/함수형-프로그래밍/"},{"name":"Functional Programming","slug":"Functional-Programming","permalink":"https://appleceo.github.io/tags/Functional-Programming/"},{"name":"Function","slug":"Function","permalink":"https://appleceo.github.io/tags/Function/"},{"name":"함수","slug":"함수","permalink":"https://appleceo.github.io/tags/함수/"}]},{"title":"Software Test and Unit Test","slug":"unitTest","date":"2019-06-14T02:48:10.000Z","updated":"2021-07-13T05:30:19.398Z","comments":true,"path":"2019/06/14/unitTest/","link":"","permalink":"https://appleceo.github.io/2019/06/14/unitTest/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 소프트웨어 테스트와 Unit Test 에 대해서 알아보겠습니다. 소프트웨어 테스트의 목적소프트웨어 테스트는 보통 소프트웨어의 버그를 찾는 것이라고 생각하실 것 같습니다. 저 또한 그렇게 생각했지만 잘못알고 있는 것이었습니다. 소프트웨어 테스트는 제품이 효과적임을 보여주려는 것입니다. 소프트웨어 테스트가 버그를 찾고 품질을 높이는 것이라면 거기에 드는 비용은 어마어마 할 것입니다. 소프트웨어 테스트는 품질 첨가이기 보다 품질 보증입니다. 소프트웨어 테스트의 최종 목표는 소프트웨어가 원래 해야 하는 동작을 해서 비용을 지불할 만한 가치가 있는지를 고객에세 보여주는 것이 되어야 합니다. 소프트웨어 테스트의 시기소프트웨어의 문제점을 발견하는 시점이 어느 때일 때 비용이 적게 들까요? 제품을 만드는 초기 단계에서 테스트하면 문제점을 찾는데 더 적은 비용이 듭니다. 전체 과정 중 어느 한 단계인 일부분이 안정적으로 잘 동작하는지 테스트 할 수 있을 것입니다. 그렇게 하면 해당 부분을 통합한 후 최종 단계에서 모든 테스트를 하는 것보다 더 적은 문제가 발생할 것입니다. 단위 테스트 란?단위 테스트란 기능 단위 별로 테스트를 하는 것을 의미합니다. 단위 테스트는 테스트를 실행하는 데 쓰는 단계와 기대되는 결과를 명세해야 합니다. 단위 테스트의 가장 중요한 장점 중 하나는 테스트를 자동으로 수행하게 할 수 있다는 것입니다. 좋은 테스트 란?FIRST Fast - 테스팅은 빠르게 동작해야 한다. Independent / Isolated - 독립적이어야 한다. Repeatable - 동일한 인풋의 테스팅의 결과는 항상 동일해야 한다. Self-Validating - 테스트는 완벽히 자동화되어야 한다. 그 결과 자체로 성공과 실패를 알 수 있어야 한다. Timely - 이상적인 테스트 코드는 테스트할 코드를 작성하기 전 작성되어야 한다. Given, When, ThenGiven, When, Then으로 섹션을 나누어 작성하는 습관을 기르자 Given - 입력 값을 제공 When - 입력 값을 사용해 테스트의 대상이 되는 메소드를 실행 Then - 결과 값을 증명 (기대값과 비교) 정리유닛 테스트에 대해 조금 더 자세히 글을 써보고 싶었지만 첫번째 글이고 아직 많은 공부가 필요한 것 같습니다. 현재까지 이해한 내용들을 정리했습니다. 이것들을 토대로 예제와 설명을 추가해서 또 포스팅하도록 하겠습니다. 글 읽어주셔서 감사합니다. 참고테스트 주도 iOS 애플리케이션 개발 - 그레이엄 리 지음https://baked-corn.tistory.com/135","categories":[{"name":"Terminology","slug":"Terminology","permalink":"https://appleceo.github.io/categories/Terminology/"}],"tags":[{"name":"Unit Test","slug":"Unit-Test","permalink":"https://appleceo.github.io/tags/Unit-Test/"},{"name":"Test","slug":"Test","permalink":"https://appleceo.github.io/tags/Test/"},{"name":"단위 테스트","slug":"단위-테스트","permalink":"https://appleceo.github.io/tags/단위-테스트/"},{"name":"테스트","slug":"테스트","permalink":"https://appleceo.github.io/tags/테스트/"}]},{"title":"Access Control","slug":"AccessControl","date":"2019-06-12T07:40:17.000Z","updated":"2021-07-13T05:30:19.378Z","comments":true,"path":"2019/06/12/AccessControl/","link":"","permalink":"https://appleceo.github.io/2019/06/12/AccessControl/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 Access Control 에 대해서 알아보겠습니다. Access Control 이란?Access Control 을 해석하면 무슨 뜻일까요? 접근 제어 입니다. 그렇다면 접근 제어하면 무슨 생각이 드시나요? 접근 금지라는 단어도 생각이 납니다. 관계자외 출입금지라는 표지판도 많이 붙어있죠. 어느 Access Level 까지 접근을 허용할지 제어하는 것을 접근 제어라고 합니다. Access Levels 이란?해석하면 접근 단계입니다. 스위프트의 접근 단계는 5단계가 있습니다. open - 모듈 외부에서도 접근 가능 public - 모듈 외부에서도 접근 가능 internal - 하나의 모듈 내부에서만 접근 가능 fileprivate - 하나의 파일 내에서만 접근 가능 private - 정의한 블록 내부에서만 접근 가능 각 단계에 대해 자세히 살펴보겠습니다. openopen 은 public 과 동일하게 모듈 외부에서도 접근 가능합니다. 하지만 아래 두가지 특징이 있습니다. 모든 접근수준 중 open만이 모듈 밖의 다른 모듈에서 상속될 수 있습니다. (클래스) 모든 접근수준 중 open으로 선언된 클래스의 멤버(프로퍼티, 메소드)들만이 다른 모듈에서 override될 수 있습니다. publicpublic 으로 선언된 요소들 역시 모듈 바깥에서도 접근이 가능합니다. 클래스를 public으로 선언한다면 모듈 바깥에서 생성할 수 있지만 해당 클래스를 상속할 수 없습니다. public 으로 선언한 클래스의 멤버(프로퍼티, 메소드)는 모듈 밖에서 override할 수 없습니다. internalinternal은 따로 접근제어를 선언해주지 않으면 기본으로 할당되는 default 접근제어 수준입니다. internal은 같은 모듈 내에서는 어디서든 접근이 가능하고 클래스도 모듈 내의 어느 곳에서나 해당 클래스를 상속받을 수 있습니다. fileprivateprivate는 하나의 스위프트 파일(.swift) 내부에서만 접근이 가능한 접근제어 수준입니다. 접근제어를 fileprivate으로 선언하면 그 파일(.swift) 내부에서만 해당 타입에 접근이 가능합니다. privateprivate 은 그 요소가 선언된 영역(블록)내에서만 접근이 가능합니다. private(set) 은 그 요소가 선언된 영역(블록)내에서만 수정이 가능하고 외부에서 조회는 할 수 있습니다. 접근제어간의 충돌접근 제어를 사용할 때 아래 두가지 원칙을 지켜야합니다. 바깥 요소의 접근제어 수준보다 높은 수준의 내부 요소는 있을 수 없다. 특정 접근제어 수준의 타입이 함수의 매개변수나 반환되는 타입일 경우 함수는 해당 값의 접근제어보다 높을 수 없다. 먼저 첫번째의 경우 클래스의 접근수준이 private이면 클래스의 멤버들은 public, internal 등 private보다 상위 수준의 접근수준이 될 수 없고 선언이 되어도 private으로 취급됩니다. 두번째의 경우 메소드나 함수가 public한데 private한 매개변수를 받거나 private한 값을 반환하는 것은 상식적으로 맞지 않습니다. 이때 매개변수의 타입이나 반환되는 값의 접근제어 수준은 메소드나 함수의 접근제어 수준과 같거나 높아야 합니다. 정리접근 제어 단계는 private 정도만 알고 있었는데 이렇게 다양한 접근 제어 단계가 있었습니다. 용도에 맞춰서 적절하게 접근 제어를 해야하겠습니다. 감사합니다. 참고https://baked-corn.tistory.com/80","categories":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/categories/Swift/"}],"tags":[{"name":"Access Control","slug":"Access-Control","permalink":"https://appleceo.github.io/tags/Access-Control/"},{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/tags/Swift/"},{"name":"접근 제어","slug":"접근-제어","permalink":"https://appleceo.github.io/tags/접근-제어/"},{"name":"접근제어자","slug":"접근제어자","permalink":"https://appleceo.github.io/tags/접근제어자/"},{"name":"private","slug":"private","permalink":"https://appleceo.github.io/tags/private/"}]},{"title":"Automatic Reference Counting","slug":"swiftARC","date":"2019-06-11T02:39:24.000Z","updated":"2021-07-13T05:30:19.397Z","comments":true,"path":"2019/06/11/swiftARC/","link":"","permalink":"https://appleceo.github.io/2019/06/11/swiftARC/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 스위프트의 특징 중에 하나인 Automatic Reference Counting(이하 ARC) 대해서 알아보겠습니다. 해석reference 는 해석하면 참조입니다. 클래스 인스턴스를 변수, 상수, 프로퍼티 등에 저장하거나 메소드나 함수에 매개변수로 사용하면 참조를 한다라고 합니다. Counting 은 해석하면 숫자를 세다라고 할 수 있죠. Reference(참조)의 숫자를 세는 것이 Reference Counting 입니다. 그렇다면 ARC 는 어떻게 해석할 수 있을까요? Automatic 은 자동이라는 뜻이죠. Reference Counting 을 자동으로 해주는 것입니다. ARC 의 동작그렇다면 스위프트는 참조를 어떻게 카운팅할까요? ARC 는 강한 참조만을 카운팅합니다. 강한 참조라는 용어가 익숙하지 않으실텐데요. 저희가 의식하지 않고 자주 사용하고 있었습니다. 변수나 상수에 클래스 인스턴스를 초기화해서 할당하는 것이 강한 참조입니다. 그렇다면 ARC 는 어떻게 동작할까요? 위에서 예시를 드렸다시피 프로퍼티, 상수 또는 변수에 클래스 인스턴스를 할당하는 것을 강한 참조라고 합니다. 인스턴스를 함수나 메서드에 인자로 전달하면 해당 블록이 실행되는 동안 참조 카운트가 증가하고 함수나 메서드가 종료되면 참조 카운트가 감소합니다. 함수나 메서드, 클로저 등 코드 블럭 내에서 생성한 인스턴스는 당연히 해당 코드 블럭이 끝나면 참조 카운트가 감소합니다. 강한 참조가 없다면 deinit 메서드가 실행된 후 해당 인스턴스는 자동으로 메모리에서 할당 해제됩니다. 강한 참조가 남아있다면 해당 인스턴스를 할당 해제하지 못합니다. 강한 참조 순환 문제이렇게 강한 참조로만 구성하면 문제가 없을까요? 강한 참조 순환 문제가 발생할 수 있습니다. 강한 참조 순환 문제는 두 개의 클래스가 서로를 프로퍼티로 강한 참조할 때 각 두개의 인스턴스가 메모리에서 할당되지 않고 계속 남아있는 문제입니다. 강한 참조 순환 문제 해결 방법강한 참조 순환 문제를 해결하는 방법은 아래의 두가지가 있습니다. 약한 참조 미소유 참조 하나씩 자세히 설명해보도록 하겠습니다. 약한 참조약한 참조는 프로퍼티나 변수 앞에 weak 을 붙여줘서 사용할 수 있습니다. 강한 참조가 순환되서 발생하던 문제는 한 쪽을 약한 참조로 바꿔주면 해결됩니다. 약한 참조를 사용할 때 사용할 때 주의할 점 두가지! 약한 참조는 항상 변수로 선언해야 한다. 상수로 선언하면 안 된다. 약한 참조는 항상 옵셔널로 선언해야 한다. 미소유 참조미소유 참조는 프로퍼티나 변수, 상수 앞에 onowned 를 붙여줘서 사용할 수 있습니다. 강한 참조가 순환되서 발생하던 문제는 한 쪽을 미소유로 바꿔주면 해결됩니다. 미소유 참조를 사용할 때 사용할 때 주의할 점 두가지! 참조하는 인스턴스가 메모리에서 해제되더라도 자동으로 nil 을 할당해주지 않음 메모리에서 해제된 인스턴스에 접근하려 하면 잘못된 메모리 접근으로 런타임 오류가 발생해서 프로세스가 강제로 종료됨 정리ARC 는 강한 참조를 자동으로 카운트한다! 강한 참조만 사용하면 클래스 인스턴스간 강한 참조 순환이 발생할 수 있다. 아래 두가지 방법으로 클래스 인스턴스간 강한 참조 순환은 해결할 수 있다. 약한 참조 미소유 참조 자세한 내용은 아래 발표 자료를 확인 부탁드립니다. https://www.slideshare.net/joonjhokil/arc-149195450","categories":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/tags/Swift/"},{"name":"ARC","slug":"ARC","permalink":"https://appleceo.github.io/tags/ARC/"},{"name":"Automatic Reference Counting","slug":"Automatic-Reference-Counting","permalink":"https://appleceo.github.io/tags/Automatic-Reference-Counting/"}]},{"title":"모듈과 모듈화","slug":"ModuleAndModularization","date":"2019-06-09T08:27:34.000Z","updated":"2021-07-13T05:30:19.384Z","comments":true,"path":"2019/06/09/ModuleAndModularization/","link":"","permalink":"https://appleceo.github.io/2019/06/09/ModuleAndModularization/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 모듈에 대해서 알아보겠습니다. 모듈은 프로그래밍에서 자주 쓰이는 용어인데요. 저 또한 정확히 뜻을 파악하고 있지는 못하고 있었습니다. 일반적으로 모듈의 뜻과 스위프트에서 사용되는 예제 등을 찾아서 정리해보고자 합니다. 모듈이란?정보통신기술용어해설 사이트에 모듈은 아래와 같이 설명되어 있습니다. 보다 작고 이해할 수 있는 단위로 나뉘어진 것 그 자체로 하나의 완전한 기능을 수행할 수 있는 독립된 실체 본체에서 분리되어 작은 부분으로 유기적으로 구성되어 있다가 필요할 때 본체에 합류하여 그 기능을 수행할 수 있는 것 모듈은 위에 설명과 같이 한가지 일을 수행하는 코드의 모음이라고 할 수 있습니다. 모듈화란?모듈 얘기가 나오면 모듈화를 빠뜨릴 수 없습니다. 모듈화는 거대한 문제를 작은 조각의 문제로 나누어 다루기 쉽도록 하는 과정입니다. 예를 들어 큰 문제를 해결하는 긴 소스가 있다면 한가지 일을 하는 소스들(모듈)끼리 나누는 것을 모듈화라고합니다. 모듈의 특징 Unity (한가지 일만 수행) Smallness (간단명료) Simplicity (단순성) Independency (독립성) 모듈의 특징은 위 4가지와 같습니다. 모듈은 한가지 일만 수행해야 합니다. 한가지 일만 수행하기 때문에 역할이 간단하고 명료해야합니다. 또한 다른 프로그램에서도 사용할 수 있도록 모듈은 단순해야 합니다. 여러 프로그램에서 붙여서 쓸 수 있도록 독립성을 유지해야 합니다. 모듈화 장점 수정 용이 재사용성 용이 유지관리 쉬움 모듈화를 하면 수정에 용이합니다. 수행하는 일에 따라서 모듈이 나뉘어져 있기 때문에 어느 부분을 수정해야 할지 찾기 쉽기 때문입니다. 모듈은 위에서 설명했다시피 재사용하기 좋습니다. 통일성있게 표준화해놓기 때문에 다른 사람이 만든 모듈들을 유지보수하기도 좋습니다. 스위프트에서 모듈화스위프트에서 모듈은 여러 기능(함수)들을 하나로 모은 것이라고 할 수 있습니다. 예를 들어 위에 소스는 입력을 담당하는 모듈입니다. 정리모듈과 모듈화에 대해서 정리해봤습니다. 느낌만 알고 있었는데 이렇게 정리하고 보니 저 또한 많이 공부가 되고 이해에 도움이 된 것 같습니다. 모듈로 잘 정리를 해놓으면 다른 사람의 소스를 보기에도 좋기 자신 또한 이해하기 좋을 것입니다. 또한 다른 프로그램을 제작할 때 비슷한 기능 또는 같은 기능이 필요하다면 앞에서 만들어 놓은 모듈을 가져다 쓰면 될 것입니다. 글 읽어주셔서 감사합니다. 도움이 되셨다면 댓글도 부탁드립니다. 참고모듈 [정보통신기술용어해설]http://www.ktword.co.kr/abbr_view.php?m_temp1=2226","categories":[{"name":"Terminology","slug":"Terminology","permalink":"https://appleceo.github.io/categories/Terminology/"}],"tags":[{"name":"Programming","slug":"Programming","permalink":"https://appleceo.github.io/tags/Programming/"},{"name":"Module","slug":"Module","permalink":"https://appleceo.github.io/tags/Module/"},{"name":"Modularization","slug":"Modularization","permalink":"https://appleceo.github.io/tags/Modularization/"},{"name":"terminology","slug":"terminology","permalink":"https://appleceo.github.io/tags/terminology/"},{"name":"모듈","slug":"모듈","permalink":"https://appleceo.github.io/tags/모듈/"},{"name":"모듈화","slug":"모듈화","permalink":"https://appleceo.github.io/tags/모듈화/"}]},{"title":"Human Interface Guide line 에 대한 생각과 사례 조사","slug":"HumanInterfaceGuidelineThinkAndExample","date":"2019-06-09T08:06:54.000Z","updated":"2021-07-13T05:30:19.382Z","comments":true,"path":"2019/06/09/HumanInterfaceGuidelineThinkAndExample/","link":"","permalink":"https://appleceo.github.io/2019/06/09/HumanInterfaceGuidelineThinkAndExample/","excerpt":"","text":"안녕하세요. 도미닉입니다. 요근래 애플 Human Interface Guidelines(HIG) 에 해석 글을 포스팅했습니다. 이러한 HIG 에 대한 제 생각을 정리하고 앱에서 HIG 를 준수하는 사례에 대해서 조사해보겠습니다. 애플 Human Interface Guildelines 에 대한 나의 생각애플은 기기와 소프트웨어를 동시에 제공하는 독특한 기업입니다. 기기와 OS 를 포함한 기본 소프트웨어(메모장, 사파리, 키노트 등)을 제공하는 것만으로도 굉장하다고 생각했습니다. 여기에서 그치지 않고 애플은 Human Interface Guidelines 라는 것을 제공합니다. 자사의 제품에서 일관된 사용자 경험을 제공하기 위한 사용자 경험 가이드 라인입니다. 기기와 자사 소프트웨어를 제공하는 것에 부족해서 자사의 OS 에 올릴 어플까지 관리하는 애플에 놀랄 수 밖에 없었습니다. 이러한 Human Interface Guidelines(이하 HIG)를 지키지 않는다면 앱스토어에 올리지 못하는 경우도 있다고 합니다. 상용화된 앱에서 애플 HIG 의 적용 사례번역했던 글들을 참고해서 HIG 적용 사례를 찾아보겠습니다. Loading콘텐츠가 로드되는 동안 화면이 멈춰있다면 앱이 정지된 것처럼 보입니다. 금방 화면이 뜰 기미가 안보이면 사용자는 앱을 그냥 종료시킬 수 있습니다. 유튜브 앱은 어떤 로딩화면을 가지고 있을까요? 로딩 중임에도 불구하고 로딩이 완료됬을 때 콘텐츠가 뜰 부분에 회색으로 음영 표시를 해놨습니다. 이런 식으로 구성해놓음으로써 저 회색 부분에 콘텐츠들이 곧 나타날 것이라는 것을 알려주고 기대하게 해서 앱을 떠나지 않도록 합니다. 사파리 앱의 로딩 화면도 유튜브와 비슷합니다. 회색 부분에 콘텐츠들이 나타날 것이라고 기대됩니다. 배달의 민족 앱에 로딩 화면도 살펴보겠습니다. 여러 아이콘들이 바뀌면서 로딩 중이라는 것을 나타냅니다. 흥미를 끄는 음식들과 오토바이 모양을 보고 앱을 나가버리는 분들은 안계실 것 같네요. ModalityModality 는 사용자들이 작업을 완료하거나 메시지나 화면을 닫기 전까지 다른 일을 하지 못하도록 포커스를 유지하는 것을 의미합니다. 아래는 배달의 민족 앱에서 Modality 를 활용한 모습입니다. HIG 에서 Modality 의 사용은 최소화하라고 권고하고 있습니다. 그래서인지 특별한 경우를 제외하고는 사용되는 부분을 찾기 어려웠습니다. 또한 액션을 간단하고 짧게 하라고 되어있는데 명확히 통화만 가능합니다. Navigation구조와 집중을 유지할 수 있도록 네비게이션을 유지해야만 합니다. 배달의 민족 앱에 네비게이션입니다. 컨텐츠 중심 구조라고 할 수 있습니다. 어디 화면에서든 중심 컨텐츠인 음식점 정보로 이동할 수 있으며 메뉴를 선택하고 주문을 할 수 있었습니다. Onboarding처음으로 앱을 시작하는 시간은 새롭게 앱을 깔거나 오랜만에 앱을 다시 깔아서 돌아온 사용자들의 적응을 돕는 기회입니다. 해피포인트 앱은 실행 시 인터페이스와 설명을 보여줍니다. 시작화면과 유사하게 디자인 되있어서 사용법을 익히기 좋습니다. Requesting Permission앱은 현재 위치, 캘린더, 연락처 정보, 알림, 사진 등의 개인 정보에 액세스하려면 사용자로부터 권한을 부여 받아야합니다. 액세스를 허용하면 앱을 사용해 동영상을 만들 수 있습니다.액세스를 허용하면 기존에 만든 동영상을 업로드할 수 있습니다. 와 같이 개인 정보가 필요한 이유를 친절하게 설명합니다. 또한 시스템에서 제공되는 경고창을 활용합니다. 정리여러 유명한 어플들은 이미 HIG 를 제가 인식하기 전부터 지켜오고 있었습니다. 이제 우리들은 어플을 만들 때 HIG 를 완벽히 이해하고 준수하여야 할 것입니다. 잘못된 점이나 궁금한 점 댓글로 부탁드립니다. 감사합니다.","categories":[{"name":"iOS","slug":"iOS","permalink":"https://appleceo.github.io/categories/iOS/"}],"tags":[{"name":"Apple","slug":"Apple","permalink":"https://appleceo.github.io/tags/Apple/"},{"name":"iOS","slug":"iOS","permalink":"https://appleceo.github.io/tags/iOS/"},{"name":"Human Interface Guidelines","slug":"Human-Interface-Guidelines","permalink":"https://appleceo.github.io/tags/Human-Interface-Guidelines/"},{"name":"사례","slug":"사례","permalink":"https://appleceo.github.io/tags/사례/"},{"name":"생각","slug":"생각","permalink":"https://appleceo.github.io/tags/생각/"}]},{"title":"Apple Human Interface Guidelines (2)","slug":"Guidelines2","date":"2019-06-09T07:25:38.000Z","updated":"2021-07-13T05:30:19.382Z","comments":true,"path":"2019/06/09/Guidelines2/","link":"","permalink":"https://appleceo.github.io/2019/06/09/Guidelines2/","excerpt":"","text":"전편에 이어서 번역글입니다. 이번에는 iOS - User Interaction 쳅터를 번역해보겠습니다. 3D Touch3D Touch는 터치에 한단계 높은 차원을 제공합니다. 지원되는 기기에 한 해서 사용자는 다양한 세기로 터치 스크린을 눌러서 추가적인 기능을 사용할 수 있습니다. 앱은 메뉴를 표시하거나 추가 콘텐츠 를 표시하거나 애니메이션을 재생함으로써 이러한 동작에 반응 할 수 있습니다. 사용자는 3D Touch 를 사용하기 위해 새로운 제스처를 배울 필요가 없습니다. 사용자는 화면을 간단하게 누르고 반응을 보면서 3D Touch 에 익숙해질 수 있습니다. Peek and Poppeek 은 3D Touch를 사용하여 페이지, 링크 또는 파일과 같은 항목의 미리보기가 현재 화면 위에 일시적으로 표시됩니다. peek 을 사용하는 방법은 이 기능을 지원하는 항목을 약간의 압력으로 누르고 있으면 됩니다. peek 을 끝내는 방법은 간단히 약간의 압력을 가하던 손을 떼면 됩니다. 항목을 열고 더 자세하게 보려면 항목이 튀어(Pop) 화면을 채울 때까지 조금 더 세게 누르면 됩니다. 일부 Peek 화면에서 위로 스와이프하여 관련 작업 버튼을 표시 할 수 있습니다. 예를 들어 사파리의 링크를 peek 하다가 위로 스와이프하여 백그라운드에서 링크를 여는 데 필요한 버튼이 표시되며 읽기 목록에 링크를 추가하고 링크를 복사 할 수 있습니다. 아래의 규칙들을 준수하는 것이 좋습니다. peek 을 사용하여 생동감있고 의미있는 프리뷰를 제공하십시오. 손가락으로 가려지지 않도록 충분히 큰 peek 화면을 제공하십시오. 앱 내에서 Peek와 Pop을 일관되게 구현하십시오. peek 화면에서 버튼과 같은 형식의 요소를 표시하지 마십시오. 모든 peek 이 pop 을 할 수 있도록 허용하십시오. peek 을 구현했다면 오래 눌렀을 때 다른 기능이 동작하지 않도로 하십시오. 적절한 경우에는 행동할 수 있는 버튼을 제공하십시오. peek 화면을 띄우는 버튼을 제공하지 마십시오. peek 을 항목의 작업을 수행시키는 유일한 방법으로 구성하지 마십시오. Apple PencilApple Pencil은 iPad 앱에서 메모를 작성하고 스케치, 그림 그리기, 문서 마크 업 등의 작업을 할 때 픽셀 수준의 정밀도를 제공하는 다기능의 직관적인 도구입니다. 아래의 규칙들을 준수하는 것이 좋습니다. 기대되는 그리는 행동을 지원하십시오. 익숙한 손가락으로 사용하던 기능과 동일한 기능을 제공하십시오. Apple Pecil 이 화면에 닿는 순간 바로 그려져야 합니다. 기울기, 힘, 방향에 따라 달라지도록 구현하십시오. 컨텐츠와 직접 연결되며 시각적 반응을 보이십시오. 왼손잡이와 오른손잡이 차이없이 작업할 수 있도록 적절하게 컨트롤을 배치 하십시오. 가능한 double-tap 제스처에 대한 사용자 설정을 존중하십시오. 필요한 경우 사용자가 정의한 double-tap 동작을 활용하도록 방법을 제공하십시오. double-tap 제스처로 내용을 수정하는 기능을 구현하지 마십시오. Audio사용자는 볼륨 버튼, 무음 스위치, 헤드폰 컨트롤 및 화면상의 볼륨 슬라이더를 통해 사운드를 조작합니다. 또한 많은 타사 액세서리에도 사운드 컨트롤이 제공됩니다. 오디오는 내부 또는 외부 스피커, 헤드폰 및 AirPlay 지원 또는 Bluetooth 장치를 통해 무선으로 출력 할 수 있습니다. 사운드가 앱의 경험이나 꾸밈의 기본 요소인지 여부에 상관없이 사운드는 제대로 동작하고 기대를 충족시키도록 구성해야합니다. 아래의 규칙들을 준수하는 것이 좋습니다. 자동으로 볼륨을 조정할 수 있지만 전체 볼륨은 조정하지 마십시오. 적절한 경우 오디오 출력 기기의 변경을 허용하십시오. 시스템에서 제공되는 볼륨 화면에서 오디오 조정을 허용하십시오. 짧은 소리와 진동은 시스템의 사운드 서비스를 사용하십시오. 사운드가 앱에 필수로 필요하면 다른 오디오를 종료시키십시오. 중단이 발생한 후더라도 적절한 경우 오디오 재생을 다시 시작하십시오. 동작중인 앱의 임시적인 오디오 재생이 끝날 때 다른 앱에 그 사실을 알리십시오. 오디오 컨트롤에 대한 응답이 의미있는 경우에만 응답하십시오. 오디오 컨트롤의 용도를 변경하지 마십시오. Authentication아래의 경우 등에 가치가 있는 경우에만 인증을 사용자에게 요청하십시오. 경험을 개인화할 때 추가 기능에 액세스할 때 콘텐츠를 구매할 때 데이터를 동기화할 때 앱에 인증이 필요한 경우 로그인 과정을 빠르고 쉽고 눈에 거슬리지 않게 유지하여 앱을 즐겁게 사용하는데 지장을 주지 않도록하십시오. 아래의 규칙들을 준수하는 것이 좋습니다. 모든 가입 및 로그인 과정에서 비밀번호 자동 채우기를 사용하십시오. 로그인을 가능한한 미루십시오. 인증의 이점과 서비스 가입 방법을 친절하게 설명하십시오. 적절한 키보드를 표시하여 데이터 입력을 간편하게 하십시오. 암호라는 용어를 절대 사용하지 마십시오. Face ID 와 Touch ID 관련 아래의 규칙들을 준수하는 것이 좋습니다. 가능할 때마다 생체 인증을 지원하십시오. 직관적이도록 인증을 위한 한가지 방법만 소개하십시오. 사용자가 원해서 요청했을 때만 인증을 시작하십시오. 항상 인증 방법을 식별하십시오. 인증 방법을 정확하게 참조하십시오. 앱에서 생체 인증을 사용하도록 설정 할 수 있도록 하지마십시오. 아이콘을 사용하여 시스템 인증 기능을 식별하지 마십시오. Data Entry인터페이스 요소를 누르거나 키보드를 사용하여 정보를 입력하는 것은 지루한 과정일 수 있습니다. 앱이 유용한 동작을 하기도 전에 많은 정보를 요구하면 사람들은 쉽게 실망 할 수 있으며 앱의 사용 자체를포기할 수도 있습니다. 아래의 규칙들을 준수하는 것이 좋습니다. 가능한 선택 사항을 제시하십시오. 사용자에게 요구하기보다 시스템에서 정보를 얻으십시오. 알맞은 기본값을 제공하십시오. 필요한 값을 수집한 후에만 ​​진행 버튼을 활성화하십시오. 실시간으로 입력 폼의 유효성을 확인하십시오. 필요한 경우에만 입력 값을 요구하십시오. 어디까지 입력했는지 알기 쉽도록 입력 값의 리스트를 보여주십시오. 텍스트 필드에 힌트를 제공하여 입력을 쉽게 하십시오. Drag and Drop한 손가락으로 현재 위치에서 다른 위치로 콘텐츠를 끌어다 놓음으로써 선택한 사진, 텍스트 또는 기타 내용을 이동하거나 복사할 수 있습니다. Sources and Destinations끌어다 놓기(drag and drop)는 선택한 내용을 현재 위치에서 대상 위치로 이동하는 작업입니다. 현재 위치와 대상 위치는 같은 컨테이너이거나 나뉘어진 다른 컨테이너일 수 있습니다. 예를 들어 Notes 에서 선택한 텍스트를 동일한 노트의 새로운 위치로 드래그 할 수 있습니다. 미리 알림에서 사용자는 하나의 목록에서 개별 미리 알림을 다른 목록으로 드래그할 수 있습니다. Supporting Drag and Drop끌어다 놓기(drag and drop)은 사용자가 시스템 전반에 걸쳐 구현되기를 기대하는 효율적이고 직관적인 기능입니다. 앱에 텍스트, 사진, 비디오 오디오 또는 사용자가 이동, 복사 또는 삽입하려는 기타 콘텐츠가 있는 경우 drag and drop 을 지원해야합니다. 아래의 규칙들을 준수하는 것이 좋습니다. 선택 가능하고 편집 가능한 모든 컨텐츠에 대해 drag and drop 을 지원하십시오. 필요한 경우 컨트롤에서 콘텐츠를 drop 할 수 있도록 허용하십시오. 가능한 표준 텍스트 view 와 텍스트 필드를 사용하십시오. 효율성을 높이려면 여러 항목을 동시에 drag and drop 할 수 있도록 지원하십시오. 앱 내에서 콘텐츠를 drag and drop 하면 이동될지 복사될지 결정하십시오. 가능하다면 drag and drop 을 취소할 수 있도록 구성하십시오. Providing Dragged Content아래의 규칙들을 준수하는 것이 좋습니다. 필요한 경우 항목 드래그하는 프리뷰를 제공하십시오. 가능한 끌어서 놓은 데이터의 품질을 여러 단계로 제공하십시오. 가능한 기본 버전을 가장 유용한 데이터 형식으로 제공하십시오. 앱의 콘텐츠 전송이 오래 걸리거나 리소스가 많이 필요할 경우 파일 제공 extension 을 구현하십시오. 앱의 콘텐츠를 전송할 때 시간이 걸리는 경우 진행 상태를 표시하십시오. Accepting Dropped Content아래의 규칙들을 준수하는 것이 좋습니다. 시각적으로 드래그해서 놓았을 때의 내용을 미리 보여주십시오. 적절한 경우 대상의 내용을 자동으로 스크롤합니다. 드롭되었을 때 가장 대표적인 콘텐츠를 추출하고 표시하십시오. 드롭된 콘텐츠와 밀접한 부분만 추출하십시오. 내용을 드롭 한 후에 table view 및 collection view 에 위치를 표시하십시오. 드롭된 콘텐츠를 전송할 시간이 필요한 경우 진행 상황을 표시하십시오. 드롭된 콘텐츠가 작업을 시작하면 피드백을 제공하십시오. 드롭이 실패할 경우 사용자에게 알리십시오. 드롭 된 텍스트에 적절한 스타일을 적용하십시오. 사용자가 드래그 앤 드롭을 즉시 취소 할 수없는 경우 직관적인 방법으로 선택 해제하십시오. Feedback피드백은 사용자가 앱이 하는 일을 알게 하고 다음에 할 수 있는 것을 발견하고 행동 결과를 이해하도록 도와줍니다. 아래의 규칙들을 준수하는 것이 좋습니다. 인터페이스에 다른 유형의 피드백과 상태가 눈에 띄지 않도록 통합하십시오. 불필요한 경고는 피하십시오. 햅틱 피드백(Haptic Feedback)지원되는 장치에서 햅틱은 주의를 끌도록 촉각적인 피드백을 제공합니다. 이러한 피드백을 통해 사용자가 물리적으로 중요한 알림을 알 수 있습니다. 아래의 규칙들을 준수하는 것이 좋습니다. 과도한 햅틱은 사용자에게 혼란을 주거나 피드백을 무시하도록 합니다. 일반적으로 사용자가 시작한 행동에 대한 반응으로 햅틱을 제공하십시오. 피드백 유형을 재정의하지 마십시오. 피드백을 마음대로 변경하지 마십시오. 햅틱을 사용함에 따라 시각적 경험을 미세 조정하십시오. 설정으로 햅틱 피드백을 꺼놨을 수 있으니 햅틱 만으로 알림을 하지마십시오. 시각적인 피드백이 가려질 경우 햅틱을 사용하십시오. 햅틱 피드백을 시작하기 전에 시스템을 준비하십시오. 햅틱과 소리는 자동으로 동기화되지 않으므로 동시에 나오려면 동기화 하십시오. File Handling사용자는 파일을 만들고 보고 조작하는 동안 파일 시스템에 관해 알 필요가 없습니다. 앱이 파일과 동작하는 경우에도 가능한 파일 관련 처리를 줄입니다. 아래의 규칙들을 준수하는 것이 좋습니다. 작업을 취소하거나 삭제하지 않는 한 항상 보존된다는 확신을 심어주십시오. 로컬에만 파일을 작성하는 옵션을 제공하지 마십시오. 직관적이고 그래픽적인 파일 탐색 인터페이스를 구현하십시오. 이제 사용자가가 앱을 떠나지 않고도 파일을 미리볼 수 있습니다. 필요한 경우 다른 앱과 파일을 공유하십시오. Gestures사용자는 터치 스크린에서 제스처를 수행하며 iOS 기기와 상호 작용합니다. 아래의 규칙들을 준수하는 것이 좋습니다. 일반적인 표준 제스처를 사용하십시오. 표준이 아닌 동작을 수행하기 위해 표준 제스처를 사용하지 마십시오. 시스템 전체에서 화면 가장자리의 제스처를 피하십시오. 인터페이스 기반 탐색 및 동작을 보충할 수 있도록 단축 제스처를 제공하십시오. 여러 손가락 제스처를 사용하여 일부 앱의 경험을 향상시키십시오. Standard Gestures사용자는 일반적으로 시스템과 모든 앱에서 다음 표준 제스처가 동일하게 동작할 것으로 기대합니다. Tap : 컨트롤을 활성화하거나 항목을 선택합니다. Drag : 요소를 좌우로 이동하거나 화면으로 끌어갑니다. Flick : 빨리 스크롤하거나 넘깁니다. Swipe : 한 손가락으로 수행하면 이전 화면으로 돌아가거나 분할 view 에서 숨겨진 view 를 표시하거나 table view 에서 삭제 단추를 표시합니다. iPad 에서 네 손가락으로 수행하면 다른 앱 화면으로 전환합니다. Double tap : 콘텐츠 또는 이미지를 확대하고 가운데에 배치하거나 이미 확대된 경우 축소합니다. Pinch : 확대된 경우 바깥 쪽으로 잡아 밀면 축소되고 안쪽으로 잡아 당기면 확대합니다. Touch and hold : 편집 가능한 텍스트 또는 선택 가능한 텍스트에서 수행될 때 커서 위치 지정을 위한확대보기를 표시합니다. collection view와 같은 certain view 들에서 수행될 때 항목을 재배치 할 수있는 모드로 들어갑니다. Shake : 실행 취소 또는 다시 실행을 시작합니다. Rotate : 이미지 또는 view 를 회전합니다. Near Field CommunicationNear Field Communication (이하 NFC)는 서로 몇 센티미터 안에 장치가 무선으로 정보를 교환할 수 있게 돕습니다. NFC 가 지원되는 기기에서 실행되는 iOS 앱은 NFC 검색으로 실제 존재하는 물건에 붙어있는 전자 태그의 데이터로부터 데이터를 읽을 수 있습니다. 예를 들어 사용자는 장난감을 스캔하여 비디오 게임에 연결하거나 구매자는 상점 로그인을 스캔하여 쿠폰에 접근하거나 소매점 직원이 제품을 스캔하여 재고를 파악할 수 있습니다. In-App Tag Reading앱을 사용하면 앱이 물건들을 스캔할 수 있고 사용자가 무언가를 스캔해야 할 때마다 스캔 시트를 표시할 수 있습니다. 아래의 규칙들을 준수하는 것이 좋습니다. 사용자가 물리적으로 물건과 접촉하도록 하지마십시오. 친숙한 용어를 사용하십시오. 스캔 시트에 대한 간략한 가이드를 제공하십시오. Background Tag Reading백그라운드 태그 읽기를 사용하면 앱을 열고 나서 검색을 시작하지 않아도 언제든지 태그를 빠르게 검색할 수 있습니다. 백그라운드 태그 읽기를 지원하는 장치는 장치의 화면이 켜질 때마다 시스템은 자동으로 근처의 태그를 찾습니다. 태그를 감지하고 앱과 매칭시킨 후 시스템은 사용자가 처리할 수 ​​있도록 태그 데이터를 앱에 보내기 위해 탭 할 수 있다는 알림을 표시합니다. NFC 스캔 시트가 보이거나 Wallet 또는 Apple Pay를 사용 중이거나, 카메라가 사용 중이고, 장치가 비행기 모드에 있고 재시작 후 장치가 잠겨 있으면 백그라운드 읽기가 비활성화됩니다. 백그라운드와 앱 내에서 태그 읽기를 둘 다 지원하십시오. Undo and Redo많은 앱에서 사용자는 기기를 흔들어 타이핑이나 삭제와 같은 작업들을 실행취소 하거나 다시 실행할 수 있습니다. 이 방법이 수행되면 사용자에게 실행 취소 또는 다시 실행 작업을 확인하거나 취소할꺼냐는 경고 메시지가 표시됩니다. 취소하거나 다시 수행 할 작업을 간단하고 정확하게 설명하십시오. 실행 취소 및 다시 실행을 위해 흔들기 동작을 사용하는 경우 다른 동작에서는 사용하지 마십시오. 흔들면 되기 때문에 실행 취소 및 다시 실행 버튼은 최대한 제공하지 마십시오. 현재 흐름에 대해서만 실행 취소 및 다시 실행 작업을 수행하십시오. 정리오늘은 User Interaction 에 대해서 해석해봤습니다. 사용자와 상호작용하고 좋은 경험을 제공하는 것은 앱에서 가장 중요한 부분 중 하나일 것입니다. 도움이 되셨다면 댓글 부탁드립니다. 긴 글 읽어주셔서 감사합니다.","categories":[{"name":"iOS","slug":"iOS","permalink":"https://appleceo.github.io/categories/iOS/"}],"tags":[{"name":"Apple","slug":"Apple","permalink":"https://appleceo.github.io/tags/Apple/"},{"name":"iOS","slug":"iOS","permalink":"https://appleceo.github.io/tags/iOS/"},{"name":"Human Interface Guidelines","slug":"Human-Interface-Guidelines","permalink":"https://appleceo.github.io/tags/Human-Interface-Guidelines/"}]},{"title":"Apple Human Interface Guidelines (1)","slug":"Guidelines1","date":"2019-06-09T06:11:23.000Z","updated":"2021-07-13T05:30:19.381Z","comments":true,"path":"2019/06/09/Guidelines1/","link":"","permalink":"https://appleceo.github.io/2019/06/09/Guidelines1/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 Human Interface Guidelines 에 대해서 알아보도록 하겠습니다. Human Interface Guidelines 란?https://developer.apple.com/design/human-interface-guidelines/ 에 접속하면 아래와 같은 문구가 보입니다. “Apple 플랫폼과 완벽하게 통합되는 훌륭한 응용 프로그램을 디자인 할 수 있는 심층적인 정보와 UI 리소스를 얻으십시오.” 라고 해석됩니다. 애플에서는 일관된 사용자 경험을 제공하기 위해 애플의 제품에서 구동될 어플을 제작할 때 지켜야할 가이드라인을 제공합니다. 각 제품군마다 가이드라인을 제공하고 있으며 이러한 자료는 여러번 읽어서 습득하고 있어야 할 것입니다. 한 번에 포스팅하기에는 분량이 많기 때문에 오늘은 iOS 의 개요와 App Architecture 부분을 해석해보도록 하겠습니다. iOS - 주제3가지 주제는 iOS 를 다른 플랫폼들과 다르게 차별화합니다. 명확함 존중 깊이 명확함시스템 전체에서 아래와 같은 규칙을 지켜야합니다. 글자는 어떠한 크기로 설정하든 알아보기 쉬워야합니다. 아이콘들은 의미가 정확히 전달되어야합니다. 무례하거나 적절하지않은 꾸미기는 지양해야 합니다. 예리한 기능에 대한 이해는 디자인에 도움을 줍니다. 부정적인 공백, 색상, 폰트, 그래픽, 인터페이스 요소는 미묘하게 중요한 부분을 강조할 수 있습니다. 존중활발한 움직임과 이해하기 쉽고 아름다운 인터페이스는 사람들이 긴장하지 않고 내용을 이해하고 상호 작용하도록 돕습니다. 일반적으로 콘텐츠들은 전체 화면을 채우지만 반투명과 흐린 부분은 종종 많은 것을 암시합니다. 베젤, 기울어짐과 그림자의 사용을 최소화하여 인터페이스를 우아하게 유지하고 콘텐츠를 최우선으로 보이게 합니다. 깊이뚜렷하게 보이는 깊이감과 현실적인 움직임은 활력을 부여하며 깊이에 대한 이해를 돕습니다. 터치할 수 있고 탐험하는 듯한 깊이감은 재미있고 전체 흐름을 잃지않으면서 추가 콘텐츠에 접근할 수 있도록 돕습니다. 뚜렷한 시각적 계층과 현실적인 동작은 계층을 전달하고 활력을 부여하며 이해를 돕습니다. iOS - 디자인 원칙강렬한 인상을 남기려면 아래 원칙을 주의해야합니다. 미적 무결성앱의 생김새와 행동이 그 기능과 얼마나 잘 통합되는지를 의미합니다. 예를 들어, 사람들이 중요하고 민감한 일을 할 수 있도록 도와주는 앱은 섬세하고 심플한 그래픽, 표준적인 제어장치, 예측 가능한 행동을 함으로써 사용자를 집중시킬 수 있습니다. 게임과 같은 사용자를 몰입시켜야 하는 앱은 획일화 된 디자인보다 재미와 흥분을 제공하는 화려한 디자인을 사용할 수 있습니다. 일관성일관된 디자인은 시스템에서 제공하는 인터페이스 요소, 익숙한 아이콘, 표준 글자 폰트 및 균일한 용어를 사용하여 익숙한 표준과 패러다임을 구현합니다. 직접 조작화면 내용의 직접적인 조작은 사용자가 집중하게 하고 이해를 용이하게 합니다. 사용자는 기기를 회전하거나 제스처를 통해 화면 내용에 영향을 줄 때 직접 조작하고 있다고 생각합니다. 직접적인 조작을 통해 사용자는 행동에 대한 즉각적이고 가시적인 결과를 볼 수 있습니다. 피드백피드백은 사용자의 행동에 따른 결과를 보여주어 사용자에게 정보를 제공합니다. 내장된 iOS 앱들은 모든 사용자 행동에 대한 반응으로 피드백을 확인할 수 있도록 돕습니다. 동영상이나 음악처럼 진행 상황을 표시함으로써 상호작용 가능한 피드백을 제공합니다. 메타포책과 잡지를 넘기는 것처럼 사용자들은 드래그하는 것과 스와이프하는 것에 익숙합니다 이러한 메타포는 사용자들이 쉽게 학습할 수 있습니다. 사용자들은 메타포들에 금방 익숙해지며 사용하기 좋아합니다. 사용자 제어앱은 사용 방법을 제안하거나 위험한 결과에 대해 경고 할 수 있습니다. 일반적으로 앱이 중요한 결정을 하는 것은 문제입니다. 가장 좋은 앱은 사용자가 원하는 대로 제어하는 것과 꼭 피해야하는 결과 사이에 정확한 균형을 찾습니다. 사용자가 원하는 대로 모든 것을 할 수 있다면 큰 문제가 발생할 수도 있을 것입니다. 문제를 피하기 위해 사용자의 자유도가 너무 적다면 그것 또한 좋은 앱은 아닐 것입니다. 대화하는 듯한 친숙하고 친절한 디자인은 이해하기 쉽도록 돕습니다. 또한 삭제하는 등의 파괴적인 행동을 확인할 수 있으며 이미 진행 중인 경우에 작업을 취소할 수 있습니다. 이러한 점들은 사용자가 앱이 자신의 통제 안에 있다는 것을 느낄 수 있도록 합니다. iOS - 인터페이스 필수 요소대부분의 iOS 앱은 공통 인터페이스 요소를 정의하는 프레임 워크인 UIKit 을 사용하여 개발됩니다. 이 프레임 워크를 통해 시스템 전반에서 일관된 디자인과 높은 수준의 커스텀 마이징을 제공합니다. UIKit 은 유연하고 친절합니다. iOS 기기에서 앱을 훌륭한 디자인을 사용할 수 있으며 시스템에서 모양이 변경되면 자동으로 업데이트 됩니다. UIKit 에서 제공하는 인터페이스 요소는 크게 세가지 범주로 나뉩니다. Bars사용자가 앱의 어느 위치에 있는지 표시하고 탐색 기능을 제공합니다. 버튼을 포함할 수 있습니다. 작업을 시작하고 정보를 전달하는 기타 요소가 포함될 수 있습니다. View사용자가 볼 수 있는 텍스트, 그래픽, 에니메이션, 상호 작용하는 요소들을 포함하는 중요한 내용들을 포함됩니다. Controls행동을 시작하고 정보를 전달하는 버튼, 스위치, 텍스트 필드와 진행 표시기는 Contorl의 예입니다. iOS 의 인터페이스를 정의하는 것 외에도 UIKit 은 앱의 기능도 적용할 수 있습니다. 예를 들어 iOS는 Apple Pay, HealthKit 및 ResearchKit 과 같은 다른 프레임 워크 및 기술과도 긴밀하게통합되어 강력한 응용 어플을 설계할 수 있습니다. iOS - 앱 구조Loading콘텐츠가 로드될 때 빈 화면 또는 멈춰있는 화면은 앱이 정지된 것처럼 보이게 하여 혼란을 야기할 수 있습니다. 또한 금방 화면이 뜰지 않을 거라는 좌절감을 느껴 사용자들이 앱을 종료할 수 있습니다. 이러한 문제를 해결하기 위해 아래의 규칙들을 준수하면 좋습니다. 로딩 중이면 이를 분명히 보여주십시오. 가능한 빨리 콘텐츠를 표시하십시오. 로딩 시간을 기다리는 사용자들에게 앱 사용의 힌트를 제공한다던지 흥미를 끄는 볼거리를 제공하십시오. 시계가 돌아가는 등의 일반적인 로딩 화면도 좋지만 앱과 게임에 어울리는 로딩 화면을 제공함으로써 사용자가 몰입할 수 있도록 도우십시오. ModalityModality 는 사용자들이 작업을 완료하거나 메시지나 화면을 닫기 전까지 다른 일을 하지 못하도록 포커스를 유지하는 것을 의미합니다. 시트, 경고, 활성화된 View 등 Modality 를 준수하는 화면을 modal view 라고 합니다. modal view 가 화면에 나타나면 사용자는 버튼을 두드리는 등의 방법으로 종료할 수 있습니다. 일부 앱은 캘린더에서 일정을 수정하거나 Safari 에서 북마크를 선택하는 등의 modal view 를 제공합니다. modal view 는 전체 화면, popover 와 같은 전체 상위 화면, 또는 화면의 일부를 차지할 수 있습니다. modal view 는 일반적으로 완료 버튼과 화면을 나갈 수 있는 취소 버튼을 가지고 있어야합니다. 아래의 규칙들을 준수하는 것이 좋습니다. Modality 의 사용을 최소화하십시오. modal 작업을 종료할 수 있는 확실하고 안전한 방법을 제공하십시오. modal 작업을 간단하고 짧게 유지하십시오. 필요한 경우 작업을 식별할 수 있는 title 을 표시하십시오. 필수로 제공해야할 정보를 표시하기 위해 경고창을 활용하십시오. 알림 환경 설정을 준수하십시오. popover 위에 modal view 를 띄우지마십시오. 앱에 적절하도록 modal view 의 모양을 조절하십시오. 앱 내에서 이해하기 쉬운 modal view 의 스타일을 유지하십시오. Navigation사용자들은 기대와 달리 움직이기 전까지 앱의 네비게이션(탐색)을 인식하지 못하는 경향이 있습니다. 구조와 집중을 유지할 수 있도록 네비게이션을 유지해야만 합니다. 네비게이션은 자연스러워야 합니다. 네비게이션은 화면을 과도하게 차지하거나 콘텐츠로의 집중을 방해하면 안됩니다. 아래는 네비게이션의 몇가지 예입니다. 계층적 구조 평면적 구조 콘텐츠 중심 또는 사용자 경험 중심 구조 일부 앱은 여러 네비게이션 스타일을 결합합니다. 예를 들어 평면적 구조를 사용하는 앱인데 각 카테고리 내에서는 계층적 구조로 구현할 수 있습니다. 아래의 규칙들을 준수하는 것이 좋습니다. 항상 명확한 탐색 방법을 제공하십시오. 콘텐츠를 빠르고 쉽게 얻을 수 있도록 정보의 구조를 설계하십시오. 사용자가 터치 제스처를 통해 유동적으로 이동할 수 있도록 구현하십시오. 표준적인 탐색 요소들을 사용하십시오. navigation bar 를 사용해 데이터 계층을 탐색할 수 있도록 하십시오. tab bar 를 사용해 각 카테고리의 콘텐츠와 기능을 표시하십시오. 동일한 콘텐츠가 여러 페이지에 있을 경우 page control 을 사용하십시오. Onboarding처음으로 앱을 시작하는 시간은 새롭게 앱을 깔거나 오랜만에 앱을 다시 깔아서 돌아온 사용자들의 적응을 돕는 기회입니다. Onboarding 은 빠르고 재미있고 유익하게 디자인할 수 있습니다. 아래의 규칙들을 준수하는 것이 좋습니다. 시작화면과 유사하게 디자인하십시오. 적절한 오리엔테이션을 표시하십시오. 동작을 신속하게 수행하십시오. 사용자에게 도움이 필요하다고 예상하십시오. 필수적인 사용 방법에 충실하십시오. 재미있게 학습하고 탐험하는 기분을 들게 하십시오. 설정 정보를 미리 요구하지 마십시오. 앱의 라이선스 정보 및 규정 등을 표시하지 마십시오. 앱을 재시작 했을 때 다시 전단계로 되돌리지 마십시오. 사용자에게 앱의 평가를 너무 빠르거나 너무 자주 요청하지 마십시오. 앱의 재부팅을 권장하지 마십시오. Requesting Permission앱은 현재 위치, 캘린더, 연락처 정보, 알림, 사진 등의 개인 정보에 액세스하려면 사용자로부터 권한을 부여 받아야합니다. 사용자들은 이러한 정보에 앱이 접근하여 얻을 수 있는 편리함을 좋아합니다. 하지만 사용자는 개인 정보를 제어할 수 있어야합니다. 예를 들어 사용자들은 사진을 찍은 위치가 자동으로 태그되거나 근처에 있는 친구를 찾을 수 있는 것을 좋아합니다. 하지만 이러한 기능이 필요하지 않다면 사용하지 않도록 설정할 수 있어야 합니다. 아래의 규칙들을 준수하는 것이 좋습니다. 명확하게 필요할 때만 개인 정보를 요청하십시오. 개인 정보가 필요한 이유를 설명하십시오. 앱이 실행 중일 때만 필요한 개인 정보인 경우 앱 실행 중에만 사용하도록 요청하십시오. 불필요하게 위치 정보를 요청하지 마십시오. 시스템에서 제공되는 경고창을 활용하십시오. Settings일부 앱은 설정이나 환경을 선택할 수 있는 방법을 제공해야하지만 대부분의 앱은 이를 피하거나 지연시킬 수 있습니다. 성공한 앱의 대부분은 사용자들이 올바르게 동작하고 있다고 느낍니다. 또한 편리하게 적응할 수 있는 방법들을 제공합니다. 대부분의 사람들이 기대하는 대로 앱이 동작된다면 설정의 필요성은 줄어들 것입니다. 아래의 규칙들을 준수하는 것이 좋습니다. 시스템으로부터 얻을 수 있는 것들은 우선 얻으십시오. 위치 정보에서 얻을 수 있다면 굳이 우편번호를 요구할 필요는 없을 것입니다. 설정의 우선순위를 부여하십시오. 자주 변경해야하는 것은 앱의 메인 화면에서 설정할 수 있도록 해야 합니다. 아이폰 설정에서 변경 가능한 설정은 표시를 지양하십시오. 아이폰 설정에 대한 바로가기를 제공하십시오. 정리분량이 많아서 App Arcitecture 부분에서 끊었습니다. 앞으로 한 챕터씩 잘라서 포스팅하도록 하겠습니다. 애플은 다른 회사들과 달리 Human Interface Guide 를 제공합니다. 이 문서는 어플을 개발하는 사람들이 공통적이고 일관성있게 디자인 할 수 있도록 돕습니다. 이러한 점은 사용자들이 좀 더 편하게 다양한 어플들의 사용 방법을 이해할 수 있는데 도움을 줄 것입니다. 애플의 앱스토어에 어플을 올리고자 한다면 이 문서를 숙지할 뿐만 아니라 시스템 전반에 반영해야 할 것입니다. 내일은 User Interaction 에 대해서 해석해서 올리도록 하겠습니다. 도움이 되셨다면 댓글 부탁드립니다. 긴 글 읽어주셔서 감사합니다.","categories":[{"name":"iOS","slug":"iOS","permalink":"https://appleceo.github.io/categories/iOS/"}],"tags":[{"name":"Apple","slug":"Apple","permalink":"https://appleceo.github.io/tags/Apple/"},{"name":"iOS","slug":"iOS","permalink":"https://appleceo.github.io/tags/iOS/"},{"name":"Human Interface Guidelines","slug":"Human-Interface-Guidelines","permalink":"https://appleceo.github.io/tags/Human-Interface-Guidelines/"}]},{"title":"정규표현식 공부 방법","slug":"regex","date":"2019-06-09T05:49:33.000Z","updated":"2021-07-13T05:30:19.394Z","comments":true,"path":"2019/06/09/regex/","link":"","permalink":"https://appleceo.github.io/2019/06/09/regex/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 정규표현식의 공부 방법에 대해서 작성해보겠습니다. 정규표현식에 대해서 아무것도 모르는 상태에서 제가 공부한 방법을 공유하고자 합니다. 정규표현식의 기본부터 공부할 수 있는 사이트에서 개념 익히기“점프 투 파이썬” 이라는 웹페이지를 아시는 분이 계실 것 같습니다. 점프 투 파이썬 은 파이썬을 처음 공부할 때 많은 분들이 추천하고 사용하는 웹페이지입니다. 파이썬에 대해서 쉽게 설명되어있어서 저도 도움을 많이 받았던 사이트입니다. 이 점프 투 파이썬 웹페이지에 정규표현식 쳅터가 있습니다. 아래의 페이지입니다.https://wikidocs.net/4308 정규표현식이 이해하기 쉽게 설명되어있습니다. 스텝을 따라하며 정규표현식에 익숙해지기위에서 기본을 익혔다면 이제 실전입니다. https://expressionsregexone.com영어로 된 문장들이 부담스럽기는 하지만 번역기를 돌려가며 설명을 이해할 수 있었습니다. 설명 아래의 예제 문제를 풀면서 실제로 정규표현식이 어떻게 동작하는지 스텝 바이 스텝으로 이해하고 공부할수 있습니다. 배운 정규표현식을 테스트해보고 응용해보기아래의 사이트에서 정규표현식이 어떻게 동작하는지 직접 작성하며 결과를 확인할 수 있습니다.https://regexr.com 위에서 배운 내용들을 실제로 테스트해봤습니다. 또한 응용해서 여러 예제들을 작성하고 결과를 확인할 수 있습니다. 정규표현식의 구조를 그림으로 확인해보기복잡한 정규표현식을 작성하다보면 구조가 어떻게 되는지, 정규표현식의 어느 부분이 먼저 실행되는지 궁금할 때가 있습니다. 아래의 사이트에서 정규표현식의 구조를 쉽게 이해할 수 있도록 그림으로 보여줍니다. https://diagramsregexper.com 정리정규표현식을 처음 활용해야 할 때 막막했습니다. 필요한 기능의 정규표현식을 구글링해서 복사, 붙여넣기해서 돌려보기도 하였습니다. 제가 원하는 기능과 똑같이 동작하는 정규표현식을 찾기는 어려웠습니다. 기본부터 공부하고 작성해보니 그렇게 어려운 것만은 아니었습니다. 여러분도 위에 사이트들을 참고해서 정규표현식에 조금이라도 익숙해지길 바랍니다. 읽어주셔서 감사합니다.","categories":[{"name":"Regex","slug":"Regex","permalink":"https://appleceo.github.io/categories/Regex/"}],"tags":[{"name":"Regex","slug":"Regex","permalink":"https://appleceo.github.io/tags/Regex/"},{"name":"정규표현식","slug":"정규표현식","permalink":"https://appleceo.github.io/tags/정규표현식/"},{"name":"공부 방법","slug":"공부-방법","permalink":"https://appleceo.github.io/tags/공부-방법/"}]},{"title":"Initializer","slug":"Initializer","date":"2019-06-09T01:55:37.000Z","updated":"2021-07-13T05:30:19.383Z","comments":true,"path":"2019/06/09/Initializer/","link":"","permalink":"https://appleceo.github.io/2019/06/09/Initializer/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 이니셜라이저에 대해서 알아보겠습니다. “이니셜라이저”란?이니셜라이저는 한글로 초기화입니다. 초기화하면 어떤 단어가 생각나시나요? 리셋, 재부팅 같은 단어가 생각납니다. 그렇습니다. 초기상태로 셋팅해주는 것을 초기화라고 합니다. 스위프트에서 “이니셜라이저”란?구조체와 클래스을 활용하고자 한다면 초기화해주어야 합니다. 이니셜라이저는 새로운 인스턴스를 만들어주는 과정이라고 할 수 있습니다. 이니셜라이저라는 작업을 통해 스위프트는 구조체와 클래스에 메모리를 할당하여 인스턴스로 만들어줍니다. 스위프트에서는 모든 프로퍼티(속성)에 값이 할당되어야 정상적으로 초기화가 되었다고 인식하며 하나의 프로퍼티라도 값이 할당되지 않았다면 오류가 발생합니다. 구조체의 이니셜라이저구조체를 선언하면 자동으로 생성되는 이니셜라이저들과 직접 구현하는 사용자 지정 이니셜라이저, 실패할 수 있는 이니셜라이저까지 3가지 이니셜라이저를 사용할 수 있습니다. 구조체 - 자동으로 생성되는 이니셜라이저(Default Initializers)자동 생성 이니셜라이저에는 아래와 같은 이니셜라이저들이 있습니다. 기본 이니셜라이저(Default Initializer) 멤버와이즈 이니셜라이저(Memberwise Initializers) 먼저 기본 이니셜라이저에 대해 알아보겠습니다. 만약 옵셔널 타입이 아닌 모든 저장 프로퍼티에 초기값이 설정되있다면 기본 이니셜라이저를 사용할 수 있습니다. tv 인스턴스를 초기화할 때 TV 구조체의 기본 이니셜라이저를 사용했습니다. tv 인스턴스가 생성이 되면 channel 저장 프로퍼티에 초기값인 1이 저장됩니다. 옵셔널이 아닌 모든 저장 프로퍼티에 값이 할당되어있기 때문에 정상적으로 초기화가 되었습니다. 이번에는 멤버와이즈 이니셜라이저(Memberwise Initializers) 에 대해 알아보겠습니다. 모든 저장 프로퍼티의 이름과 할당할 값을 매개변수로 넣으면서 초기화하는 것입니다. TV 의 모든 저장 프로퍼티인 channel 을 매개변수로 초기화합니다. 이렇게 초기화를 하면 channel 저장 프로퍼티에 기본값인 1이 아니라 15가 저장됩니다. 구조체 - 사용자 지정 이니셜라이저위에 기본으로 제공되는 이니셜라이저가 아니라 직접 기능들을 구현해 만들 수 있는 사용자 지정 이니셜라이저가 있습니다. 사용자 지정 이니셜라이저를 선언한 경우 위에서 설명한 자동으로 생성되는 이니셜라이저들은 사용할 수 없습니다. 위에 소스는 기본 이니셜라이저 중 멤버와이즈 이니셜라이즈와 동일하게 동작하는 사용자 지정 이니셜라이저입니다. 이번 예제 또한 channel 만 매개변수로 받지만 brand 저장 프로퍼티에 “LG” 를 저장하도록 구현해놓았습니다. 모든 저장 프로퍼티에 값이 들어갔고 정상적으로 초기화가 됩니다. 선언한 이니셜라이저에게 초기화를 위임하는 위임 이니셜라이저도 있습니다. 위에서 init() 은 self.init 을 통해 위에서 선언한 init(channel: Int) 에게 초기화를 위임합니다. 구조체 - 실패할 수 있는 이니셜라이저꼭 성공하지 않아도 된다면 실패할 수 있는 이니셜라이저를 사용할 수 있습니다. 꼭 인스턴스가 생성되는 것이 아니라 nil이 반환될 수 있습니다. animal 변수에는 실패했기 때문에 nil이 저장되며 animal 의 타입은 Animal?(옵셔널) 입니다. 클래스의 이니셜라이저지정 이니셜라이저와 편의 이니셜라이저, 실패할 수 있는 이니셜라이저, 필수 이니셜라이저까지 4가지 이니셜라이저를 사용할 수 있습니다. 클래스 - 지정 이니셜라이저(designated initializer)지정 이니셜라이저는 구조체의 사용자 지정 이니셜라이저와 유사합니다. 위와 같이 할당되지 않은 저장 프로퍼티가 없도록 init 을 선언해주는 것이 지정 이니셜라이저입니다.클래스를 상속했을 때 이니셜라이저는 아래와 같은 규칙을 지켜야합니다. 자식 클래스의 지정 이니셜라이즈는 부모 클래스의 지정 이니셜라이저를 호출해야만 합니다. 위에 예제에 Square 클래스의 지정 이니셜라이저는 부모 클래스인 Shape 의 지정 이니셜라이저(super.init)를 호출해야만 합니다. 자식 클래스의 모든 저장 프로퍼티에 값이 할당된 후에 부모 클래스의 지정 이니셜라이저를 호출해야 합니다. 위에 예제에 Square 클래스의 sideLength 저장 프로퍼티에 값을 할당한 후에 super.init 을 호출해야만 합니다. 자식 클래스에 저장 프로퍼티가 없어서 지정 이니셜라이저가 선언되지 않았다면 부모 클래스의 지정 이니셜라이저가 상속됩니다. 위에 예제에 Square 에 저장 프로퍼티가 없기 때문에 지정 이니셜라이저를 선언하지 않을 수 있었습니다.이러한 경우 부모 클래스의 지정 이니셜라이저가 상속됩니다. 클래스 - 편의 이니셜라이저(convenience initializer)편의 이니셜라이저는 구조체의 이니셜라이저 위임과 유사한 점이 있습니다. 필요에 따라 매개변수를 다르게 해서 지정 이니셜라이저를 호출하여 초기화하는 방법입니다. 편의 이니셜라이저는 무조건 자신의 지정 이니셜라이저를 호출해야 합니다. convenience init 은 self.init 으로 자신의 지정 이니셜라이저를 호출하고 있습니다. 부모 클래스의 모든 지정 이니셜라이저를 오버라이딩해준 경우 부모의 편의 이니셜라이저들도 상속됩니다.위에 예제에서 RecipeIngredient 클래스는 부모 클래스의 지정 이니셜라이저init(name: String) 을 오버라이딩합니다. 위에 규칙을 지켰기 때문에 RecipeIngredient 클래스는 부모 클래스의 편의 이니셜라이저 init() 을 상속 받았습니다. oneMysteryItem 인스턴스는 정상적으로 생성됩니다. 클래스 - 실패할 수 있는 이니셜라이저(Failable Initializer)클래스에서도 실패할 수 있는 이니셜라이저를 만들 수 있습니다. anmail 은 nil 이 할당되며 타입은 Animal?(옵셔널)입니다. 클래스 - 필수 이니셜라이저(Required Initializer)부모 클래스에서 필수 이니셜라이저를 선언해주면 자식 클래스들에서 무조건 필수 이니셜라이저를 구현해주어야 합니다. 정리구조체와 클래스의 이니셜라이저에 대해서 알아봤습니다. 잘못된 내용이나 궁금하신 점은 댓글 부탁드립니다. 감사합니다.","categories":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/tags/Swift/"},{"name":"Initializer","slug":"Initializer","permalink":"https://appleceo.github.io/tags/Initializer/"},{"name":"Initialize","slug":"Initialize","permalink":"https://appleceo.github.io/tags/Initialize/"},{"name":"초기화","slug":"초기화","permalink":"https://appleceo.github.io/tags/초기화/"},{"name":"이니셜라이저","slug":"이니셜라이저","permalink":"https://appleceo.github.io/tags/이니셜라이저/"}]},{"title":"클로저와 고차함수","slug":"closureAndHigherOrderFunction","date":"2019-06-08T23:42:32.000Z","updated":"2021-07-13T05:30:19.388Z","comments":true,"path":"2019/06/09/closureAndHigherOrderFunction/","link":"","permalink":"https://appleceo.github.io/2019/06/09/closureAndHigherOrderFunction/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 클로저와 고차함수에 대해서 알아보겠습니다. 클로저란?클로저는 기능을 갖는 독립적인 코드 블록입니다. 말이 조금 어려운데요. 기능을 갖는 코드 블록을 우리는 이미 알고 있습니다. 맞습니다. 함수입니다. 그렇다면 함수와 클로저의 차이는 무엇일까요? 아래 설명을 보시면 이해하실 수 있으실 겁니다. 클로저를 선언하는 방법은?클로저는 선언하는 부분에서부터 함수와 차이점을 보입니다. 클로저는 함수와 달리 이름을 적지않습니다. 이름을 적지 않음으로써 아래와 같은 사실을 알 수 있습니다. 클로저는 선언해놓고 호출하는 방식이 아니라 필요할 때마다 코드 블록을 작성해야한다. 자주 사용하는 코드 블록을 선언해놓는 함수와 달리 매번 다른 코드 블록을 사용할 때 필요할 것 같다. 그렇다면 클로저를 사용하려면 매번 긴 코드 블록을 직접 작성해야할까요? 이러한 문제를 해결하기 위해 클로저는 축약형을 제공합니다. 아래 nameSorted1부터 nameSorted8 까지의 상수들은 모두 같은 순서의 배열을 갖습니다. 다만 애플은 축약형보다 풀어서 쓰는 것을 선호한다고 합니다. 클로저의 활용 방안은?map 의 전달인자로 사용할 수 있습니다.map 고차함수는 배열의 전체 요소들에 대해 동시에 더하기, 곱하기, 형변환 등의 작업을 할 때 사용할 수 있습니다. 만약 numbers 라는 배열이 있는데 각 요소에 3을 곱한 배열이 필요하다고 합시다. 아래처럼 배열을 초기화하고 for 문을 돌려서 threeTimesNumbers 배열을 채울 수 있을 것입니다. 이러한 상황에서 map 을 사용하면 한번에 그리고 상수 타입으로 배열을 저장할 수 있습니다. 스위프트는 변수보다 상수의 활용을 권장하기 때문에 이러한 점은 굉장한 메리트가 될 수 있습니다. 공식문서에 있는 예제입니다. map 함수를 이용해 숫자를 문자열로 나타내도록 실행됩니다. 기준에 따라 합격 불합격을 저장할 수도 있습니다. filter 의 전달인자로 사용할 수 있습니다.filter 고차함수는 조건에 따라 배열의 요소를 추출하는데 사용합니다. 예를 들어 점수가 80점 초과인 요소들만 뽑아낼 수 있습니다. 짝수만 뽑아낼 수도 있습니다. reduce 의 전달인자로 사용할 수 있습니다.reduce 고차함수는 배열 요소의 총합, 전체 요소 빼기, 전체 요소 곱하기 등 전체 요소를 종합하는데 사용할 수 있습니다. 정리이상으로 클로저에 대한 설명을 마치도록 하겠습니다. 클로저와 고차함수를 활용하면 for 문과 append, 변수의 사용을 줄일 수 있을 것입니다. 설명 중 틀린 점이나 궁금하신 점은 댓글로 남겨주시면 답변 드리도록 하겠습니다. 읽어주셔서 감사합니다.","categories":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/tags/Swift/"},{"name":"Function","slug":"Function","permalink":"https://appleceo.github.io/tags/Function/"},{"name":"Closure","slug":"Closure","permalink":"https://appleceo.github.io/tags/Closure/"},{"name":"Higher-order function","slug":"Higher-order-function","permalink":"https://appleceo.github.io/tags/Higher-order-function/"},{"name":"고차함수","slug":"고차함수","permalink":"https://appleceo.github.io/tags/고차함수/"}]},{"title":"열거형","slug":"enum","date":"2019-06-08T15:10:56.000Z","updated":"2021-07-13T05:30:19.389Z","comments":true,"path":"2019/06/09/enum/","link":"","permalink":"https://appleceo.github.io/2019/06/09/enum/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 스위프트의 열거형에 대해서 알아보겠습니다. 열거형 이란?열거는 무슨 뜻일까요? 국어사전에 검색해보았습니다. “여러 가지 예나 사실을 낱낱이 죽 늘어놓음.” 이라고 나옵니다. 그렇다면 열거형은 “여러 가지 예나 사실을 낱낱이 죽 늘어놓음” + “형태” 라고 이해할 수 있겠습니다. 스위프트에서 열거형 이란?스위프트에서 열거형은 Enumeration 이라고 합니다. 줄여서 Enum 이라고도 합니다. 열거형은 같은 성질을 가지는 여러 것들을 늘어놓는데 사용할 수 있습니다. 예를 들어 무게라는 성질을 가지는 것에는 어떤 것이 있을까요? g, kg, oz, lb 등이 있습니다. 이러한 한가지 성질을 가지는 것들을 묶어서 사용하는데 용이한 타입이 열거형입니다. 열거형을 선언하는 방법은?스위프트에서 열거형은 아래처럼 선언할 수 있습니다. 예를 들어 나침반의 점은 아래 4가지 케이스로 선언할 수 있습니다. 아래처럼 여러 케이스들을 한 줄로 표현할 수도 있습니다. 열거형의 활용 방안은?열거형은 Switch 문과 결합해서 사용할 수 있습니다.열거형의 특징은 어떤 것이 있을까요? 위에서 언급했다시피 한가지 특징을 가지는 여러 것들을 묶어서 사용합니다. 한가지 특징을 여러 케이스로 나누는 특징이 있습니다. 이런 식으로 여러 케이스로 나누어 처리하는 방식은 익숙하지 않으신가요? 그렇습니다. Switch 문과 Enum 은 밀접한 관계가 있습니다. 아래에서 directionToHead 는 .south 케이스를 따르기 때문에 Watch out for penguins 이 출력됩니다. 아래의 예제는 Planet 에서 earth 일 때만 처리를 해주고 있습니다. 이에서 볼 수 있듯이 enum 의 케이스 별로 꼭 switch 문에 case 를 선언해 줄 필요는 없습니다. 여러 케이스에 대해 반복작업을 할 때도 좋습니다.한가지 특징에 대해 여러가지 케이스를 가지는 반복 작업을 할 때에도 열거형을 활용할 수 있습니다. 아래와 같이 CaseIterable 프로토콜을 채택하면 allCases 를 사용할 수 있습니다. 위에 소스에서 case 는 3가지 이므로 numberOfChoices 상수에는 3 이 들어갑니다. for 문에서도 allCases 를 사용하면 모든 case 에 대해 반복할 수 있습니다. beverage 에 Beverage 의 케이스인 coffee, tea, juice 가 차례로 들어가면서 반복됩니다. 타입으로 만들 수 도 있습니다.예를 들어 Json 의 타입은 아래처럼 선언할 수 있습니다. 여기에서 (Int) 라고 적혀있는 부분은 연관값(Associated Value) 이라고 하며 해당 케이스를 따르면 Int 형을 저장할 수 있다는 뜻입니다. 괄호 안의 값을 저장하는 case 들을 만들 수 있는 것입니다. 아래의 예제에서 JsonType 을 따르는 여러 변수를 만들어봤습니다. 이러한 JsonType 은 어떤 타입만 사용할지 정할 수 있습니다. 예를 들어 JsonType 의 enum 변수에는 [Int:String] 과 같은 딕셔너리를 저장할 수 없습니다. 위에서 선언한 Int, String, Bool, [String: JsonType], JsonType 배열만 저장하고 사용할 수 있습니다. 공식 문서에 있는 Barcode 도 비슷한 예제입니다. Barcode 라는 타입을 만들었다고 할 수 있습니다. Barcode 에는 upc 케이스를 따를 경우 Int 4개가 들어가거나 qrCode 케이스의 문자열만 저장할 수 있습니다. 동일한 유형의 기본값을 저장할 수 있습니다.한가지 타입의 데이터들을 모아서 저장하고 싶은 경우에도 열거형은 좋은 대안이 될 수 있습니다. 특수문자들을 모아서 저장한 예제입니다. 이제 “[“ 라고 비교하는 것보다 체계적으로 특수문자들을 관리할 수 있습니다. rawValue 의 몇가지 특징을 더 설명해드리겠습니다. Int 타입을 rawValue 로 가지도록 아래와 같이 선언하고 case 에 값을 할당하지 않는다면 각 케이스에 0부터 차례대로 rawValue 값이 할당됩니다. 만약에 첫 case 에 1을 할당한다면 그 뒤에 case 들은 다음 숫자인 2부터 채워집니다. String 을 rawValue 로 가지도록 선언해놓고 case 에 값을 할당하지 않는다면 case 의 이름이 자동으로 할당됩니다. 예를 들어 north case 의 rawValue 는 “north” 입니다. 정리이상으로 열거형 Enum 에 대한 설명을 마치도록 하겠습니다. 열거형은 Swift 에서 구조체와 함께 활용을 권장하는 것으로 알고 있습니다. 이러한 특징들을 잘 활용하셔서 Enum 을 사용하는데 조금이라도 도움이 되었으면 좋겠습니다. 틀린 점이나 궁금하신 점은 댓글로 남겨주시면 답변 드리도록 하겠습니다. 긴 글 읽어주셔서 감사합니다.","categories":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/tags/Swift/"},{"name":"Enum","slug":"Enum","permalink":"https://appleceo.github.io/tags/Enum/"},{"name":"Enumeration","slug":"Enumeration","permalink":"https://appleceo.github.io/tags/Enumeration/"},{"name":"열거형","slug":"열거형","permalink":"https://appleceo.github.io/tags/열거형/"}]},{"title":"SOLID 원칙","slug":"SOLID","date":"2019-05-16T09:54:00.000Z","updated":"2021-07-13T05:30:19.386Z","comments":true,"path":"2019/05/16/SOLID/","link":"","permalink":"https://appleceo.github.io/2019/05/16/SOLID/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 SOLID 에 대해 정리해보겠습니다. SOLID 는 5가지 원칙을 가지고 있습니다. 하나씩 예시를 들어가며 설명해드리겠습니다. 1. SRP (Single Responsibility Principle)첫번째는 단일 책임 원칙입니다. 작성한 클래스는 하나의 기능과 책임을 가져야만 한다는 원칙입니다. 아래와 같이 기타 구조체를 생성했다면 SRP 원칙에 위반되는 것입니다. 왜냐하면 price 부터 maker, type, model, backWood, topWood, stringNum 은 기타의 모델과 상태에 따라 달라질 수 있기 때문입니다. 수정이 일어날 때마다 Guitar 클래스를 변경해주어야하므로 안정적이지 않습니다. 아래와 같이 SRP 원칙을 적용할 수 있습니다. 기타의 변동 가능한 부분이 따로 GuitarSpec 이라는 구조체에 저장이 되었습니다. 변경이 발생하면 GuitarSpec 만 변경하면 됩니다. 보기에도 좋고 변경이 가능한 부분을 한곳에서 관리할 수 있습니다. 2. OCP(Open Close Principle)두번째는 개방 폐쇄의 원칙입니다. 소프트웨어의 구성요소는 확장에는 열려있고 변경에는 닫혀있어야한다는 원리입니다. 확장은 쉽게 할 수 있고 변경은 최소화할 수 있어야 한다는 뜻이겠습니다. 만약 위에 Guitar 와 GuitarSpec 구조체에 이어서 Violin 과 여러 현악기가 추가되어야 한다면 매번 악기 이름의 구조체와 악기 스팩을 갖는 구조체를 추가해주어야 할까요? 이러한 상황이라면 OCP 원칙을 고려해볼 수 있습니다. 위와 같이 현악기 클래스를 선언했습니다. 이제 기타, 바이올린 등 어떤 현악기를 추가할 때든 StringInstrument 와 StringInstrumentSpec 을 상속받아서 간단히 추가할 수 있습니다. 코드의 수정을 최소화하여 결합도는 줄이고 응집도는 높이는 효과를 볼 수 있습니다. 3. LSP(The Liskov Substitution Principle)세번째는 리스코브 치환의 원칙입니다. “서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다.”라고 할 수 있습니다. 서브 타입은 기반 타입이 약속한 규약(public 인터페이스, 물론 메소드가 던지는 예외까지 포함됩니다.)을 지켜야 합니다. 현악기 클래스에 play 라는 메서드를 추가해주었습니다. 또한 기타와 바이올린에 play 라는 메서드를 오버라이딩 해주었습니다. 결과를 보면 현악기 클래스 변수에 서브 타입인 바이올린과 기타가 자유롭게 들어갈 수 있고 기반 타입인 “안알려진 현악기” 또한 자유롭게 들어갈 수 있습니다. 또한 상위 클래스에서 선언한 play 메서드 또한 하위 클래스에서 호출할 수 있습니다. 이렇게 서브 타입이 기반 타입으로 자유롭게교체될 수 있는 것이 LSP 원리입니다. 4. ISP(Interface Segregation Principle)네번째는 인터페이스 분리의 원칙입니다. 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원리입니다. 인터페이스를 나눌 수 있으면 나누고 필요없는 인터페이스는 제거해야합니다. “칠 수 있는” 이라는 프로토콜을 선언했습니다. 현악기는 칠 수 있는 프로토콜을 채택했고 손으로 연주하는 메서드와 도구를 이용해서 연주하는 메서드를 선언해줬습니다. 구현은 제대로 되었지만 바이올린은 도구를 이용해서만 연주할 수 있는데 손으로도 칠 수 있는 등 완전하지 않게 동작합니다. 이제 ISP 원칙에 따르도록 수정해보겠습니다. 두개의 프로토콜로 나눠주었습니다. 5. DIP(Dependency Inversion Principle)다섯번째는 의존성 역전의 원칙입니다. 하위 클래스는 당연히 상위 클래스에 의존해야합니다. 하지만 하위 클래스의 모듈의 변경이나 기능에 상위 클래스가 의존성을 갖게 되는 현상을 의존성 역전이라고 합니다. 예를 들어 조금 전의 예제 소스는 기타만 손으로 칠 수 있는 상황이었는데 현악기가 Playable 프로토콜을 채택함에 따라 현악기를 상속받는 모든 악기는 playWithHands 메서드를 사용할 수 있었습니다. DIP 원칙에 따라 현악기에는 도구로 칠 수 있다는 프로토콜만 채택했습니다. 아래와 같이 기타는 손으로도 칠 수 있기 때문에 “손으로 칠 수 있다”는 프로토콜도 채택하였습니다. 이제 현악기 타입의 클래스 변수에서 playWithHands 는 오류가 발생합니다. 기타 타입으로 선언해야만 playWithHands 를 호출할 수 있기 때문에 조금 더 안정적이며 명확해졌습니다.","categories":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/tags/Swift/"},{"name":"SOLID","slug":"SOLID","permalink":"https://appleceo.github.io/tags/SOLID/"}]},{"title":"Pattern and Pattern Maching","slug":"PatternMaching","date":"2019-05-03T06:12:41.000Z","updated":"2021-07-13T05:30:19.385Z","comments":true,"path":"2019/05/03/PatternMaching/","link":"","permalink":"https://appleceo.github.io/2019/05/03/PatternMaching/","excerpt":"","text":"안녕하세요. 도미닉입니다 오늘은 패턴에 대해서 알아보겠습니다. 패턴이란 소스의 양을 줄여서 쓰고 읽기 쉽게 정해놓은 구조 라고 생각할 수 있습니다. 패턴 매칭이란. 코드에서 패턴을 찾아내고 활용하는 것이라고 할 수 있겠습니다. 패턴에는 두가지 큰 유형이 있습니다. 모든 종류의 값에서 성공적으로 동작하는 패턴과 런타임 안에 지정된 값에 따라서 동작하지 못하는 패턴입니다. 첫 번째 종류의 패턴은 단순 변수, 상수 및 옵셔널 바인딩에서 값을 소멸시키는 데 사용됩니다. 여기에는 와일드 카드 패턴, 식별자 패턴 및 이를 포함하는 값 바인딩 패턴 또는 튜플 패턴이 포함됩니다. 이러한 패턴에서 타입 지정하여 특정 타입의 값만 일치하도록 제한 할 수 있습니다. 두 번째 종류의 패턴은 전체 패턴 일치에 사용되며, 여기서 일치시키려는 값은 런타임에 없을 수 있습니다. 여기에는 열거 케이스 패턴, 선택적 패턴, 표현식 패턴 및 타입 캐스팅 패턴이 포함됩니다. 이러한 패턴은 switch 문의 case 레이블, do 문의 catch 절 또는 if, while, guard 또는 for-in 문의 경우에서만 사용됩니다. Wildcard Pattern(와일드카드 패턴)Wildcard Pattern 은 밑줄 (_)로 모든 값을 무시하도록사용할 수 있습니다. 값을 쓰지 않으면 와일드 카드 패턴을 사용할 수 있습니다. 예를 들어, 다음 코드는 루프의 각 반복에서 범위의 현재 값을 무시하고 범위 1 ~ 3을 반복합니다. 만약 _ 를 x로 바꾼다면 x에 1,2,3이 들어가며 반복될 것이다. 값이 필요없다면 _ 를 사용한다. Identifier Pattern (식별자 패턴)Identifier Pattern 은 모든 값에서 사용 가능하며 값을 변수 또는 상수의 이름에 바인딩합니다. 예를 들어, 다음 상수 선언에서 someValue 는 Int 타입의 값 42와 매칭되는 식별자 패턴입니다. Value-Binding Pattern (값 바인딩 패턴)Value-Binding Pattern 은 값을 변수 또는 상수 이름에 바인딩합니다. 상수의 이름에 바인드하는 Value-Binding Pattern 은 let 키워드로 시작합니다. 변수 이름에 바인드하는 Value-Binding Pattern은 var 키워드로 시작합니다. Value-Binding Pattern 내의 Identifier Pattern 은 새로운 이름의 변수 또는 상수를 일치하는 값에 바인딩합니다. 예를 들어 튜플의 요소를 분해하고 각 요소의 값을 해당 Identifier Pattern 에 바인딩 할 수 있습니다. 위의 예제에서 튜플 패턴 (x, y)의 x, y를 Identifier Pattern 에 분배합니다. 이 방식으로 인해 switch case let (x, y):와 case (let x, let y): 은 같은 동작을 합니다. Tuple Pattern (튜플 패턴)Tuple Pattern 은 괄호로 묶인 0 개 이상의 패턴을 쉼표로 구분 한 목록입니다. Tuple Pattern 은 해당 튜플 타입의 값과 매칭됩니다. 튜플 요소의 타입을 선언해주어서 특정 타입의 튜플과만 매칭되도록 Tuple Pattern 을 제한 할 수 있습니다. 예를 들어, let (x, y) : (Int, Int) = (1, 2) 상수 선언에서 튜플 패턴 (x, y) : (Int, Int) 은 두 요소가 모두 Int 타입인 튜플 타입입니다. Tuple Pattern 이 for-in 문이나 변수 또는 상수 선언의 패턴으로 사용될 때 Wildecard Pattern, Identifier Pattern, Optional Pattern 또는 이를 포함하는 다른 Tuple Pattern 만 포함 할 수 있습니다. 예를 들어, 튜플 패턴 (x, 0)의 요소 0이 Expression Pattern 이므로 아래 코드는 유효하지 않습니다. 단일 요소를 포함하는 Tuple Pattern 주위의 괄호는 아무 효과가 없습니다. 패턴은 단일 요소의 타입과 일치합니다. 예를 들어, 다음은 동일합니다. Enumeration Case Pattern (열거형 케이스 패턴)Enumeration Case Pattern 은 기존 열거형 타입과 일치합니다. Enumeration Case Pattern 은 switch 문 안에서 case 뒤에 if, while, guard, for-in 문이 있는 경우 사용됩니다. 일치시키려는 열거형에 연결된 값이있는 경우 해당 Enumeration Case Pattern 은 각 관련 값에 대해 하나의 요소가 포함된 Tuple Pattern을 지정해야합니다. Optional Pettern (옵셔널 패턴)Optional Pettern 은 Optional 열거형의 일부 (래핑된) 경우에 래핑된 값과 매칭합니다. Optional Pettern 은 Identifier Pettenr 과 그 뒤에 바로 붙은 물음표로 구성되며 Enumeration Case Patterns 과 동일한 위치에 나타납니다. Optional Pettern 은 Optional Enumeration Case Patterns 에 대한 더욱 더 간결하고 명확하게 표현이 가능한 문법이므로 다음은 동일합니다. Optional Pettern 은 for-in 문에서 Optional 값의 배열을 반복할 수있는 편리한 방법을 제공합니다. 이 패턴은 루프의 본문을 nil 이 아닌 요소에만 실행합니다. Type-Casting Patterns (타입 캐스팅 패턴들)Type-Casting Patterns 는 is 패턴과 as 패턴이 있습니다. is 패턴은 switch 문 case 레이블에만 나타납니다. is 및 as 패턴은 다음 형식을 갖습니다. is 패턴은 실행 시 해당 값의 유형이 is 패턴의 오른쪽에 지정된 유형 또는 해당 유형의 서브 클래스와 동일한 경우 값과 일치합니다. is 패턴은 is 연산자와 같이 타입 캐스트를 수행하지만리턴된 타입은 버린다는 점에서 다릅니다. as 패턴은 실행 시 해당 값의 유형이 as 패턴의 오른쪽에 지정된 유형 또는 해당 유형의 서브 클래스와 동일한 경우 값을 찾습니다. 일치가 성공하면 일치된 값의 유형이 as 패턴의 오른쪽에 지정된 타입으로 변환됩니다. Expression Pattern (표현식 패턴)Expression Pattern 은 표현식의 값을 나타냅니다. Expression Pattern 은 switch 문 case 에만 나타납니다. Expression Pattern 으로 표현된 표현식은 Swift 표준 라이브러리 ~ = 연산자를 사용하여 입력 표현식의 값과 비교됩니다. ~ = 연산자가 true를 반환하면 일치가 성공합니다. 기본적으로 ~ = 연산자는 == 연산자를 사용하여 같은 유형의 두 값을 비교합니다. 또한 다음 예에서와 같이 값이 범위에 포함되는지 여부를 확인하여 범위의 값과 값을 일치시킬 수도 있습니다. ~ = 연산자를 오버로드하여 사용자가 정의한 대로 타입을 맞출 수 있습니다. 예를 들어 위의 예제를 다시 작성하여 point 표현식을 point 의 문자열 표현식과 비교할 수 있습니다. 출처 : https://docs.swift.org/swift-book/ReferenceManual/Patterns.html#grammar_wildcard-pattern","categories":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/tags/Swift/"},{"name":"Pattern","slug":"Pattern","permalink":"https://appleceo.github.io/tags/Pattern/"},{"name":"Maching","slug":"Maching","permalink":"https://appleceo.github.io/tags/Maching/"}]},{"title":"Oveloading and Overriding","slug":"oveloadingAndOverriding","date":"2019-04-29T02:09:08.000Z","updated":"2021-07-13T05:30:19.393Z","comments":true,"path":"2019/04/29/oveloadingAndOverriding/","link":"","permalink":"https://appleceo.github.io/2019/04/29/oveloadingAndOverriding/","excerpt":"","text":"안녕하세요. 도미닉입니다. 오늘은 오버로딩과 오버라이딩에 대해서 알아보겠습니다. 오버로딩(overloading) 이란 같은 이름의 메소드를 매개변수가 다르게 여러번 선언할 수 있는 것을 의미합니다. 오버로딩에는 생성자 오버로딩과 메소드 오버로딩이 있습니다. init 생성자를 매개변수 숫자를 다르게 해서 두번 선언했습니다. 이러한 것을 생성자 오버로딩이라고 합니다. eat 메서드를 매개변수 숫자를 다르게 해서 두번 선언했습니다. 이러한 것을 메서드 오버로딩이라고 합니다. 오버라이딩(overriding) 은 상위 클래스에서 선언한 메서드를 하위 클래스에서 재정의해서 사용하는 것을 의미합니다. 위에 오버로딩의 예제를 들었던 소스에서 People 클래스의 eat 메서드를 선언했었습니다. Student 클래스는 People 클래스를 상속받습니다. eat 라는 메서드를 재정의하려고 하자 오류가 발생했습니다. Overriding 임에도 불구하고 override 라는 키워드를 앞에 적어주지 않아서 오류가 발생합니다. 앞에 override 를 붙여주니 제대로 실행 되었습니다. 오버라이딩은 매개변수의 이름이나 타입이 달라지면 오류 발생합니다. 오버로딩과 오버라이딩의 성립 조건은 아래 표와 같습니다. 구분오버로딩(Overloading)오버라이딩(Overriding)메서드 이름동일동일매개변수의 이름, 타입다름동일리턴 타입상관없음동일","categories":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/tags/Swift/"},{"name":"Overloading","slug":"Overloading","permalink":"https://appleceo.github.io/tags/Overloading/"},{"name":"Overriding","slug":"Overriding","permalink":"https://appleceo.github.io/tags/Overriding/"}]},{"title":"Protocol and Polymorphism","slug":"Protocol-and-Polymorphism","date":"2019-04-24T08:25:11.000Z","updated":"2021-07-13T05:30:19.385Z","comments":true,"path":"2019/04/24/Protocol-and-Polymorphism/","link":"","permalink":"https://appleceo.github.io/2019/04/24/Protocol-and-Polymorphism/","excerpt":"","text":"안녕하세요. 도미닉입니다. 프로토콜과 다형성에 대해 정리해보겠습니다. 프로토콜은 특정 역할을 하기 위해 메서드, 프로퍼티 등을 정의하는 것입니다. 프로토콜을 채택하면 해당 프로토콜에서 정의되있는 메서드, 프로퍼티를 무조건 구현해주어야 합니다. Food 프로토콜을 채택하였는데 eat 메서드를 작성하지 않아서 오류가 발생한 상태위와 같이 Food 라는 프로토콜에 eat 메서드를 정의하였습니다. 스파게티 구조체가 Food 프로토콜을 채택하였으나 eat 메서드가 존재하지 않아서 오류가 발생하였습니다. 동그라미를 클릭해서 오류 해결을 자동으로 요청하니 아래와 같이 eat 메서드가 생기고 구현부가 생성되었습니다. eat 메서드가 추가되니 오류가 사라졌습니다. 스파게티, 햄버거, 피자 구조체 작성했습니다. 위와 같이 스파게티, 햄버거, 피자 구조체를 Food 프로토콜을 채택해서 작성했습니다. 이제 스파게티, 햄버거, 피자는 Food 프로토콜을 따르기 때문에 무조건 eat 메서드가 있다고 안심할 수 있습니다. 프로토콜에 정의된 프로퍼티, 메서드는 해당 프로토콜을 채택한 객체에서 안전하게 수행된다고 보장됩니다. 스파게티와 피자 인스턴스를 생성했습니다. 스파게티 구조체와 피자 구조체는 Food 타입인 food 프로토콜 변수에 저장할 수 있고 eat 메서드를 사용할 수 있습니다. 먼저 food 프로토콜 변수에 스파게티 구조체를 넣고 eat 메서드를 실행시켰습니다. 스파게티 구조체에 eat 메서드에 구현한 “스파게티를 포크로 먹어치웠습니다.” 문구가 출력됩니다. 그 다음에 pizza 구조체를 food 프로토콜 변수에 넣고 eat 메서드를 실행시키니 피자 구조체에 구현한 문구가 정상적으로 출력됩니다. 프로토콜의 이러한 특징을 다형성(Polymorphism)이라고 합니다. 다형성(Polymorphism)이란 객체들의 형태는 다양하게 가질 수 있지만 프로토콜을 채택했거나 클래스를 상속 받았다면 해당 프로토콜과 상위 클래스에서 정의한 기능은 무조건 수행될 것이라고 예측할 수 있는 특성입니다.","categories":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/tags/Swift/"},{"name":"Protocol","slug":"Protocol","permalink":"https://appleceo.github.io/tags/Protocol/"},{"name":"Polymorphism","slug":"Polymorphism","permalink":"https://appleceo.github.io/tags/Polymorphism/"},{"name":"다형성","slug":"다형성","permalink":"https://appleceo.github.io/tags/다형성/"},{"name":"프로토콜","slug":"프로토콜","permalink":"https://appleceo.github.io/tags/프로토콜/"}]},{"title":"Structure","slug":"structure","date":"2019-04-17T07:54:26.000Z","updated":"2021-07-13T05:30:19.396Z","comments":true,"path":"2019/04/17/structure/","link":"","permalink":"https://appleceo.github.io/2019/04/17/structure/","excerpt":"","text":"오늘은 스위프트의 구조체에 대해서 알아보겠습니다. struct 이름 { 프로퍼티 메서드} 위와 같은 형태로 선언할 수 있습니다. 예를 들면 고양이 구조체는 아래와 같이 선언할 수 있습니다. 구조체는 자동으로 생성된 이니셜라이저를 통해 생성할 수 있습니다. var yaong: Cat = Cat(name: “yaong”, age: 5) 또는 아래와 같이 직접 이니셜라이저 메서드를 선언해줄 수 있습니다. 직접 이니셜라이저 메서드를 선언해주면 기본으로 생성된 이니셜라이저는 사용하실 수 없습니다. 위에서 인스턴스를 만들어주는 소스는 직접 만든 이니셜라이저를 따르지 않기 때문에 오류가 발생합니다. 직접 만든 이니셜라이저 메서드를 따라서 아래와 같이 인스턴스를 만드는 부분을 변경하였습니다. var yaong: Cat = Cat(nameEntred: “yaong”) 프로퍼티를 선언할 때 var로 선언해 가변 프로퍼티이면 아래와 같이 값을 변경하실 수 있습니다. yaong.age = 2 lat으로 선언한 name 불변 프로퍼티는 변경할 수 없습니다. 또한 인스턴스를 만들 때 let 으로 선언한 불변 인스턴스라면 가변 프로퍼티라도 변경할 수 없습니다. 이상 기본적인 구조체의 구조에 대해서 알아봤습니다.","categories":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/tags/Swift/"},{"name":"Structure","slug":"Structure","permalink":"https://appleceo.github.io/tags/Structure/"}]},{"title":"Property","slug":"property","date":"2019-04-17T07:54:17.000Z","updated":"2021-07-13T05:30:19.394Z","comments":true,"path":"2019/04/17/property/","link":"","permalink":"https://appleceo.github.io/2019/04/17/property/","excerpt":"","text":"앞에서 소개드린 구조체 안에 내용 중에 프로퍼티에 대해서 먼저 알아보겠습니다. 프로퍼티는 저장 프로퍼티, 연산 프로퍼티, 타입 프로퍼티로 나뉘어집니다. 첫번째로 저장 프로퍼티는 가변 프로퍼티와 불변 프로퍼티로 나뉩니다. 구조체는 기본적으로 모든 저장 프로퍼티를 포함하는 이니셜라이저가 자동으로 생성됩니다. 위에 Cat 구조체에서 그것을 사용해보았습니다. 저장 프로퍼티는 기본값을 설정할 수도 있으며 기본값이 있는 경우 이니셜라이저 없이 인스턴스 생성이 가능합니다. 만약 저장 프로퍼티가 옵셔널이면 해당 프로퍼티는 초기값을 넣어주지 않아도 됩니다. 지연 저장 프로퍼티라는 것에 대해서 알려드리겠습니다. 저장 프로퍼티는 호출이 있어야 값을 초기화시킵니다. 인스턴스가 생성될 때 초기화되고 고정되는 불변 프로퍼티에는 적용될 수 없습니다. 가변 프로퍼티 앞에 lazy 를 붙여서 선언할 수 있으며 처음 프로퍼티에 접근하면 초기화됩니다. 두번째 프로퍼티는 연산 프로퍼티입니다. 프로퍼티를 선언할 때 get set 을 추가해놓으면 값이 변경되거나 호출될 때 특정 연산이 진행된 뒤에 프로퍼티를 반환하는 형태입니다. 세번째 프로퍼티는 타입 프로퍼티입니다. 타입 프로퍼티는 저장 타입 프로퍼티와 연산 타입 프로퍼티로 나뉘어집니다.","categories":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://appleceo.github.io/tags/Swift/"},{"name":"Property","slug":"Property","permalink":"https://appleceo.github.io/tags/Property/"}]},{"title":"iOSAppLifeCycle","slug":"iOSAppLifeCycle","date":"2018-07-04T02:44:30.000Z","updated":"2021-07-13T05:30:19.390Z","comments":true,"path":"2018/07/04/iOSAppLifeCycle/","link":"","permalink":"https://appleceo.github.io/2018/07/04/iOSAppLifeCycle/","excerpt":"","text":"iOS 13 앱 사이클사용자 또는 시스템이 앱의 새로운 장면을 요청하면 UIKit 은 이를 생성하고 Unattached 상태로 둡니다.실행 후 UI 가 화면에 표시될 지 여부에 따라 Foreground Inactive 또는 Background 상태가 될 수 있다.화면에 나타나면 시스템은 앱의 상태를 자동으로 Foreground Inactive 와 Foreground Active 상태 사이에서 왔다갔다 변경시킵니다. Unattached: Foreground Inactive : Foreground Active : 사용자가 요청한 scene은 빠르게 화면에 나타납니다. Suspended : Background : 앱을 실행하면 UIApplication 이 생성되고 끝날때까지 유지된다.홈화면은 스프링보드이다. – 작성중 –","categories":[{"name":"iOS","slug":"iOS","permalink":"https://appleceo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://appleceo.github.io/tags/iOS/"},{"name":"App","slug":"App","permalink":"https://appleceo.github.io/tags/App/"},{"name":"LifeCycle","slug":"LifeCycle","permalink":"https://appleceo.github.io/tags/LifeCycle/"}]}]}